<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Revolute Joint 模块</title>
      <link href="/2022/03/31/Revolute-Joint-%E6%A8%A1%E5%9D%97/"/>
      <url>/2022/03/31/Revolute-Joint-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Revolute-Joint-模块"><a href="#Revolute-Joint-模块" class="headerlink" title="Revolute Joint 模块"></a>Revolute Joint 模块</h2><span id="more"></span><p>Joint with one revolute primitive 一个初试的旋转关节</p><ul><li><strong>Library:</strong>Simscape / Multibody / Joints</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>The Revolute Joint block models a joint that has one rotational degree of freedom.</p><p>Revolute Joint 模块模拟具有一个旋转自由度的关节。</p><p><img src="image-20220331122431883.png" alt="image-20220331122431883" style="zoom:150%;" /></p><p>The joint constrains the motion of two arbitrary frames that connect to the base and follower frames of the joint to pure rotation about a common axis. The axis of rotation is aligned with the <em>z</em>-axis of the joint base frame. The base and follower frames have a common origin and <em>z</em>-axis, and the follower frame rotates about the <em>z</em>-axis, as shown in the image.</p><p>关节将连接到关节的基础框架和从动框架的两个任意框架的运动限制为围绕公共轴进行纯旋转。 旋转轴与关节基础框架的 z 轴对齐。 如图所示，基础框架和跟随框架具有共同的原点和 z 轴，并且跟随框架围绕 z 轴旋转。</p><p><img src="image-20220331122451755.png" alt="image-20220331122451755" style="zoom:150%;" /></p><p>To target the initial state of the a joint primitive, use the parameters under <strong>State Targets</strong>. The position and velocity targets are resolved in the base frame. You can also set the priority levels for the targets. If the block cannot simultaneously satisfy the state targets, the priority level determines which targets to satisfy first and how closely to satisfy them. See <a href="https://ww2.mathworks.cn/help/physmod/sm/ug/assembling-multibody-systems.html#busaiy6-1">Guiding Assembly</a> for more information.</p><p>要定位关节图元的初始状态，请使用 <strong>State Targets</strong> 下的参数。 位置和速度目标在基本框架中解析。 您还可以设置目标的优先级。 如果块不能同时满足状态目标，则优先级确定首先满足哪些目标以及满足这些目标的程度。 更多信息见【指导组装】(<a href="https://ww2.mathworks.cn/help/physmod/sm/ug/assemble-multibody-systems.html#busaiy6-1)。">https://ww2.mathworks.cn/help/physmod/sm/ug/assemble-multibody-systems.html#busaiy6-1)。</a></p><p>To model damping and spring behavior in a joint primitive, use the parameters under <strong>Internal Mechanics</strong>. Specify joint damping coefficients to model energy dissipation and joint spring stiffness to model energy storage. Springs resist attempts to displace the joint primitive from its equilibrium position. Joint dampers act as energy dissipation elements. Springs and dampers are strictly linear.</p><p>要模拟关节基本体中的阻尼和弹簧行为，请使用内部力学下的参数。 指定关节阻尼系数来模拟能量耗散和关节弹簧刚度来模拟能量存储。 弹簧抵抗试图将关节基元从其平衡位置移开的尝试。 关节阻尼器充当能量耗散元件。 弹簧和阻尼器是严格线性的。</p><p>To specify the limits of a joint primitive, use the parameters under <strong>Limits</strong>. The lower and upper bounds define the width of the free region of a joint primitive. The block applies a force or torque to accelerate the joint position back to the free region when the position exceeds the bounds. The block uses a smoothed spring-damper method to compute the force or torque. See <a href="https://ww2.mathworks.cn/help/physmod/sm/ref/spatialcontactforce.html#mw_acd246fe-915a-4822-9c50-b9aa9debb1ce">Description</a> section of the <a href="https://ww2.mathworks.cn/help/physmod/sm/ref/spatialcontactforce.html">Spatial Contact Force</a> block for more information about the smoothed spring-damper method.</p><p>要指定关节基本体的限制，请使用“限制”下的参数。 下限和上限定义了关节图元的自由区域的宽度。 当位置超出界限时，该块会施加力或扭矩以将关节位置加速回到自由区域。 该块使用平滑弹簧阻尼器方法来计算力或扭矩。 有关平滑弹簧阻尼器方法的更多信息，请参见空间接触力模块的描述部分。</p><p>A revolute primitive provides two actuation parameters, <strong>Torque</strong> and <strong>Motion</strong>, that govern the motion of the primitive during a simulation. See <a href="https://ww2.mathworks.cn/help/physmod/sm/ug/joint-actuation.html">Specifying Joint Actuation Inputs</a> for more information. Additionally, the block has ports that output sensing data, such as position, velocity, acceleration, forces, and torques, that enable you to perform analytical tasks on a model. See <a href="https://ww2.mathworks.cn/help/physmod/sm/ug/sensing.html">Sensing</a> and <a href="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Force and Torque Sensing</a> for more information.</p><p>旋转基元提供两个驱动参数，扭矩和运动，它们在模拟过程中控制基元的运动。 有关详细信息，请参阅指定关节驱动输入。 此外，该模块具有输出传感数据的端口，例如位置、速度、加速度、力和扭矩，使您能够对模型执行分析任务。 有关详细信息，请参阅传感和力和扭矩传感。</p><h3 id="Ports"><a href="#Ports" class="headerlink" title="Ports"></a>Ports</h3><h4 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h4><h5 id="B-—-Base-frame"><a href="#B-—-Base-frame" class="headerlink" title="B — Base frame"></a><code>B</code> — Base frame</h5><p>Base frame of the joint block.</p><h5 id="F-—-Follower-frame"><a href="#F-—-Follower-frame" class="headerlink" title="F — Follower frame"></a><code>F</code> — Follower frame</h5><p>Follower frame of the joint block.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><h5 id="t-—-Actuation-torque-physical-signal-驱动扭矩物理信号"><a href="#t-—-Actuation-torque-physical-signal-驱动扭矩物理信号" class="headerlink" title="t — Actuation torque physical signal 驱动扭矩物理信号"></a><code>t</code> — Actuation torque physical signal 驱动扭矩物理信号</h5><p>Physical signal input port that accepts the actuation torque for the joint primitive. The signal provides the value of the torque that applies on both the base and follower frames of the joint primitive.</p><h6 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Actuation</strong>, set <strong>Torque</strong> to <code>Provided by Input</code>.</p><p>接受关节图元的驱动扭矩的物理信号输入端口。 该信号提供了应用于关节图元的基础框架和从动框架的扭矩值。</p><p>依赖项</p><p>要启用此端口，请在 Z Revolute Primitive (Rz) &gt; Actuation 下，将 Torque 设置为由 Input 提供。</p><h5 id="q-—-Motion-profile-physical-signal"><a href="#q-—-Motion-profile-physical-signal" class="headerlink" title="q — Motion profile physical signal"></a><code>q</code> — Motion profile physical signal</h5><p>Physical signal input port that accepts the motion profile for the joint primitive. The signal provides the rotation of the follower frame with respect to the base frame about the joint primitive axis. Note that the signal must also contain the first and second derivatives of the rotation.</p><h6 id="Dependencies-1"><a href="#Dependencies-1" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Actuation</strong>, set <strong>Motion</strong> to <code>Provided by Input</code>.</p><p>物理信号输入端口，接受关节基元的运动轮廓。 该信号提供了从动框架相对于基本框架绕关节图元轴的旋转。 请注意，信号还必须包含旋转的一阶和二阶导数。</p><h6 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Actuation</strong> 下，将 <strong>Motion</strong> 设置为 <code>Provided by Input</code>。</p><h5 id="mode-—-Joint-mode-control-scalar-关节模式控制标量"><a href="#mode-—-Joint-mode-control-scalar-关节模式控制标量" class="headerlink" title="mode — Joint mode control scalar 关节模式控制标量"></a><code>mode</code> — Joint mode control scalar 关节模式控制标量</h5><p>Input port that controls the joint mode. The signal is a unitless scalar. The joint mode is normal when the input signal is 0 and disengaged when the input signal is -1. The joint mode can be changed many times during a simulation.</p><h6 id="Dependencies-2"><a href="#Dependencies-2" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Mode Configuration</strong>, set <strong>Mode</strong> to <code>Provided by Input</code>.</p><p>控制关节模式的输入端口。 信号是无单位标量。 输入信号为0时关节模式正常，输入信号-1时关节模式断开。 在模拟过程中可以多次更改关节模式。</p><h6 id="依赖项-1"><a href="#依赖项-1" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Mode Configuration</strong> 下，将 <strong>Mode</strong> 设置为 <code>Provided by Input</code>。</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><h5 id="q-—-Position-of-joint-primitive-physical-signal-关节原始物理信号的位置"><a href="#q-—-Position-of-joint-primitive-physical-signal-关节原始物理信号的位置" class="headerlink" title="q — Position of joint primitive physical signal 关节原始物理信号的位置"></a><code>q</code> — Position of joint primitive physical signal 关节原始物理信号的位置</h5><p>Physical signal port that outputs the position of the joint primitive. The value is the rotation angle of the follower frame with respect to the base frame.</p><h6 id="Dependencies-3"><a href="#Dependencies-3" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong>, select <strong>Position</strong>.</p><p>输出关节图元位置的物理信号端口。 该值是从动框架相对于基础框架的旋转角度。</p><h6 id="依赖项-2"><a href="#依赖项-2" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong> 下，选择 <strong>Position</strong>。</p><h5 id="w-—-First-derivative-of-position-of-joint-primitive-physical-signal"><a href="#w-—-First-derivative-of-position-of-joint-primitive-physical-signal" class="headerlink" title="w — First derivative of position of joint primitive physical signal"></a><code>w</code> — First derivative of position of joint primitive physical signal</h5><p>Physical signal port that outputs the first derivative of position of the joint primitive.</p><h6 id="Dependencies-4"><a href="#Dependencies-4" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong>, select <strong>Velocity</strong>.</p><p>输出关节图元位置的一阶导数的物理信号端口。</p><h6 id="依赖项-3"><a href="#依赖项-3" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong> 下，选择 <strong>Velocity</strong>。</p><h5 id="b-—-Second-derivative-of-position-of-joint-primitive-physical-signal"><a href="#b-—-Second-derivative-of-position-of-joint-primitive-physical-signal" class="headerlink" title="b — Second derivative of position of joint primitive physical signal"></a><code>b</code> — Second derivative of position of joint primitive physical signal</h5><p>关节原始物理信号位置的二阶导数</p><p>Physical signal port that outputs the second derivative of position of the joint primitive.</p><h6 id="Dependencies-5"><a href="#Dependencies-5" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong>, select <strong>Acceleration</strong>.</p><p>输出关节图元位置二阶导数的物理信号端口。</p><h6 id="依赖项-4"><a href="#依赖项-4" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong> 下，选择 <strong>Acceleration</strong>。</p><h5 id="t-—-Actuator-torque-acting-on-joint-primitive-physical-signal"><a href="#t-—-Actuator-torque-acting-on-joint-primitive-physical-signal" class="headerlink" title="t — Actuator torque acting on joint primitive physical signal"></a><code>t</code> — Actuator torque acting on joint primitive physical signal</h5><p>Physical signal port that outputs the actuator torque acting on the joint primitive.</p><h6 id="Dependencies-6"><a href="#Dependencies-6" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong>, select <strong>Actuator Torque</strong>.</p><p>输出作用在关节基元上的执行器扭矩的物理信号端口。</p><h6 id="依赖项-5"><a href="#依赖项-5" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong> 下，选择 <strong>Actuator Torque</strong>。</p><h5 id="tll-—-Lower-limit-torque-physical-signal"><a href="#tll-—-Lower-limit-torque-physical-signal" class="headerlink" title="tll — Lower-limit torque physical signal"></a><code>tll</code> — Lower-limit torque physical signal</h5><p>Physical signal port that outputs the lower-limit torque. The block applies the torque when the joint primitive position exceeds the lower bound of the free region. The torque applies to both the base and follower frames of the joint primitive to accelerate the position back to the free region.</p><h6 id="Dependencies-7"><a href="#Dependencies-7" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong>, select <strong>Lower-Limit Torque</strong>.</p><p>输出下限扭矩的物理信号端口。 当关节基元位置超过自由区域的下限时，该模块将应用扭矩。 扭矩适用于关节图元的基础框架和跟随框架，以将位置加速回到自由区域。</p><h6 id="依赖项-6"><a href="#依赖项-6" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong> 下，选择 <strong>Lower-Limit Torque</strong>。</p><h5 id="tul-—-Upper-limit-torque-physical-signal"><a href="#tul-—-Upper-limit-torque-physical-signal" class="headerlink" title="tul — Upper-limit torque physical signal"></a><code>tul</code> — Upper-limit torque physical signal</h5><p>Physical signal port that outputs the upper-limit torque. The block applies the torque when the joint primitive position exceeds the upper bound of the free region. The torque applies to both the base and follower frames of the joint primitive to accelerate the position back to the free region.</p><h6 id="Dependencies-8"><a href="#Dependencies-8" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong>, select <strong>Upper-Limit Torque</strong>.</p><p>输出上限扭矩的物理信号端口。 当关节基元位置超过自由区域的上限时，该模块将应用扭矩。 扭矩适用于关节图元的基础框架和跟随框架，以将位置加速回到自由区域。</p><h6 id="依赖项-7"><a href="#依赖项-7" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>Sensing</strong> 下，选择 <strong>Upper-Limit Torque</strong>。</p><h5 id="fc-—-Constraint-force-physical-signal"><a href="#fc-—-Constraint-force-physical-signal" class="headerlink" title="fc — Constraint force physical signal"></a><code>fc</code> — Constraint force physical signal</h5><p>Physical signal port that outputs constraint force that acts in the joint. The force maintains the translational constraints of the joint. See <a href="https://ww2.mathworks.cn/help/physmod/sm/ug/sense-internal-forces-in-double-pendulum-link.html">Sense Constraint Forces</a> for more information.</p><h6 id="Dependencies-9"><a href="#Dependencies-9" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Composite Force/Torque Sensing</strong>, select <strong>Constraint Force</strong>.</p><p>输出作用于关节的约束力的物理信号端口。 力保持关节的平移约束。 更多信息参见【感知约束力】(<a href="https://ww2.mathworks.cn/help/physmod/sm/ug/sense-internal-forces-in-double-pendulum-link.html)。">https://ww2.mathworks.cn/help/physmod/sm/ug/sense-internal-forces-in-double-pendulum-link.html)。</a></p><h6 id="依赖项-8"><a href="#依赖项-8" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Composite Force/Torque Sensing</strong> 下，选择 <strong>Constraint Force</strong>。</p><h5 id="tc-—-Constraint-torque-physical-signal"><a href="#tc-—-Constraint-torque-physical-signal" class="headerlink" title="tc — Constraint torque physical signal"></a><code>tc</code> — Constraint torque physical signal</h5><p>Physical signal port that outputs constraint torque that acts in the joint. The torque maintains the rotational constraints of the joint. See <a href="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Force and Torque Sensing</a> for more information.</p><h6 id="Dependencies-10"><a href="#Dependencies-10" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Composite Force/Torque Sensing</strong>, select <strong>Constraint Torque</strong>.</p><p>输出作用于关节的约束扭矩的物理信号端口。 扭矩保持关节的旋转约束。 有关详细信息，请参阅力和扭矩传感。</p><h6 id="依赖项-9"><a href="#依赖项-9" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 Composite Force/Torque Sensing 下选择 Constraint Torque。</p><h5 id="ft-—-Total-force-physical-signal"><a href="#ft-—-Total-force-physical-signal" class="headerlink" title="ft — Total force physical signal"></a><code>ft</code> — Total force physical signal</h5><p>Physical signal port that outputs the total force that acts in the joint. The total force is the sum of the forces transmitted from one frame to the other through the joint. The force includes actuation, internal, limit and constraint forces. See <a href="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Force and Torque Sensing</a> for more information.</p><h6 id="Dependencies-11"><a href="#Dependencies-11" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Composite Force/Torque Sensing</strong>, select <strong>Total Force</strong>.</p><p>输出作用于关节的总力的物理信号端口。 总力是通过关节从一帧传递到另一帧的力的总和。 力包括驱动力、内部力、限制力和约束力。 更多信息请参见【力和扭矩传感】（<a href="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。">https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。</a> ###### 依赖项 要启用此端口，请在 <strong>Composite Force/Torque Sensing</strong> 下，选择 <strong>Total Force</strong>。 </p><h5 id="tt-—-Total-torque-physical-signal"><a href="#tt-—-Total-torque-physical-signal" class="headerlink" title="tt — Total torque physical signal"></a><code>tt</code> — Total torque physical signal</h5><p>Physical signal port that outputs the total torque that acts in the joint. The total torque is the sum of the torques transmitted from one frame to the other through the joint. The torque includes actuation, internal, limit, and constraint torques. See <a href="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Force and Torque Sensing</a> for more information.</p><h6 id="Dependencies-12"><a href="#Dependencies-12" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this port, under <strong>Composite Force/Torque Sensing</strong>, select <strong>Total Torque</strong>.</p><p>输出作用于关节的总扭矩的物理信号端口。 总扭矩是从一个框架通过关节传递到另一个框架的扭矩之和。 扭矩包括致动扭矩、内部扭矩、限制扭矩和约束扭矩。 更多信息请参见【力和扭矩传感】（<a href="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。">https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。</a></p><h6 id="依赖项-10"><a href="#依赖项-10" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此端口，请在 <strong>Composite Force/Torque Sensing</strong> 下，选择 <strong>Total Torque</strong>。</p><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><h4 id="Z-Revolute-Primitive-Rz"><a href="#Z-Revolute-Primitive-Rz" class="headerlink" title="Z Revolute Primitive (Rz)"></a>Z Revolute Primitive (Rz)</h4><h5 id="State-Targets-gt-Specify-Position-Target-—-Whether-to-specify-position-target-off-default-on"><a href="#State-Targets-gt-Specify-Position-Target-—-Whether-to-specify-position-target-off-default-on" class="headerlink" title="State Targets &gt; Specify Position Target — Whether to specify position target off (default) | on"></a><code>State Targets &gt; Specify Position Target</code> — Whether to specify position target <code>off</code> (default) | <code>on</code></h5><p>State Targets &gt; Specify Position Target<code>— 是否指定位置目标</code>off<code>（默认） |</code>开</p><p>Select this parameter to enable parameters that specify the position target of the joint primitive.</p><p>选择此参数以启用指定关节图元位置目标的参数。</p><h5 id="State-Targets-gt-Specify-Position-Target-gt-Priority-—-Priority-level-of-position-target-High-desired-default-Low-approximate"><a href="#State-Targets-gt-Specify-Position-Target-gt-Priority-—-Priority-level-of-position-target-High-desired-default-Low-approximate" class="headerlink" title="State Targets &gt; Specify Position Target &gt; Priority — Priority level of position target High (desired) (default) | Low (approximate)"></a><code>State Targets &gt; Specify Position Target &gt; Priority</code> — Priority level of position target <code>High (desired)</code> (default) | <code>Low (approximate)</code></h5><p>状态目标 &gt; 指定位置目标 &gt; 优先级 - 位置目标的优先级高（需要）（默认）| 低（大约）</p><p>Priority level of the position target, specified as <code>High (desired)</code> or <code>Low (approximate)</code>.</p><h6 id="Dependencies-13"><a href="#Dependencies-13" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>State Targets</strong>, select <strong>Specify Position Target</strong>.</p><p>位置目标的优先级，指定为“高（期望）”或“低（近似）”。</p><h6 id="依赖项-11"><a href="#依赖项-11" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>State Targets</strong> 下，选择 <strong>Specify Position Target</strong>。</p><h5 id="State-Targets-gt-Specify-Position-Target-gt-Value-—-Angle-of-position-target-0-deg-default-scalar-with-a-unit-of-angle"><a href="#State-Targets-gt-Specify-Position-Target-gt-Value-—-Angle-of-position-target-0-deg-default-scalar-with-a-unit-of-angle" class="headerlink" title="State Targets &gt; Specify Position Target &gt; Value — Angle of position target 0 deg (default) | scalar with a unit of angle"></a><code>State Targets &gt; Specify Position Target &gt; Value</code> — Angle of position target 0 <code>deg</code> (default) | scalar with a unit of angle</h5><p>Angle to specify the position target, specified as a scalar with a unit of angle.</p><h6 id="Dependencies-14"><a href="#Dependencies-14" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>State Targets</strong>, select <strong>Specify Position Target</strong>.</p><p>指定位置目标的角度，指定为以角度为单位的标量。</p><p>依赖项<br>要启用此参数，请在 Z Revolute Primitive (Rz) &gt; State Targets 下选择指定位置目标。</p><h5 id="State-Targets-gt-Specify-Velocity-Target-—-Whether-to-specify-velocity-target-off-default-on"><a href="#State-Targets-gt-Specify-Velocity-Target-—-Whether-to-specify-velocity-target-off-default-on" class="headerlink" title="State Targets &gt; Specify Velocity Target — Whether to specify velocity target off (default) | on"></a><code>State Targets &gt; Specify Velocity Target</code> — Whether to specify velocity target <code>off</code> (default) | <code>on</code></h5><p>Select this parameter to enable parameters for that specify the velocity target of the joint primitive.</p><p>选择此参数以启用指定关节图元的速度目标的参数。</p><h5 id="State-Targets-gt-Specify-Velocity-Target-gt-Priority-—-Priority-level-of-velocity-target-High-desired-default-Low-approximate"><a href="#State-Targets-gt-Specify-Velocity-Target-gt-Priority-—-Priority-level-of-velocity-target-High-desired-default-Low-approximate" class="headerlink" title="State Targets &gt; Specify Velocity Target &gt; Priority — Priority level of velocity target High (desired) (default) | Low (approximate)"></a><code>State Targets &gt; Specify Velocity Target &gt; Priority</code> — Priority level of velocity target <code>High (desired)</code> (default) | <code>Low (approximate)</code></h5><p>Priority level of the velocity target, specified as <code>High (desired)</code> or <code>Low (approximate)</code>.</p><h6 id="Dependencies-15"><a href="#Dependencies-15" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>State Targets</strong>, select <strong>Specify Velocity Target</strong>.</p><p>速度目标的优先级，指定为“高（期望）”或“低（近似）”。</p><h6 id="依赖项-12"><a href="#依赖项-12" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>State Targets</strong> 下，选择 <strong>Specify Velocity Target</strong>。</p><h5 id="State-Targets-gt-Specify-Velocity-Target-gt-Value-—-Velocity-target-of-joint-primitive-0-deg-s-default-scalar-with-unit-of-angular-velocity"><a href="#State-Targets-gt-Specify-Velocity-Target-gt-Value-—-Velocity-target-of-joint-primitive-0-deg-s-default-scalar-with-unit-of-angular-velocity" class="headerlink" title="State Targets &gt; Specify Velocity Target &gt; Value — Velocity target of joint primitive 0 deg/s (default) | scalar with unit of angular velocity"></a><code>State Targets &gt; Specify Velocity Target &gt; Value</code> — Velocity target of joint primitive 0 <code>deg/s</code> (default) | scalar with unit of angular velocity</h5><p>Velocity target of the joint primitive, specified as a scalar with a unit of angular velocity.</p><h6 id="Dependencies-16"><a href="#Dependencies-16" class="headerlink" title="Dependencies"></a>Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>State Targets</strong>, select <strong>Specify Velocity Target</strong>.</p><p>关节图元的速度目标，指定为具有角速度单位的标量。</p><h6 id="依赖项-13"><a href="#依赖项-13" class="headerlink" title="依赖项"></a>依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt; <strong>State Targets</strong> 下，选择 <strong>Specify Velocity Target</strong>。</p><h5 id="Internal-Mechanics-gt-Equilibrium-Position-—-Position-where-internal-torque-is-zero-0-deg-default-scalar-with-unit-of-angle"><a href="#Internal-Mechanics-gt-Equilibrium-Position-—-Position-where-internal-torque-is-zero-0-deg-default-scalar-with-unit-of-angle" class="headerlink" title="Internal Mechanics &gt; Equilibrium Position — Position where internal torque is zero 0 deg (default) | scalar with unit of angle"></a><code>Internal Mechanics &gt; Equilibrium Position</code> — Position where internal torque is zero 0 <code>deg</code> (default) | scalar with unit of angle</h5><p>内部扭矩为零的位置 0 <code>deg</code>（默认）| 以角度为单位的标量</p><p>Position where the spring torque is zero, specified as a scalar with a unit of angle. The value specifies the rotation angle of the follower frame with respect to the base frame.</p><p>弹簧扭矩为零的位置，指定为具有角度单位的标量。 该值指定从动框架相对于基础框架的旋转角度。</p><h5 id="Internal-Mechanics-gt-Spring-Stiffness-—-Stiffness-of-force-law-0-N-m-deg-default-scalar-with-unit-of-stiffness"><a href="#Internal-Mechanics-gt-Spring-Stiffness-—-Stiffness-of-force-law-0-N-m-deg-default-scalar-with-unit-of-stiffness" class="headerlink" title="Internal Mechanics &gt; Spring Stiffness — Stiffness of force law 0 N*m/deg (default) | scalar with unit of stiffness"></a><code>Internal Mechanics &gt; Spring Stiffness</code> — Stiffness of force law 0 <code>N*m/deg</code> (default) | scalar with unit of stiffness</h5><p>Stiffness of the internal spring-damper force law for the joint primitive, specified as a scalar with a unit of stiffness.</p><p>关节基元的内部弹簧阻尼力定律的刚度，指定为具有刚度单位的标量。</p><h5 id="Internal-Mechanics-gt-Damping-Coefficient-—-Damping-coefficient-of-force-law-0-N-m-deg-s-default-scalar-with-unit-of-damping-coefficient"><a href="#Internal-Mechanics-gt-Damping-Coefficient-—-Damping-coefficient-of-force-law-0-N-m-deg-s-default-scalar-with-unit-of-damping-coefficient" class="headerlink" title="Internal Mechanics &gt; Damping Coefficient — Damping coefficient of force law 0 N*m/(deg/s) (default) | scalar with unit of damping coefficient"></a><code>Internal Mechanics &gt; Damping Coefficient</code> — Damping coefficient of force law 0 <code>N*m/(deg/s)</code> (default) | scalar with unit of damping coefficient</h5><p>Damping coefficient of the internal spring-damper force law for the joint primitive, specified as a scalar with a unit of damping coefficient.</p><p>关节基元的内部弹簧-阻尼力定律的阻尼系数，指定为具有阻尼系数单位的标量。</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> MATLAB仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> MATLAB仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simulink机器人仿真库</title>
      <link href="/2022/03/27/simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93/"/>
      <url>/2022/03/27/simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h4 id="simulink机器人仿真库"><a href="#simulink机器人仿真库" class="headerlink" title="simulink机器人仿真库"></a>simulink机器人仿真库</h4><p>[TOC]</p><span id="more"></span><h2 id="Forward-Dynamics-正向动力学"><a href="#Forward-Dynamics-正向动力学" class="headerlink" title="Forward Dynamics 正向动力学"></a>Forward Dynamics 正向动力学</h2><p>给定关节扭矩和状态的关节加速度</p><p><strong>Library:</strong> Robotics System Toolbox / Manipulator Algorithm</p><p><img src="image-20220327131159671.png" alt="image-20220327131159671"  /></p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>The Forward Dynamics block computes joint accelerations for a robot model given a robot state that is made up of joint torques, joint states, and external forces. To get the joint accelerations, specify the robot configuration (joint positions), joint velocities, applied torques, and external forces.</p><p>Forward Dynamics 模块在给定由关节扭矩、关节状态和外力组成的机器人状态下计算机器人模型的关节加速度。 要获得关节加速度，请指定机器人配置（关节位置）、关节速度、施加的扭矩和外力。</p><p>The Forward Dynamics block computes joint accelerations for a robot model given a robot state that is made up of joint torques, joint states, and external forces. To get the joint accelerations, specify the robot configuration (joint positions), joint velocities, applied torques, and external forces.</p><p>Specify the robot model in the <strong>Rigid body tree</strong> parameter as a <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a> object, and set the <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html#bvan8uq-1-Gravity">Gravity</a> property on the object. You can also import a robot model from an URDF (Unified Robot Description Formation) file using <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>Forward Dynamics 模块在给定由关节扭矩、关节状态和外力组成的机器人状态下计算机器人模型的关节加速度。 要获得关节加速度，请指定机器人配置（关节位置）、关节速度、施加的扭矩和外力。</p><p>将刚体树参数中的机器人模型指定为rigidBodyTree对象，并在该对象上设置Gravity属性。 您还可以使用 importrobot 从 URDF（统一机器人描述格式）文件中导入机器人模型。</p><h3 id="Ports"><a href="#Ports" class="headerlink" title="Ports"></a>Ports</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><h5 id="Config-—-Robot-configuration-vector"><a href="#Config-—-Robot-configuration-vector" class="headerlink" title="Config — Robot configuration vector"></a><code>Config</code> — Robot configuration vector</h5><p>Robot configuration, specified as a vector of positions for all nonfixed joints in the robot model, as set by the <strong>Rigid body tree</strong> parameter. You can also generate this vector for a complex robot using the <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a> or <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a> functions inside a Constant or MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由<strong>刚体树</strong>参数设置。 您还可以使用 <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a> 或 [<code>randomConfiguration</code>] 为复杂机器人生成此向量 (<a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html">https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html</a>) 函数在 Constant 或 MATLAB Function 块中。</p><h5 id="JointVel-—-Joint-velocities-vector"><a href="#JointVel-—-Joint-velocities-vector" class="headerlink" title="JointVel — Joint velocities vector"></a><code>JointVel</code> — Joint velocities vector</h5><p>Joint velocities, specified as a vector. The number of joint velocities is equal to the degrees of freedom (number of nonfixed joints) of the robot.</p><p>关节速度，指定为矢量。 关节速度的数量等于机器人的自由度（非固定关节的数量）。</p><h5 id="JointTorq-—-Joint-torques-vector"><a href="#JointTorq-—-Joint-torques-vector" class="headerlink" title="JointTorq — Joint torques vector"></a><code>JointTorq</code> — Joint torques vector</h5><p>Joint torques, specified as a vector. Each element corresponds to a torque applied to a specific joint. The number of joint torques is equal to the degrees of freedom (number of nonfixed joints) of the robot.</p><p>关节扭矩，指定为矢量。 每个元素对应于施加到特定关节的扭矩。 关节扭矩的数量等于机器人的自由度（非固定关节的数量）。</p><h5 id="FExt-—-External-force-matrix-6-by-n-matrix"><a href="#FExt-—-External-force-matrix-6-by-n-matrix" class="headerlink" title="FExt — External force matrix 6-by-n matrix"></a><code>FExt</code> — External force matrix 6-by-<em>n</em> matrix</h5><p>外力矩阵，指定为 6×n 矩阵，其中 n 是机器人模型中的物体数量。 该矩阵在对应于特定实体的行中包含非零值。 每一行都是施加的力和扭矩的矢量，它们充当该特定身体的扳手。 使用带有 MATLAB Function 模块的 externalForce 生成此矩阵</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><h5 id="JointAccel-—-Joint-accelerations-vector"><a href="#JointAccel-—-Joint-accelerations-vector" class="headerlink" title="JointAccel — Joint accelerations vector"></a><code>JointAccel</code> — Joint accelerations vector</h5><p>关节加速度，以向量形式返回。 关节加速度的数量等于机器人的自由度。 </p><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><h5 id="Rigid-body-tree-—-Robot-model-twoJointRigidBodyTree-default-RigidBodyTree-object"><a href="#Rigid-body-tree-—-Robot-model-twoJointRigidBodyTree-default-RigidBodyTree-object" class="headerlink" title="Rigid body tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTree object"></a><code>Rigid body tree</code> — Robot model <code>twoJointRigidBodyTree</code> (default) | <code>RigidBodyTree</code> object</h5><p>Robot model, specified as a <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a> object. You can also import a robot model from an URDF (Unified Robot Description Formation) file using <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>The default robot model, <code>twoJointRigidBodyTree</code>, is a robot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为 <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a> 对象。 您还可以使用 <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a> 从 URDF（统一机器人描述形成）文件导入机器人模型。</p><p>默认机器人模型“twoJointRigidBodyTree”是具有旋转关节和两个自由度的机器人。</p><h5 id="Simulate-using-—-Type-of-simulation-to-run-Interpreted-execution-default-Code-generation"><a href="#Simulate-using-—-Type-of-simulation-to-run-Interpreted-execution-default-Code-generation" class="headerlink" title="Simulate using — Type of simulation to run Interpreted execution (default) | Code generation"></a><code>Simulate using</code> — Type of simulation to run <code>Interpreted execution</code> (default) | <code>Code generation</code></h5><ul><li><code>Interpreted execution</code> — Simulate model using the MATLAB® interpreter. This option shortens startup time but has a slower simulation speed than <code>Code generation</code>. In this mode, you can debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated C code. The first time you run a simulation, Simulink® generates C code for the block. The C code is reused for subsequent simulations, as long as the model does not change. This option requires additional startup time, but the speed of the subsequent simulations is comparable to <code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。 此选项可缩短启动时间，但仿真速度比代码生成慢。 在这种模式下，您可以调试块的源代码。</p><p>代码生成 - 使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink® 会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。 此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><h2 id="Get-Jacobian-获取雅可比矩阵"><a href="#Get-Jacobian-获取雅可比矩阵" class="headerlink" title="Get Jacobian 获取雅可比矩阵"></a>Get Jacobian 获取雅可比矩阵</h2><p>Geometric Jacobian for robot configuration</p><p>用于机器人配置的几何雅可比行列式</p><p><img src="image-20220327132517323.png" alt="image-20220327132517323"  /></p><ul><li><strong>Library:</strong>Robotics System Toolbox / Manipulator Algorithms</li></ul><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>The Get Jacobian block returns the geometric Jacobian relative to the base for the specified end effector at the given configuration of a <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a> robot model.</p><p>The Jacobian maps the joint-space velocity to the end-effector velocity relative to the base coordinate frame. The end-effector velocity equals:</p><p>Get Jacobian 模块返回相对于在刚体树机器人模型的给定配置下指定末端执行器的基部的几何雅可比。</p><p>雅可比将关节空间速度映射到相对于基本坐标系的末端执行器速度。 末端执行器速度等于：</p><p><img src="simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93.assets/image-20220327132908638.png" alt="image-20220327132908638" style="zoom: 80%;" /></p><p>$\omega$is the angular velocity, $v$ is the linear velocity, and$\dot q$is the joint-space velocity.</p><h3 id="Ports-1"><a href="#Ports-1" class="headerlink" title="Ports"></a>Ports</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><h5 id="Config-—-Robot-configuration-vector-1"><a href="#Config-—-Robot-configuration-vector-1" class="headerlink" title="Config — Robot configuration vector"></a>Config — Robot configuration vector</h5><p>Robot configuration, specified as a vector of positions for all nonfixed joints in the robot model, as set by the <strong>Rigid body tree</strong> parameter. You can also generate this vector for a complex robot using the <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a> or<a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a> functions inside a Constant or MATLAB Function block</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由刚体树参数设置。 您还可以使用 Constant 或 MATLAB Function 模块中的 homeConfiguration 或 randomConfiguration 函数为复杂机器人生成此向量</p><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><h5 id="Jacobian-—-Geometric-Jacobian-of-end-effector-6-by-n-matrix"><a href="#Jacobian-—-Geometric-Jacobian-of-end-effector-6-by-n-matrix" class="headerlink" title="Jacobian — Geometric Jacobian of end effector 6-by-n matrix"></a>Jacobian — Geometric Jacobian of end effector 6-by-n matrix</h5><p>Geometric Jacobian of the end effector with the specified configuration, Config, returned as a 6-by-n matrix, where n is the number of degrees of freedom of the end effector. The Jacobian maps the joint-space velocity to the end-effector velocity relative to the base coordinate frame. The end-effector velocity equals:</p><p><img src="image-20220327133500482.png" alt="image-20220327133500482"  /></p><p>$\omega$is the angular velocity, $v$ is the linear velocity, and$\dot q$is the joint-space velocity.</p><p>具有指定配置 Config 的末端执行器的几何雅可比矩阵以 6×n 矩阵形式返回，其中 n 是末端执行器的自由度数。 雅可比将关节空间速度映射到相对于基本坐标系的末端执行器速度。 末端执行器速度等于：</p><h4 id="Parameters-1"><a href="#Parameters-1" class="headerlink" title="Parameters"></a>Parameters</h4><h5 id="Rigid-body-tree-—-Robot-model-twoJointRigidBodyTree-default-RigidBodyTree-object-1"><a href="#Rigid-body-tree-—-Robot-model-twoJointRigidBodyTree-default-RigidBodyTree-object-1" class="headerlink" title="Rigid body tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTree object"></a>Rigid body tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTree object</h5><p>Robot model, specified as a <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a> object. You can also import a robot model from an URDF (Unified Robot Description Formation) file using <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>The default robot model, <code>twoJointRigidBodyTree</code>, is a robot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为 <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a> 对象。 您还可以使用 <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a> 从 URDF（统一机器人描述形成）文件导入机器人模型。</p><p>默认机器人模型“twoJointRigidBodyTree”是具有旋转关节和两个自由度的机器人。</p><h5 id="End-effector-—-End-effector-for-Jacobian-body-name"><a href="#End-effector-—-End-effector-for-Jacobian-body-name" class="headerlink" title="End effector — End effector for Jacobian body name"></a>End effector — End effector for Jacobian body name</h5><p>End effector for <code>Jacobian</code>, specified as a body name from the <strong>Rigid body tree</strong>robot model. To access body names from the robot model, click <strong>Select body</strong>.</p><p>Jacobian 的末端执行器，指定为刚体树机器人模型中的身体名称。 要从机器人模型访问身体名称，请单击选择身体。</p><h5 id="Simulate-using-—-Type-of-simulation-to-run"><a href="#Simulate-using-—-Type-of-simulation-to-run" class="headerlink" title="Simulate using — Type of simulation to run"></a>Simulate using — Type of simulation to run</h5><ul><li><code>Interpreted execution</code> — Simulate model using the MATLAB®interpreter. This option shortens startup time but has a slower simulation speed than <code>Code generation</code>. In this mode, you can debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated C code. The first time you run a simulation, Simulink® generates C code for the block. The C code is reused for subsequent simulations, as long as the model does not change. This option requires additional startup time, but the speed of the subsequent simulations is comparable to <code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。 此选项可缩短启动时间，但仿真速度比代码生成慢。 在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink® 会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。 此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p><h2 id="Get-Transform-获取转换矩阵"><a href="#Get-Transform-获取转换矩阵" class="headerlink" title="Get Transform 获取转换矩阵"></a>Get Transform 获取转换矩阵</h2><p>Get transform between body frames</p><p>获取身体帧之间的变换</p><ul><li><strong>Library:</strong>Robotics System Toolbox / Manipulator Algorithms</li></ul><p><img src="image-20220327140329832.png" alt="image-20220327140329832"  /></p><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>The Get Transform block returns the homogeneous transformation between body frames on the <strong>Rigid body tree</strong> robot model. Specify a <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a> object for the robot model, and select a source and target body in the block.</p><p>The block uses <strong>Config</strong>, the robot configuration (joint positions) input, to calculate the transformation from the source body to the target body. This transformation is used to convert coordinates from the source to the target body. To convert to base coordinates, use the base body name as the <strong>Target body</strong> parameter.</p><p>Get Transform 块返回刚体树机器人模型上的身体框架之间的齐次变换。 为机器人模型指定一个刚体树对象，并在块中选择一个源体和目标体。</p><p>该块使用 Config（机器人配置（关节位置）输入）来计算从源体到目标体的转换。 此转换用于将坐标从源体转换为目标体。 要转换为基础坐标，请使用基础主体名称作为目标主体参数。</p><h3 id="Ports-2"><a href="#Ports-2" class="headerlink" title="Ports"></a>Ports</h3><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><h5 id="Config-—-Robot-configuration-vector-2"><a href="#Config-—-Robot-configuration-vector-2" class="headerlink" title="Config — Robot configuration vector"></a>Config — Robot configuration vector</h5><p>Robot configuration, specified as a vector of positions for all nonfixed joints in the robot model, as set by the <strong>Rigid body tree</strong> parameter. You can also generate this vector for a complex robot using the <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a> or<a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a> functions inside a Constant or MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由<strong>刚体树</strong>参数设置。 您还可以使用 <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a> 或 [<code>randomConfiguration</code>] 为复杂机器人生成此向量 (<a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html">https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html</a>) 函数在 Constant 或 MATLAB Function 块中。</p><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><h5 id="Transform-—-Homogeneous-transform-4-by-4-matrix"><a href="#Transform-—-Homogeneous-transform-4-by-4-matrix" class="headerlink" title="Transform — Homogeneous transform 4-by-4 matrix"></a>Transform — Homogeneous transform 4-by-4 matrix</h5><p>Homogeneous transform, returned as a 4-by-4 matrix.<br>齐次变换，以 4×4 矩阵形式返回。</p><h4 id="Parameters-2"><a href="#Parameters-2" class="headerlink" title="Parameters"></a>Parameters</h4><h5 id="Rigid-body-tree-—-Robot-model-twoJointRigidBodyTree-default-RigidBodyTree-object-2"><a href="#Rigid-body-tree-—-Robot-model-twoJointRigidBodyTree-default-RigidBodyTree-object-2" class="headerlink" title="Rigid body tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTree object"></a>Rigid body tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTree object</h5><p>Robot model, specified as a rigidBodyTree object. You can also import a robot model from an URDF (Unified Robot Description Formation) file using importrobot.</p><p>The default robot model, twoJointRigidBodyTree, is a robot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为一个刚体树对象。 您还可以使用 importrobot 从 URDF（统一机器人描述格式）文件中导入机器人模型。</p><p>默认机器人模型 twoJointRigidBodyTree 是具有旋转关节和两个自由度的机器人。</p><h5 id="Target-body-—-Target-body-name-body-name"><a href="#Target-body-—-Target-body-name-body-name" class="headerlink" title="Target body — Target body name body name"></a><code>Target body</code> — Target body name body name</h5><p>Target body name, specified as a body name from the robot model specified in <strong>Rigid body tree</strong>. To access body names from the robot model, click <strong>Select body</strong>. The target frame is the coordinate system you want to transform points into.</p><p>目标坐标系名称，指定为刚体树中指定的机器人模型的身体名称。 要从机器人模型访问身体名称，请单击选择身体。 目标框架是您要将点转换到的坐标系。</p><h5 id="Source-body-—-Source-body-name-body-name"><a href="#Source-body-—-Source-body-name-body-name" class="headerlink" title="Source body — Source body name body name"></a><code>Source body</code> — Source body name body name</h5><p>Source body name, specified as a body name from the robot model specified in <strong>Rigid body tree</strong>.To access body names from the robot model, click <strong>Select body</strong>. The source frame is the coordinate system you want points transformed from.</p><p>源身体名称，指定为刚体树中指定的机器人模型的身体名称。要从机器人模型访问身体名称，请单击选择身体。 源框架是您想要转换点的坐标系。</p><h5 id="Simulate-using-—-Type-of-simulation-to-run-1"><a href="#Simulate-using-—-Type-of-simulation-to-run-1" class="headerlink" title="Simulate using — Type of simulation to run"></a>Simulate using — Type of simulation to run</h5><ul><li><code>Interpreted execution</code> — Simulate model using the MATLAB®interpreter. This option shortens startup time but has a slower simulation speed than <code>Code generation</code>. In this mode, you can debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated C code. The first time you run a simulation, Simulink® generates C code for the block. The C code is reused for subsequent simulations, as long as the model does not change. This option requires additional startup time, but the speed of the subsequent simulations is comparable to <code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。 此选项可缩短启动时间，但仿真速度比代码生成慢。 在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink® 会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。 此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p><h2 id="Gravity-Torque"><a href="#Gravity-Torque" class="headerlink" title="Gravity Torque"></a>Gravity Torque</h2><p>Joint torques that compensate gravity</p><p>补偿重力的关节扭矩</p><p><img src="image-20220327154957257.png" alt="image-20220327154957257"  /></p><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>The Gravity Torque block returns the joint torques required to hold the robot at a given configuration with the current <a href="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html#bvan8uq-1-Gravity">Gravity</a> setting on the <strong>Rigid body tree</strong> robot model.</p><p>Gravity Torque 块返回在刚体树机器人模型上使用当前 Gravity 设置将机器人保持在给定配置所需的关节扭矩。</p><h3 id="Ports-3"><a href="#Ports-3" class="headerlink" title="Ports"></a>Ports</h3><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><h5 id="Config-—-Robot-configuration-vector-3"><a href="#Config-—-Robot-configuration-vector-3" class="headerlink" title="Config — Robot configuration vector"></a><code>Config</code> — Robot configuration vector</h5><p>Robot configuration, specified as a vector of positions for all nonfixed joints in the robot model, as set by the Rigid body tree parameter. You can also generate this vector for a complex robot using the homeConfiguration or randomConfiguration functions inside a Constant or MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由刚体树参数设置。 您还可以使用 Constant 或 MATLAB Function 模块中的 homeConfiguration 或 randomConfiguration 函数为复杂机器人生成此向量。</p><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><h5 id="JointTorq-—-Joint-torques-vector-1"><a href="#JointTorq-—-Joint-torques-vector-1" class="headerlink" title="JointTorq — Joint torques vector"></a><code>JointTorq</code> — Joint torques vector</h5><p>Joint torques, specified as a vector. Each element corresponds to a torque applied to a specific joint. The number of joint torques is equal to the degrees of freedom (number of nonfixed joints) of the robot.</p><p>关节扭矩，指定为矢量。 每个元素对应于施加到特定关节的扭矩。 关节扭矩的数量等于机器人的自由度（非固定关节的数量）。</p><h4 id="Parameters-3"><a href="#Parameters-3" class="headerlink" title="Parameters"></a>Parameters</h4><h5 id="Rigid-body-tree-—-Robot-model-twoJointRigidBodyTree-default-RigidBodyTree-object-3"><a href="#Rigid-body-tree-—-Robot-model-twoJointRigidBodyTree-default-RigidBodyTree-object-3" class="headerlink" title="Rigid body tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTree object"></a>Rigid body tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTree object</h5><p>Robot model, specified as a rigidBodyTree object. You can also import a robot model from an URDF (Unified Robot Description Formation) file using importrobot.</p><p>The default robot model, twoJointRigidBodyTree, is a robot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为一个刚体树对象。 您还可以使用 importrobot 从 URDF（统一机器人描述格式）文件中导入机器人模型。</p><p>默认机器人模型 twoJointRigidBodyTree 是具有旋转关节和两个自由度的机器人。</p><h5 id="Simulate-using-—-Type-of-simulation-to-run-2"><a href="#Simulate-using-—-Type-of-simulation-to-run-2" class="headerlink" title="Simulate using — Type of simulation to run"></a>Simulate using — Type of simulation to run</h5><ul><li><code>Interpreted execution</code> — Simulate model using the MATLAB®interpreter. This option shortens startup time but has a slower simulation speed than <code>Code generation</code>. In this mode, you can debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated C code. The first time you run a simulation, Simulink® generates C code for the block. The C code is reused for subsequent simulations, as long as the model does not change. This option requires additional startup time, but the speed of the subsequent simulations is comparable to <code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。 此选项可缩短启动时间，但仿真速度比代码生成慢。 在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink® 会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。 此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> MATLAB仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> MATLAB仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代学习控制</title>
      <link href="/2022/03/24/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/03/24/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代学习控制"><a href="#迭代学习控制" class="headerlink" title="迭代学习控制"></a>迭代学习控制</h3><p>迭代学习控制（iterative learning control，ILC）是智能控制中具有严格数学描述的一个分支。1984年，Arimoto等人提出了迭代学习控制的概念，该控制方法适合于<strong>具有重复运动性质</strong>的被控对象，它不依赖于系统的精确数学模型，能以非常简单的方式处理不确定度相当高的非线性强耦合动态系统。目前，迭代学习控制在学习算法、收敛性、鲁棒性、学习速度及工程应用研究上取得了巨大的进展。<br>       近年来，迭代学习控制理论和应用在国外得到快速发展，取得了许多成果。在国内，迭代学习控制理论也得到广泛的重视，有许多重要著作出版，发表了许多综述性论文。</p><span id="more"></span><h4 id="1、迭代学习控制基本原理"><a href="#1、迭代学习控制基本原理" class="headerlink" title="1、迭代学习控制基本原理"></a>1、迭代学习控制基本原理</h4><p>设被控对象的动态过程为</p><script type="math/tex; mode=display">\dot x(t)=f(x(t),u(t),t), y(t)=g(x(t),u(t),t)</script><p>其中，$x\in R^n$、$y\in R^m$、$u\in R^r$分别为系统的状态、输出和输入变量，$f(·)$、$g(·)$为适当维数的向量函数，其结构与参数均未知。若期望控制$u_d(t)$存在，则迭代学习<strong>控制的目标</strong>为：给定期望输出$y_d(t)$和每次运行的初始状态$x_k(0)$，要求在给定的时间$t\in [0,T]$内，按照一定的学习控制算法通过多次重复的运行，使控制输入$u_k(t)\rightarrow u_d(t)$，而系统输出$y_k(t)\rightarrow y_d(t)$。第$k$次运行时，式$(1)$表示为</p><script type="math/tex; mode=display">\dot x_k(t)=f(x_k(t),u_k(t),t), y_k(t)=g(x_k(t),u_k(t),t)</script><p>跟踪误差为</p><script type="math/tex; mode=display">e_k(t)=y_d(t)-y_k(t)</script><p>迭代学习控制可分为以下开环学习和闭环学习两种方法：</p><p>（1）开环学习控制的方法是：第$k+1$次的控制等于第$k$次控制再加上第$k$次输出误差的校正项，即</p><script type="math/tex; mode=display">u_{k+1}(t)=L(u_k(t),e_k(t))</script><p>（2）闭环学习控制的方法是：取第$k十1$次运行的误差作为学习的修正项，即</p><script type="math/tex; mode=display">u_{k+1}(t)== L(u_k(t),e_{k+1}(t))</script><p>其中，L为线性或非线性算子。</p><p><img src="20211203022736652.jpg" alt="20211203022736652"  /></p><h4 id="2、基本的迭代学习控制算法"><a href="#2、基本的迭代学习控制算法" class="headerlink" title="2、基本的迭代学习控制算法"></a>2、基本的迭代学习控制算法</h4><p>Arimoto等首先给出了线性时变连续系统的D型迭代学习控制律</p><script type="math/tex; mode=display">u_{k+1}(t)=u_k(t)+\Gamma \dot e_k(t)</script><p>其中，$\Gamma$为常数增益矩阵。在D型算法的基础上，相继出现了P型、PI型、PD型迭代学习<br>控制律。从一般意义来看它们都是PID型迭代学习控制律的特殊形式，PID迭代学习控制律表示为</p><script type="math/tex; mode=display">u_{k+1}(t)=u(t)+\Gamma \dot e_k(t)+\Phi e_K(T)+\Psi\int_{0}^{t}e_k(\tau)d\tau</script><p>其中，$\Gamma$、$\Phi$、$\Psi$为学习增益矩阵。算法中的误差信息使用$e_k(t)$称为开环迭代学习控制，如果使用$e_{k+1}(t)$则称为闭环迭代学习控制，如果同时使用$e_k(t)$和$e_{k+1}(t)$则称为开闭环迭代学习控制。</p><p>此外，还有高阶迭代学习控制算法、最优迭代学习控制算法、遗忘因子迭代学习控制算法和反馈-前馈迭代学习控制算法等。</p><h4 id="3、迭代学习控制主要分析方法"><a href="#3、迭代学习控制主要分析方法" class="headerlink" title="3、迭代学习控制主要分析方法"></a>3、迭代学习控制主要分析方法</h4><p>学习算法的收敛性分析是迭代学习控制的核心问题，这方面的研究成果很丰富。</p><p>1、基本的收敛性分析方法</p><p>对于如下线性离散系统：</p><script type="math/tex; mode=display">\left\{\begin{matrix} x(t+1)=Ax(t)+Bu(t) \\ y(t)=Cx(t)\end{matrix}\right.</script><p>迭代学习控制算法为</p><script type="math/tex; mode=display">u_{k+1}(t)=u_k(t)+\Gamma e_k(t+1)</script><p>针对学习算法式$(9)$的收敛性，有以下两种分析方法：</p><p>（1）压缩映射方法：即系统要求满足全局$Lipschitz$条件和相同的初始条件，如果<br>$||I-CBT||&lt;1$,则有</p><script type="math/tex; mode=display">\parallel e_{K+1}\parallel=\parallel(I-CB\Gamma)e_K\parallel<\parallel I-CB\Gamma\parallel \parallel e_k\parallel<\parallel e_k\parallel</script><p>此时算法是单调收敛的。该方法依赖于范数的选择，常用的有$l_1$范数、$l_2$范数、$l_\infty$范数<br>及$\lambda$范数。在收敛性证明过程中常用到$Bellman-Gronwall$引理。</p><p>（2）谱半径条件法：如果谱半径$\rho$满足$\rho(I-CB\Gamma)\leq \rho &lt;1$，则有</p><script type="math/tex; mode=display">\lim_{k \to \infty}\parallel e_k \parallel = \lim_{k \to \infty} \parallel(I- CB\Gamma)e_{k-1}\parallel = \lim_{k \to \infty} \rho(I-CB\Gamma)^k\parallel e \parallel</script><p>即$ \lim_ {k \to \infty}\parallel e_k\parallel=0$。</p><p>2、基于2-D理论的分析方法</p><p>迭代学习控制系统的学习是按两个相互独立的方向进行：时间轴方向和迭代次数轴方向，因此选代学习过程本质上是二维系统，可利用成熟的2-D系统理论系统地研究和分析时间域的稳定性和迭代次数域的收敛性问题。2-D系统的稳定性理论为迭代学习控制的收敛性证明提供了一种非常有效的方法，2-D系统理论中的Roesser模型成为迭代学习控制中最基本的分析模型。</p><p>3.基于Lyapunov直接法的设计方法</p><p>Lyapunov直接法已广泛用于非线性动态系统的控制器设计和分析中，在研究非线性不确定系统时，该方法是最重要的应用工具之一。受Lyapunov直接法的启发，在时间域和迭代域能量函数的概念得到研究，它为学习控制在迭代域设计和收敛性分析方面提供了一种新的研究方法。</p><p>在迭代域能量函数的迭代学习控制方法基础上，发展了鲁棒和自适应迭代学习控制，可解决具有参数或非参数不确定性非线性系统控制器的设计，近年来反映时间域和迭代域系统能量的组合能量函数方法也应用于迭代学习控制，它可保证在迭代域跟踪误差的渐近收敛以及在时间域具有有界和逐点跟踪的动态特性，并且控制输入在整个迭代区间内是范数收敛的，适用于一类不具有全局Lipschitz条件的非线性系统。通过能量函数的方法，许多新的控制方法，如反演设计和非线性优化方法都作为系统设计工具应用到迭代学习控制中。此外，还有最优化分析方法、频域分析法等分析方法。</p><h4 id="4、选代学习控制的关键技术"><a href="#4、选代学习控制的关键技术" class="headerlink" title="4、选代学习控制的关键技术"></a>4、选代学习控制的关键技术</h4><p>1.学习算法的稳定性和收敛性</p><p>稳定性与收敛性是研究当学习律与被控系统满足什么条件时，选代学习控制过程才是稳定收敛的。算法的稳定性保证了随着学习次数的增加，控制系统不发散，但是对于学习控制系统而言，仅仅稳定是没有实际意义的，只有使学习过程收敛到真值，才能保证得到的控制为某种意义下最优的控制。收敛是对学习控制的最基本要求，多数学者在提出新的学习律的同时，基于被控对象的一些假设，给出了收敛的条件。例如，Arimoto在最初提出PID型学习控制律时，仅针对线性系统在D型学习律下的稳定性和收敛条件作了证明。</p><p>2.初始值问题</p><p>运用迭代学习控制技术设计控制器时，只需要通过重复操作获得的受控对象的误差或误差导数信号。在这种控制技术中，迭代学习总要从某初始点开始，初始点指初始状态或初始输出。几乎所有的收敛性证明都要求初始条件是相同的，解决选代学习控制理论中的初始条件问题一直是人们追求的目标之一。目前已提出的迭代学习控制算法大多数要求被控系统每次运行时的初始状态在期望轨迹对应的初始状态上，即满足初始条件：</p><script type="math/tex; mode=display">x_k(0)=x_d(0),k=0,1,2,…</script><p>当系统的初始状态不在期望轨迹上，而在期望轨迹的某一很小的邻域内时，通常把这类问题归结为学习控制的鲁棒性问题研究。</p><p>3.学习速度问题</p><p>在迭代学习算法研究中，其收敛条件基本上都是在学习次数$k→\infty$下给出的。而在实际应用场合，学习次数$k→\infty$显然是没有任何实际意义的。因此，如何使迭代学习过程更快地收敛于期望值是迭代学习控制研究中的另一个重要问题。ILC本质上是一种前馈控制技术，大部分学习律尽管证明了学习收敛的充分条件，但收敛速度还是很慢。可利用多次学习过程中得到的知识来改进后续学习过程的速度，例如，采用高阶迭代控制算法、带遗忘因子的学习律、利用当前项或反馈配置等方法来构造学习律，可使收敛速度大大加快。</p><p>4.鲁棒性问题</p><p>迭代学习控制理论的提出有浓厚的工程背景，因此仅仅在无干扰条件下过论收敛性问题是不够的，还应讨论存在各种干扰的情形下系统的跟踪性能。一个实际运行的迭代学习控制系统除了存在初始偏移外，还或多或少存在状态扰动、测量噪声、输入扰动等各种干扰。鲁棒性问题讨论存在各种干扰时迭代学习控制系统的跟踪性能。具体地说，一个迭代学习控制系统是鲁棒的，指系统在各种有界干扰的影响下，其迭代轨迹能收敛到期望轨迹的邻域内，而当这些干扰消除时，迭代轨迹会收敛到期望轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械臂的PD控制</title>
      <link href="/2022/03/23/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84PD%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/03/23/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84PD%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="机械臂的PD控制"><a href="#机械臂的PD控制" class="headerlink" title="机械臂的PD控制"></a>机械臂的PD控制</h3><h3 id="1-控制率设计"><a href="#1-控制率设计" class="headerlink" title="1 控制率设计"></a>1 控制率设计</h3><p>当忽略重力和外部干扰的时候，采用独立的PD控制，可以满足机械臂的定点控制的要求。</p><span id="more"></span><p>设n关节机械臂的动力学方程为</p><script type="math/tex; mode=display">D(q)\ddot q+ C(q,\dot q)\dot q=\tau</script><p>其中，$D(q)$为$n\times n $正定惯性矩阵，$C(q,\dot q)$为$n\times n$的离心和哥氏力项。</p><p>独立的PD控制率为</p><script type="math/tex; mode=display">\tau =K_d\dot e +K_pe</script><p>取跟踪误差为$e=q_d-q$，采用定点控制时，$q_d$为常值，则$\dot q_d=\ddot q_d\equiv 0$</p><p>此时，机械臂方程为</p><script type="math/tex; mode=display">D(q)(\ddot q_d-\ddot q)+C(q,\dot q)(\dot q_d - \dot q)+K_d\dot e +K_pe=0</script><p>即</p><script type="math/tex; mode=display">D(q)\ddot e+C(q,\dot q)\dot e +K_pe=-K_d\dot e</script><p>取Lyapunov李雅普诺夫函数为</p><script type="math/tex; mode=display">V= \frac{1}{2}\dot e^TD(q)\dot e+\frac{1}{2}e^TK_pe</script><p>由$D(q)$和$K_p$的正定性可知，$V$是全局正定的，则</p><script type="math/tex; mode=display">\dot V=\dot e^TD\ddot e+\frac{1}{2}\dot e^T\dot D\dot e+\dot e^TK_pe</script><p>利用$\dot D-\ddot 2C$的斜对称性可知，$\dot e^TD\ddot e=2\dot e^TC\ddot e$则</p><script type="math/tex; mode=display">\dot V=\dot e^TD\ddot e+\dot e^T C\dot e+\dot e^TK_pe=\dot e^T(D\ddot e+C\dot e+K_p e)=-\dot e^TK_d\dot e \leq 0</script>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输出受限引理</title>
      <link href="/2022/03/22/%E8%BE%93%E5%87%BA%E5%8F%97%E9%99%90%E5%BC%95%E7%90%86/"/>
      <url>/2022/03/22/%E8%BE%93%E5%87%BA%E5%8F%97%E9%99%90%E5%BC%95%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在实际系统的控制系统中，为了保证系统的安全性，通常会对系统的输出的上下界做出严格的限制，或者要求系统的超调量在一定的范围内，超调量过大往往意味着系统处于不理想的运行状态，某些情况下，会对系统本身产生不可预知的影响。</p><span id="more"></span><h4 id="引理1-1"><a href="#引理1-1" class="headerlink" title="引理1.1"></a>引理1.1</h4><p>针对系统误差</p><script type="math/tex; mode=display">\dot{z}=f(t,z), z=[z_1,z_2]^T</script><p>存在连续可微的正定函数$V_1$和$V_2$，$k_b&gt;0$,位置输出为$X_1$,定义为位置误差$z_1=x_1-y_d$，满足</p><p>（1）当$z_1\rightarrow-k_b$或$z_1\rightarrow k_b$时，有$V_1(z_1)\rightarrow \infty$；</p><p>（2）$\gamma_1(|| z_2||)\leq V_2(z_2)\leq\gamma_2(||z_2||))$,$\gamma_1$为$\gamma_2$为$K_\infty$类函数；</p><p>假设</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adaptive Neural Network Control of a Robotic Manipulator With Time-V arying Output Constraints</title>
      <link href="/2022/03/21/Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints/"/>
      <url>/2022/03/21/Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints/</url>
      
        <content type="html"><![CDATA[<h3 id="Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints"><a href="#Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints" class="headerlink" title="Adaptive Neural Network Control of a Robotic Manipulator With Time-V arying Output Constraints"></a>Adaptive Neural Network Control of a Robotic Manipulator With Time-V arying Output Constraints</h3><h3 id="带时变输出约束的机械臂自适应神经网络控制"><a href="#带时变输出约束的机械臂自适应神经网络控制" class="headerlink" title="带时变输出约束的机械臂自适应神经网络控制"></a>带时变输出约束的机械臂自适应神经网络控制</h3><span id="more"></span><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>研究了不确定n自由度机器人机械臂受时变输出约束的控制问题。将刚性机械臂系统描述为多输入多输出的非线性系统。我们设计了一个干扰观测器来估计来自人类和环境的未知干扰。为了解决不确定性问题，采用径向基函数的神经网络对机械臂的未知动力学进行估计。在控制设计过程中，采用了非对称势垒(障碍)李雅普诺夫函数，避免了输出约束的时变。仿真结果验证了该控制方案的有效性。</p><p>Adaptive neural network (NN) control, barrier</p><p>Lyapunov function (BLF), disturbance observer (DO)</p><h4 id="论文拟解决的主要问题"><a href="#论文拟解决的主要问题" class="headerlink" title="论文拟解决的主要问题"></a><strong>论文拟解决的主要问题</strong></h4><p>机器人系统的输入输出普遍存在饱和、死区、安全规范等约束。由于现在要求机器人与人类和环境有更多的物理互动，违反这些约束所产生的安全问题是不可忽视的。因此，我们需要设计有针对性的控制器来处理这些问题。在人与环境的相互作用下，对未知的动力学和未知的扰动的不确定机械臂的控制具有挑战性。</p><p>传统的李雅普诺夫函数的目标是实现有保证的全局或半全局稳定性，而在本文中，我们不仅要保证系统的半全局稳定性，而且要避免时变约束的冲突。研究中常见的约束通常是常数约束，而常数约束可以看作是一种特殊的时变约束，因此时变约束的研究更为实际。现有的大量论文考虑了无约束的非线性系统、具有输入约束的非线性系统、具有恒定输出约束的非线性系统，或具有时变输出约束的某些SISO非线性系统。因此，需要解决MIMO未知机器人系统在未知扰动和时变输出约束下的控制问题</p><h4 id="论文主要研究内容"><a href="#论文主要研究内容" class="headerlink" title="论文主要研究内容"></a><strong>论文主要研究内容</strong></h4><p>利用自适应神经网络对机械臂系统的不确定动力学进行补偿。在控制设计过程中利用非对称blf（障碍李雅普诺夫函数）来克服输出约束的时变问题。本文的主要贡献如下:</p><p>1)通过基于神经网络的自适应控制律，成功地补偿了系统不确定性的影响，提高了机器人系统的鲁棒性。</p><p>2)将神经网络估计误差与来自人、环境的未知干扰集成为一个组合干扰，最后由DO逼近。</p><p>3)为了避免时变约束的冲突，采用非对称blf设计控制律，成功实现了渐近跟踪。</p><h4 id="论文的算法"><a href="#论文的算法" class="headerlink" title="论文的算法"></a><strong>论文的算法</strong></h4><p><img src="1.png" alt="1"  /></p><p><img src="2.png" alt="2" style="zoom:67%;" /></p><p>控制目标就是设计控制率，使得输出可以跟踪轨迹q，同时不能违反时变输出约束，如果给出了时变的边界，kc和kc-，输出qt就应该在这个边界内。</p><p><img src="3.png" alt="3" style="zoom: 80%;" /></p><h4 id="控制算法设计"><a href="#控制算法设计" class="headerlink" title="控制算法设计"></a><strong>控制算法设计</strong></h4><p>使用神经网络来弥补系统不确定性的影响，并使用时变的blf来避免时变约束的冲突。我们定义了一种新的由神经网络估计误差和来自人类和环境的未知外部干扰组成的复合干扰，该复合干扰由DO估计。控制策略如图2所示。</p><p><img src="4.png" alt="4"  /></p><p><img src="5.png" alt="5"  /></p><p>定义了误差变量z1和误差变量的导数。还定义了一个新的误差变量z2，γ是辅助变量。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>我们考虑一个如图3所示的三自由度机器人机械手。该机器人有两个旋转关节和一个移动关节。手腕的位置是由两个旋转关节和一个移动关节(RRP)的两次旋转和一次平移决定的。为了验证该控制方法的有效性，对一个三自由度机器人系统进行了仿真。我们定义</p><p><img src="6.png" alt="6"  /></p><p><img src="7.png" alt="7"  /></p><p><img src="8.png" alt="8"  /></p><p><img src="9.png" alt="9"  /></p><p><img src="10.png" alt="10"  /></p><p>仿真使用了三种不同的控制率，第一个是基于模型的控制，第二个使用自适应神经网络的控制，第三个使用传统的pd控制。</p><p><img src="11.png" alt="11"  /></p><p>可以看出，输出的q可以精确地跟踪期望的轨迹qd。由图5-7可知，跟踪误差z11、z12、z13收敛到一个接近零的小值</p><p>针对一类受时变约束和未知干扰的不确定n-DOF机器人，提出了一种基于DOs的自适应神经网络控制方法。我们用神经网络估计机器人的未知动力学模型，用DOs逼近时变扰动。使用非对称BLF避免与输出约束的冲突。仿真结果表明，所提出的控制方案能在保证约束条件满足的情况下，使输出很好地跟随目标轨迹。</p><p><img src="12.png" alt="12"  /></p><p><img src="13.png" alt="13"  /></p><p>与此同时，它们的约束从未被打破。图8给出了控制输入力矩τ1、τ2和τ3。DO的近似误差如图9所示。我们可以看到，DO估计误差越来越小，最后接近于零。综上所述，本文提出的基于模型的控制方法取得了满意的控制效果。</p><p>但是，基于模型的控制律是在已知机械臂系统的精确参数的基础上建立起来的，而这些参数在实际操作中通常是未知的</p><p>对于神经网络控制律，图10表明，输出q可以在很小的误差下遵循期望的轨迹qd。由图11-13可知，跟踪误差z11、z12、z13收敛到一个接近零的小值。同时，它们都明显排斥时变边界−ka(t)和kb(t)，即不违反输出约束</p><p>F g18表明输出q可以大致跟随所需轨迹qd，但从图20和图21可以明显看出，q2和q3的约束被打破了。图22给出了PD控制输入力矩，从中我们可以看到输入是有界的。</p><p>控制目标就是设计控制率，使得输出可以跟踪轨迹q，同时不能违反时变输出约束，如果给出了时变的边界，kc和kc-，输出qt就应该在这个边界内。</p><p><img src="14.png" alt="14"  /></p><p><img src="15.png" alt="15"  /></p><p><img src="16.png" alt="16"  /></p><p><img src="17.png" alt="17"  /></p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 论文阅读笔记 </category>
          
          <category> 英文论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 论文，英文论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械臂相关论文列表</title>
      <link href="/2022/03/21/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/"/>
      <url>/2022/03/21/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="论文列表"><a href="#论文列表" class="headerlink" title="论文列表"></a>论文列表</h3><p>​        1、Z. Yang, W. Lu, Z. Yao and B. Zhang, “Neuroadaptive backstepping tracking control of robotic manipulators considering actuator dynamics,” The 27th Chinese Control and Decision Conference (2015 CCDC), 2015, pp. 465-470, doi: 10.1109/CCDC.2015.7161737.</p><p>考虑执行器动力学的机器人神经自适应反步跟踪控制</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 论文列表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
