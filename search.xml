<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数字图像处理实验</title>
      <link href="/2022/04/15/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"/>
      <url>/2022/04/15/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="opencv中文文档httpsopencv.apachecn.org">opencv中文文档：<ahref="https://opencv.apachecn.org/#/">https://opencv.apachecn.org</a></h1><p>[TOC]</p><h2 id="实验一-python中数字图像处理的基本操作">实验一Python中数字图像处理的基本操作</h2><span id="more"></span><h3 id="一实验目的">一、实验目的</h3><p>1 熟悉及掌握在 python中能够处理哪些格式图像；</p><p>2 熟练掌握在 python中如何 用 OpenCV读取图像；</p><p>3 掌握如何利用python来获取图像的大小、颜色、高度、宽度等等相关信息；</p><p>4 掌握如何在 python中 用 OpenCV按照指定要求存储一幅图像的方法；</p><p>5 图像间如何转化。</p><h3 id="二实验原理">二、实验原理</h3><h4 id="数字图像的表示和类别">1.数字图像的表示和类别</h4><p>一幅图像可以被定义为一个二维函数f(x,y),其中 x和 y是空间 (平面 )坐标，f 在任何坐标(x,y)处的振幅称为图像在该点的亮度。灰度是用来表示黑白图像亮度的一个术语，而彩色图像是由单个二维图像组合形成的。例如，在RGB彩色系统中，一幅彩色图像是由三幅独立的分量图像 (红、绿、蓝)组成的。因此，许多为黑白图像处理开发的技术适用于彩色图像处理，方法是分别处理三副独立的分量图像即可。</p><p>要将这样的一幅图像转化为数字形式，就要求数字化坐标和振幅。将坐标值数字化成为取样；将振幅数字化成为量化。采样和量化的过程如图1所示。因此，当 f的 x、y分量和振幅都是有限且离散的量时，称该图像为数字图像。</p><p><img src="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220415212141944.png" alt="image-20220415212141944" style="zoom: 80%;" /></p><center style="color=#C0C0C0;text-decoration:underline">图1 图像的采样和量化</center><p>在python中，一幅图像可能包含一个数据矩阵，也可能有一个颜色映射表矩阵。opencv支持四种图像类型，其区别在于数据矩阵元素的不同含义。它们是：</p><p> 亮度图像（ Intensity images）</p><p> 二值图像（ Binary images）</p><p> 索引图像（ Indexed images）</p><p> RGB图像（ RGB images）</p><p>(1)亮度图像。</p><p>也称灰度图像。一幅亮度图像是一个数据矩阵，其归一化的取值表示亮度。若亮度图像一幅亮度图像是一个数据矩阵，其归一化的取值表示亮度。若亮度图像的像素都是的像素都是uint8类或类或uint16类，则它们的整数值范围分别是类，则它们的整数值范围分别是[0，255]和和[0，65536]。若。若图像图像是是double类，则像素取值就是浮点数。规定双精度型归一化亮度图像的取值范围是类，则像素取值就是浮点数。规定双精度型归一化亮度图像的取值范围是[0，1]。。</p><p>(2)二值图像</p><p>二值图像是指在图像中，每个像素的灰度等级只有两种。即全黑或者全白，在二值图像是指在图像中，每个像素的灰度等级只有两种。即全黑或者全白，在python种，种，一幅二值图像是一个取值只有一幅二值图像是一个取值只有0和和255的的numpy数组数组。</p><p>(3)索引图像</p><p>索引颜色通常也称为映射颜色，在这种模式下，颜色都是预先定义的，并且可供选用的索引颜色通常也称为映射颜色，在这种模式下，颜色都是预先定义的，并且可供选用的一组颜色也很有限，索引颜色的图像最多只能显示一组颜色也很有限，索引颜色的图像最多只能显示256种颜色。种颜色。一幅索引颜色图像在图像文件里定义，当打开该文件时，构成该图像具体颜色的索引值一幅索引颜色图像在图像文件里定义，当打开该文件时，构成该图像具体颜色的索引值就被读入程序里，然后根据索引值找到最终的颜色。就被读入程序里，然后根据索引值找到最终的颜色。</p><ol start="4" type="1"><li>RGB图像</li></ol><p>一幅RGB图像就是彩色像素的一个图像就是彩色像素的一个M×N×3数组，其中每一个彩色相似点都是在特定数组，其中每一个彩色相似点都是在特定空间位置的彩色图像相对应的红、绿、蓝三个分量。按照惯例，形成一幅空间位置的彩色图像相对应的红、绿、蓝三个分量。按照惯例，形成一幅RGB彩色图像的彩色图像的三个图像常称为红、绿或蓝分量图像。三个图像常称为红、绿或蓝分量图像。</p><p>值得注意的是，在OpenCV中，加载图像通道的顺序是中，加载图像通道的顺序是BGR（实验五中您将用到此特（实验五中您将用到此特性）性）。。但是但是Matplotlib（（python的一个绘图库）以的一个绘图库）以RGB模式显示。因此，如果使用模式显示。因此，如果使用OpenCV读取彩色图像，则读取彩色图像，则Matplotlib中将无法正确显示彩色图像。中将无法正确显示彩色图像。</p><h4id="opencv图像文件格式图像文件格式">2.OpenCV图像文件格式图像文件格式</h4><p>OpenCV支持支持处理处理以下几种图像文件格式：以下几种图像文件格式：</p><p>1 PCX（WindowsPaintbrus），可处理1，4，8，16，24位等图像数据。文件位等图像数据。文件内容包括：文件头（内容包括：文件头（128字节），图像数据、扩展颜色映射表数据。字节），图像数据、扩展颜色映射表数据。</p><p>2 BMP（WindowsBitmap格式。有1，4，8，24位非压缩图像，位非压缩图像，8位位RLE（（Run-lengthEncoded）图像。文件内容包括：文件头（一个）图像。文件内容包括：文件头（一个BITMAPFILEHEADER数据结构），数据结构），位图信息数据块（位图信息头位图信息数据块（位图信息头BITMAPINFOHEADER和一个颜色表）和图像数据。和一个颜色表）和图像数据。</p><p>3 HDF（（Hierarchical DataFormat）格式。有8位，位，24位光栅数据集。位光栅数据集。</p><p>4 JPEG(Joint Photographic ExpertsGroup)格式，是一种成为联合图像专家组的图像压格式，是一种成为联合图像专家组的图像压缩格式。缩格式。</p><p>5 TIFF（Tagged Image FileFormat）格式，处理1，4，8，24位非压缩图像，位非压缩图像，1，，4，，8，，24位位packbit压缩图像，一位压缩图像，一位CCITT压缩图像等。文件内容压缩图像等。文件内容包括：文件头，参数指针表包括：文件头，参数指针表与参数域，参数数据表和图像数据四部分。与参数域，参数数据表和图像数据四部分。</p><p>6 XWD(X WindowsDump)格式。1，8位位Zpixmaps,XYbitmaps,1位位XYpixmaps。。</p><p>7 PNG（Portable Network Graphics）格式。</p><h3 id="三实验内容">三、实验内容</h3><p>1利用OpenCV读取一幅彩色图像，并读取图像的基本信息；</p><p>2 利用OpenCV显示图像；</p><p>3 对彩色图像进行灰度化化处理；</p><p>4 对灰度图像进行二值化处理；</p><p>5 对图像进行几何变换（缩放，平移，翻转）；</p><p>6 储存处理后的图像；</p><h3 id="四实验报告要求">四、实验报告要求</h3><p>1给出使用给出使用opencv-python进行图像读取、显示、翻转、裁剪，存储的完整代码。</p><p>2 写出实验的心得与体会。</p><h3 id="五预习要求">五、预习要求</h3><p>1 了解python 基本语法以及基本语法以及图像处理API--OpenCV。</p><p>2 了解opencv图像基础操作函数。</p><h3 id="六实验">六、实验</h3><h4 id="示例程序">1.示例程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv <span class="comment">#引入 OpenCV库</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;1.jpg&#x27;</span>) <span class="comment">#使用 imread函数读取图像 ，并以 numpy数组形式储存</span></span><br><span class="line"><span class="built_in">print</span>(img.shape) <span class="comment">#查看图像的大小。返回的元组（ touple）中的三个数依次表示高度、宽度和通道数</span></span><br><span class="line"><span class="built_in">print</span>(img.dtype) <span class="comment">#查看图片的类型</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;img&#x27;</span>,img) <span class="comment">#使用 imshow函数显示图像，第一个参数是窗口名称（可不写），第二个参数是要显示的图像的名称，一定要写</span></span><br><span class="line">cv.waitKey(<span class="number">0</span>) <span class="comment">#可以让窗口一直显示图像直到按下任意按键</span></span><br><span class="line">img_GRAY = cv.cvtColor(img,cv.COLOR_BGR2GRAY) <span class="comment">#使用 cv.cvtColor函数转换色彩空间 参数 ‘cv.COLOR_BGR2GRAY’表示从RGB空间转换到灰度空间</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;gray&#x27;</span>,img_GRAY)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">ret,thresh = cv.threshold(img_GRAY,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY) <span class="comment">#使用 cv.threshold函数进行图像阈值处理 参数‘cv.THRESH_BINARY’代表了阈值的类型 127为阈值</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;threshold&#x27;</span>,thresh)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">res = cv.resize(img,<span class="literal">None</span>,fx=<span class="number">2</span>,fy=<span class="number">2</span>,interpolation=cv.INTER_CUBIC) <span class="comment">#使用 cv.resize函数进行图像缩放</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;resize&#x27;</span>,res)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.imwrite(<span class="string">&#x27;result.jpg&#x27;</span>,res) <span class="comment">#保存图像</span></span><br></pre></td></tr></table></figure><h4 id="实验程序">2 实验程序</h4><p>1利用OpenCV读取一幅彩色图像，并读取图像的基本信息；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python:</span><br><span class="line">retval=cv.imread(filename[, flags])</span><br><span class="line">从文件加载图像。函数IMRead从指定文件加载图像并返回它。 如果无法读取图像（由于缺少文件，不正确的权限，不受支持或无效格式），则该函数返回一个空矩阵（MAT :: data == null）。</span><br></pre></td></tr></table></figure><h5 id="访问和修改像素值"><ahref="https://opencv.apachecn.org/#/docs/4.0.0/3.1-tutorial_py_basic_ops?id=访问和修改像素值">访问和修改像素值</a></h5><p>先来理解一下，图像与一般的矩阵或张量有何不同(不考虑图像的格式，元数据等信息)。首先，一张图像有自己的属性，宽，高，通道数。其中宽和高是我们肉眼可见的属性，而通道数则是图像能呈现色彩的属性。我们都知道，光学三原色是红色，绿色和蓝色，这三种颜色的混合可以形成任意的颜色。常见的图像的像素通道也是对应的R，G，B三个通道，在OpenCV中，每个通道的取值为0～255，。(注：还有RGBA，YCrCb，HSV等其他图像通道表示)。即，一般彩色图像读进内存之后是一个h* w *c的矩阵，其中h为图像高(相当于矩阵的行)，w为图像宽(相当于矩阵列)，c为通道数。</p><p>下面我们先加载一副彩色图像，更准确的说，是一副黄色图像，如图所示。</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/yellow-16500308353862.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>黄色为绿色和红色的混合，所以，该图像的所有像素值都应为R=255，G=255，B=0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img = cv2.imread(<span class="string">&quot;img/yellow.jpg&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h,w,c = img.shape</span><br><span class="line"><span class="comment">#图像为128*128*3的大小</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(h,w,c)</span><br><span class="line"><span class="number">128</span> <span class="number">128</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，您可以通过行和列坐标访问像素值。注意,对于常见的RGB图像，OpenCV的imread函数返回的是一个蓝色(Blue)、绿色(Green)、红色(Red)值的数组，维度大小为3。而对于灰度图像，仅返回相应的强度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">100</span>,<span class="number">100</span>]</span><br><span class="line"><span class="comment">#OpenCV的读取顺序为B，G，R，由于图像所有像素为黄色，因此，G=255，R=255</span></span><br><span class="line">array([  <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>], dtype=uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅访问蓝色通道的像素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blue = img[<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(blue)</span><br><span class="line"><span class="number">0</span>复制ErrorOK!</span><br></pre></td></tr></table></figure><p>你也可以使用同样的方法来修改像素值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">100</span>,<span class="number">100</span>] = [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(img[<span class="number">100</span>,<span class="number">100</span>])</span><br><span class="line">[<span class="number">255</span> <span class="number">255</span> <span class="number">255</span>]</span><br></pre></td></tr></table></figure><p>2 利用OpenCV显示图像；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv.imshow(<span class="string">&#x27;img&#x27;</span>,img) <span class="comment">#使用 imshow函数显示图像，第一个参数是窗口名称（可不写），第二个参数是要显示的图像的名称，一定要写</span></span><br><span class="line">cv.waitKey(<span class="number">0</span>) <span class="comment">#可以让窗口一直显示图像直到按下任意按键</span></span><br></pre></td></tr></table></figure><p>3 对彩色图像进行灰度化化处理；</p><p><img src="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220425232528758.png" alt="image-20220425232528758" style="zoom: 80%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img_GRAY = cv.cvtColor(img,cv.COLOR_BGR2GRAY) <span class="comment">#使用 cv.cvtColor函数转换色彩空间 参数 ‘cv.COLOR_BGR2GRAY’表示从RGB空间转换到灰度空间</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;gray&#x27;</span>,img_GRAY)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>4 对灰度图像进行二值化处理；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret,thresh = cv.threshold(img_GRAY,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY) <span class="comment">#使用 cv.threshold函数进行图像阈值处理 参数‘cv.THRESH_BINARY’代表了阈值的类型 127为阈值</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;threshold&#x27;</span>,thresh)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>5 对图像进行几何变换（缩放，平移，翻转）；</p><p><ahref="https://opencv.apachecn.org/#/docs/4.0.0/4.2-tutorial_py_geometric_transformations">图像的几何变换(apachecn.org)</a></p><h6 id="变换"><ahref="https://opencv.apachecn.org/#/docs/4.0.0/4.2-tutorial_py_geometric_transformations?id=变换">变换</a></h6><p>OpenCV 提供了两个转换函数，<strong><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983">cv.warpAffine</a></strong>和 <strong><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87">cv.warpPerspective</a>*<em>，可以进行各种转换。*</em><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983">cv.warpAffine</a></strong>采用 2x3 变换矩阵，而 <strong><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87">cv.warpPerspective</a></strong>采用 3x3 变换矩阵作为输入。</p><h6 id="缩放"><ahref="https://opencv.apachecn.org/#/docs/4.0.0/4.2-tutorial_py_geometric_transformations?id=缩放">缩放</a></h6><p>缩放是调整图片的大小。 OpenCV 使用 <strong><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d">cv.resize()</a></strong>函数进行调整。可以手动指定图像的大小，也可以指定比例因子。可以使用不同的插值方法。对于下采样(图像上缩小)，最合适的插值方法是<strong><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121acf959dca2480cc694ca016b81b442ceb">cv.INTER_AREA</a></strong>对于上采样(放大),最好的方法是 <strong><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121a55e404e7fa9684af79fe9827f36a5dc1">cv.INTER_CUBIC</a></strong>（速度较慢）和 <strong><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121ac97d8e4880d8b5d509e96825c7522deb">cv.INTER_LINEAR</a></strong>(速度较快)。默认情况下，所使用的插值方法都是 <strong><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121acf959dca2480cc694ca016b81b442ceb">cv.INTER_AREA</a></strong>。你可以使用如下方法调整输入图片大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img = cv.imread(<span class="string">&#x27;messi5.jpg&#x27;</span>)</span><br><span class="line">res = cv.resize(img,<span class="literal">None</span>,fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation = cv.INTER_CUBIC)</span><br><span class="line"><span class="comment">#OR</span></span><br><span class="line">height, width = img.shape[:<span class="number">2</span>]</span><br><span class="line">res = cv.resize(img,(<span class="number">2</span>*width, <span class="number">2</span>*height), interpolation = cv.INTER_CUBIC)</span><br></pre></td></tr></table></figure><h6 id="平移变换"><ahref="https://opencv.apachecn.org/#/docs/4.0.0/4.2-tutorial_py_geometric_transformations?id=平移变换">平移变换</a></h6><p>平移变换是物体位置的移动。如果知道 <strong>（x，y）</strong>方向的偏移量，假设为 <strong>(t_x,t_y)*<em>，则可以创建如下转换矩阵*</em>M</strong>：</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/Geometric_Transformations_fomula_1.png"alt="图片" /><figcaption aria-hidden="true">图片</figcaption></figure><p>您可以将变换矩阵存为 np.float32 类型的 numpy 数组，并将其作为<strong><ahref="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983">cv.warpAffine</a></strong>的第二个参数。请参见以下转换（100,50）的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img = cv.imread(<span class="string">&#x27;messi5.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">rows,cols = img.shape</span><br><span class="line">M = np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>]])</span><br><span class="line">dst = cv.warpAffine(img,M,(cols,rows))</span><br><span class="line">cv.imshow(<span class="string">&#x27;img&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>6 储存处理后的图像；</p><p>cv.imwrite('result.jpg',res) #保存图像</p><h3 id="七-部分实验结果">七、 部分实验结果</h3><h4 id="原图像">1 原图像</h4><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220425233257492.png"alt="image-20220425233257492" /><figcaption aria-hidden="true">image-20220425233257492</figcaption></figure><h4 id="灰度图像">2 灰度图像</h4><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220425233324332.png"alt="image-20220425233324332" /><figcaption aria-hidden="true">image-20220425233324332</figcaption></figure><h4 id="二值图像">3 二值图像</h4><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220425233418464.png"alt="image-20220425233418464" /><figcaption aria-hidden="true">image-20220425233418464</figcaption></figure><h4 id="放大两倍后的图像">4 放大两倍后的图像：</h4><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220425233441600.png"alt="image-20220425233441600" /><figcaption aria-hidden="true">image-20220425233441600</figcaption></figure><h2 id="实验二-数字图像增强实验">实验二 数字图像增强实验</h2><h4 id="一实验目的-1">一、实验目的</h4><p>1.熟悉并学会 opencv python 中图像增强的相关函数</p><p>2.了解图像增强的方法、去噪的方法和效果 。</p><h3 id="二实验主要仪器设备">二、实验主要仪器设备</h3><p>(1)计算机</p><p>(2)python 软件</p><p>(3)典型的灰度、彩色图像文件 。</p><h3 id="三实验原理">三、实验原理</h3><p>图像增强是指按特定的需要突出一幅图像中的某些信息，同时，消弱或去除某些不需要的信息的处理方法。其主要目的是处理后的图像对某些特定的应用比原来的图像更加有效。图像增强技术主要有直方图修改处理、图像平滑化处理、图像尖锐化处理和彩色处理技术等。本实验以直方图均衡化增强图像对比度的方法为主要内容，其他方法同学们可以在课后自行练习 。</p><h4 id="直方图">1 直方图</h4><p>直方图是多种空间域处理技术的基础。直方图操作能有效地用于图像增强。除了提供有用的图像统计资料外，直方图固有的信息在其他图像处理应用中也是非常有用的，如图像压缩与分割。直方图在软件中易于计算，也适用于商用硬件设备，因此，它们成为了实时图像处理的一个流行工具。</p><p>直方图是图像的最基本的统计特征，它反映的是图像的灰度值的分布情况。直方图均衡化的目的是使图像在整个灰度值动态变化范围内的分布均匀化，改善图像的亮度分布状态，增强图像的视觉效果。灰度直方图是图像预处理中涉及最广泛的基本概念之一。</p><p>图像的直方图事实上就是图像的亮度分布的概率密度函数，是一幅图像的所有象素集合的最基本的统计规律。直方图反映了图像的明暗分布规律，可以通过图像变换进行直方图调整，获得较好的视觉效果。</p><p>直方图均衡化是通过灰度变换将一幅图像转换为另一幅具有均衡直方图，即在每个灰度级上都具有相同的象素点数的过程。#### 2 图像锐化 图像锐化(image是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰，分为空域处理和频域处理两类。</p><h4 id="图像平滑">3 图像平滑</h4><p>图像平滑是对图像作低通滤波 ，可在空间域或频率域实现。</p><h3 id="四实验内容">四、实验内容</h3><p>1 绘制灰度图像直方图；</p><p>2 对直方图均衡化</p><p>3利用模版进行空域滤波</p><p>4分别利用常见低通（平滑）滤波器与高通（锐化）滤波器进行频域滤波（滤波器公式见实验指导）</p><h3 id="五实验报告要求">五、实验报告要求</h3><p>(1)说明利用 opencv python 图像处理 工具包实现灰度修正、图像平滑、锐化的方法</p><p>(2)列出上述图像处理的程序</p><p>(3)记录灰度修正、图像平滑、图像锐化的图像，回答思考题</p><p>(4)心得和体会 。</p><h3 id="六预习要求">六、预习要求</h3><p>(1)了解 opencv python 图像处理 包 关于图像 增强的有关功能；</p><p>(2)列出上述图像处理的流程。</p><h3 id="七思考题">七、思考题</h3><p>(1)如何针对图像过暗、过亮、对比度不足设计灰度变换函数？</p><p>(2)比较同一种去噪方法对不同噪声处理的效果。</p><p>(3)讨论梯度法锐度图像的 4 种不同方法的应用范围。 ### 八、实验指导#### 1绘制灰度直方图 OpenCV利用 calcHist() 函数来绘制直方图 ca lcHist()函数原型为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist = cv2.calcHist(img , channels, mask, histSize, ranges, accumulate)</span><br></pre></td></tr></table></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220426105941609.png"alt="image-20220426105941609" /><figcaption aria-hidden="true">image-20220426105941609</figcaption></figure><p>由于calcHist() 函数返回的是二维数组，可利用 matplotlib 库绘制图像。部分代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;images/buffalos.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">255</span>])</span><br><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="直方图均衡">2.直方图均衡</h4><p>OpenCV 中的直方图均衡化函数为cv2.equalizeHist()。该函数的输入为灰度图像，输出结果为直方图均衡化后的图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br></pre></td></tr></table></figure><h4 id="空域滤波空域平滑或锐化">3.空域滤波(空域平滑或锐化)</h4><h5 id="平滑滤波">(1)平滑滤波</h5><p>平滑滤波是低频增强的空间域滤波技术。它的目的有两类：一类是模糊；另一类是消除噪音。空间域的平滑滤波一般采用简单平均法进行，就是求邻近像元点的平均亮度值。邻域的大小与平滑的效果直接相关，邻域越大平滑的效果越好，但邻域过大，平滑会使边缘信息损失的越大，从而使输出的图像变得模糊，因此需合理选择邻域的大小。</p><h6 id="均值滤波">均值滤波</h6><p>OpenCV 中均值模板可以用cv2.blur 和cv2.boxFilter函数实现。其基本用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blur = cv2.blur(img, (<span class="number">3</span>, <span class="number">5</span>)) <span class="comment"># 模板大小为3*5, 模板的大小是可以设定的</span></span><br><span class="line">box = cv2.boxFilter(img, -<span class="number">1</span>, (<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><h6 id="高斯模糊滤波">高斯模糊滤波</h6><p>Opencv 中使用cv2.GaussianBlur()函数实现高斯模糊。其基本用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>) <span class="comment"># （5,5）表示的是卷积模板的大小，0 表示的是沿x 与y 方向上的标准差</span></span><br></pre></td></tr></table></figure><h6 id="中值滤波">中值滤波</h6><p>Opencv 用cv2.medianBlur()函数实现中值滤波。其基本用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv2.medianBlur(img, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h5 id="锐化滤波">(2)锐化滤波</h5><h6 id="roberts-算子">Roberts 算子</h6><p>Roberts 算法简介</p><p>Roberts算法又称为交叉微分算法，它是基于交叉差分的梯度算法，通过局部差分计算检测边缘线条。常用来处理具有陡峭的低噪声图像，当图像边缘接近于正45度或负45 度时，该算法处理效果更理想。Roberts算子的模板分为水平方向和垂直方向，如下所示：</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220426110855989.png"alt="image-20220426110855989" /><figcaption aria-hidden="true">image-20220426110855989</figcaption></figure><p>OpenCV 中Roberts 算法库函数使用</p><p>在OpenCV 官方的库中，也提供了 Roberts 算法库函数，调用 OpenCV 的filter2D()函数实现边缘提取。该函数主要是利用内核实现对图像的卷积运算，然后通过addWeighted()函数来进行 x 方向与 y 方向上的结合 。</p><p> filter2D() 函数原型： result=cv2.filter2D( img , cv2.CV_16S,</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220426110957454.png"alt="image-20220426110957454" /><figcaption aria-hidden="true">image-20220426110957454</figcaption></figure><p>其中ddepth表示目标图像的所需深度，它包含有关图像中存储的数据类型的信息，可以是unsigned char CV_8U signed char CV_8S unsigned short CV_16U等等 ...</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220426111040061.png"alt="image-20220426111040061" /><figcaption aria-hidden="true">image-20220426111040061</figcaption></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220426111054235.png"alt="image-20220426111054235" /><figcaption aria-hidden="true">image-20220426111054235</figcaption></figure><p>代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">一般来说，对图像轮廓提取都会经过如下步骤，灰度</span></span><br><span class="line"><span class="string">滤波去噪 阈值化处理 形态学处</span></span><br><span class="line"><span class="string">理，前面如果达标，这步骤可以省略 轮廓提取</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">读取图像</span><br><span class="line">img=cv2.imread(<span class="string">&quot;images/building.jpg&quot;</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">图像高斯滤波去噪</span><br><span class="line">blur=cv2.GaussianBlur(img,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">核尺寸通过对图像的调节自行定义</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">图像阈值化处理</span><br><span class="line">ret,thresh1=cv2.threshold(blur,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY) <span class="comment">#</span></span><br><span class="line">二进制阈值化</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">调用 Roberts 算法的 OpenCV 库函数进行图像轮廓提取</span><br><span class="line"></span><br><span class="line">kernelx = np.array([[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]], dtype=<span class="built_in">int</span>)</span><br><span class="line">kernely = np.array([[<span class="number">0</span>,-<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]], dtype=<span class="built_in">int</span>)</span><br><span class="line">x = cv2.filter2D(thresh1, cv2.CV_16S, kernelx)</span><br><span class="line">y = cv2.filter2D(thresh1, cv2.CV_16S, kernely)</span><br><span class="line"><span class="comment">#转uint8</span></span><br><span class="line">absX = cv2.convertScaleAbs(x)</span><br><span class="line">absY = cv2.convertScaleAbs(y)</span><br><span class="line">Roberts = cv2.addWeighted(absX,<span class="number">0.5</span>,absY,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Roberts&quot;</span>,Roberts)</span><br><span class="line">cv2.waitKey()</span><br></pre></td></tr></table></figure><h6 id="prewitt-算子">Prewitt 算子</h6><p>Prewitt 算法简介</p><p>Prewitt算子是一种一阶微分算子的边缘检测，利用像素点上下、左右邻点的灰度差，在边缘处达到极值检测边缘，去掉部分伪边缘，对噪声具有平滑作用。其原理是在图像空间利用两个方向模板与图像进行邻域卷积来完成的，这两个方向模板一个检测水平边缘，一个检测垂直边缘。Prewitt算法适合用来识别噪声较多、灰度渐变的图像；水平和竖直方向上的卷积模板如下所示：</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220426111245686.png"alt="image-20220426111245686" /><figcaption aria-hidden="true">image-20220426111245686</figcaption></figure><p>OpenCV 中Prewitt 算法库函数使用</p><p>OpenCV 官方同样对Prewitt 算法有对应的库函数，与Roberts算法算法的库函数一样，只是传递的卷积核有变化；通过Numpy定义模板，再调用OpenCV的filter2D()函数实现对图像的卷积运算，最终通过convertScaleAbs()和addWeighted()函数实现边缘提取，函数原型参考Roberts算法介绍的函数原型。</p><p>部分代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调用Prewitt 算法的OpenCV 库函数进行图像轮廓提取</span></span><br><span class="line">kernelx = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>]],dtype=<span class="built_in">int</span>)</span><br><span class="line">kernely = np.array([[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]],dtype=<span class="built_in">int</span>)</span><br><span class="line">x = cv2.filter2D(thresh1, -<span class="number">1</span>, kernelx)</span><br><span class="line">y = cv2.filter2D(thresh1, -<span class="number">1</span>, kernely)</span><br></pre></td></tr></table></figure><h6 id="sobel-算子">Sobel 算子</h6><p>Sobel 算法简介</p><p>Sobel算法(索贝尔算子)是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导。该算子用于计算图像明暗程度近似值，根据图像边缘旁边明暗程度把该区域内超过某个数的特定点记为边缘。Sobel算子在Prewitt算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。当对精度要求不是很高时，Sobel算子是一种较为常用的边缘检测方法，其卷积模板如下所示：</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220426111423774.png"alt="image-20220426111423774" /><figcaption aria-hidden="true">image-20220426111423774</figcaption></figure><p>OpenCV 中Roberts 算法库函数使用</p><p>OpenCV 中提供了专门的Soble 算法的库函数,函数原型：</p><p>result=cv2.Sobel(img, ddepth, dx, dy, ksize)</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220426111446729.png"alt="image-20220426111446729" /><figcaption aria-hidden="true">image-20220426111446729</figcaption></figure><p>部分代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调用Sobel 算法的OpenCV 库函数进行图像轮廓提取</span></span><br><span class="line">x = cv2.Sobel(thresh1, cv2.CV_16S, <span class="number">1</span>, <span class="number">0</span>) <span class="comment">#对x 求一阶导</span></span><br><span class="line">y = cv2.Sobel(thresh1, cv2.CV_16S, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">#对y 求一阶导</span></span><br><span class="line">absX = cv2.convertScaleAbs(x) <span class="comment">#对x 取绝对值，并将图像转换为8 位图</span></span><br><span class="line">absY = cv2.convertScaleAbs(y) <span class="comment">#对y 取绝对值，并将图像转换为8 位图</span></span><br><span class="line">Sobel = cv2.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="频域滤波频域平滑或锐化">4、频域滤波(频域平滑或锐化)</h4><h5 id="常见低通平滑滤波器">(1)常见低通（平滑）滤波器</h5><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220426111636474.png"alt="image-20220426111636474" /><figcaption aria-hidden="true">image-20220426111636474</figcaption></figure><h5 id="常见高通锐化滤波器">(2)常见高通（锐化）滤波器</h5><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220428200737100.png"alt="image-20220428200737100" /><figcaption aria-hidden="true">image-20220428200737100</figcaption></figure><h4 id="九实验结果">九、实验结果</h4><h5 id="直方图处理">(1)直方图处理：</h5><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220428203832779.png"alt="image-20220428203832779" /><figcaption aria-hidden="true">image-20220428203832779</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">原图像</center><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220428203916774.png"alt="image-20220428203916774" /><figcaption aria-hidden="true">image-20220428203916774</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">灰度直方图</center><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220428204011392.png"alt="image-20220428204011392" /><figcaption aria-hidden="true">image-20220428204011392</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">直方均衡后的图像</center><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220428204109388.png"alt="image-20220428204109388" /><figcaption aria-hidden="true">image-20220428204109388</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">直方图均 衡 后的 灰度直方图</center><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">img=cv2.imread(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;aaa&quot;</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">img_GRAY = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) <span class="comment">#使用 cv.cvtColor函数转换色彩空间 参数 ‘cv.COLOR_BGR2GRAY’表示从RGB空间转换到灰度空间</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;gray&#x27;</span>,img_GRAY)</span><br><span class="line">hist = cv2.calcHist([img_GRAY], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">255</span>])</span><br><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br><span class="line">equ = cv2.equalizeHist(img_GRAY)</span><br><span class="line">cv2.imshow(<span class="string">&quot;aaa1&quot;</span>,equ)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([equ], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">255</span>])</span><br><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h5 id="平滑与锐化">(2)平滑与锐化</h5><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/2.jpg"alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">原图像</center><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220428204645583.png"alt="image-20220428204645583" /><figcaption aria-hidden="true">image-20220428204645583</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">Sobel 算子</center><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">img=cv.imread(<span class="string">&quot;2.jpg&quot;</span>)</span><br><span class="line">x = cv.Sobel(img, cv.CV_16S, <span class="number">1</span>, <span class="number">0</span>) <span class="comment">#对x 求一阶导</span></span><br><span class="line">y = cv.Sobel(img, cv.CV_16S, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">#对y 求一阶导</span></span><br><span class="line">absX = cv.convertScaleAbs(x) <span class="comment">#对x 取绝对值，并将图像转换为8 位图</span></span><br><span class="line">absY = cv.convertScaleAbs(y) <span class="comment">#对y 取绝对值，并将图像转换为8 位图</span></span><br><span class="line">Sobel = cv.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&quot;qq&quot;</span>,Sobel)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="实验三-形态学图像处理实验">实验三 形态学图像处理实验</h2><h3 id="一实验目的-2">一、实验目的</h3><p>1 使用形态学滤波对图像进行腐蚀、膨胀运算</p><p>2 使用形态学滤波对图像进行开闭运算</p><p>3 利用 opencv python 对图像进行形态学运算</p><h3 id="二实验主要仪器设备-1">二、实验主要仪器设备</h3><p>(1)计算机</p><p>(2)python 软件</p><p>(3)典型的灰度、彩色图像文件 。</p><h3 id="三实验原理-1">三、实验原理</h3><p>数学形态学是以形态结构元素为基础对图像进行分析的数学工具。它的基本思想是用具有一定形态的结构元素去度量和提取图像中的对应形状以达到对图像分析和识别的目的。数学形态学的应用可以简化图像数据，保持它们基本的形状特征，并除去不相干的结构。数学形态学的基本运算有4个：膨胀、腐蚀、开启和闭合。它们在二值图像中和灰度图像中各有特点。基于这些基本运算还可以推导和组合成各种数学形态学实用算法。</p><p>基本的形态运算是腐蚀和膨胀。</p><p>在形态学中，结构元素是最重要最基本的概念。结构元素在形态变换中的作用相当于信号处理中的滤波窗口 。用<spanclass="math inline">\(B(x)\)</span>代表结构元素，对工作空间<spanclass="math inline">\(E\)</span>中的每一点<spanclass="math inline">\(x\)</span> ，腐蚀和膨胀的定义为：</p><p>腐蚀<span class="math inline">\(X=E⊙B(x)\)</span>;</p><p>膨胀<span class="math inline">\(Y=E⊗B(y)\)</span>。</p><p>用<span class="math inline">\(B(x)\)</span> 对 <spanclass="math inline">\(E\)</span>进行膨胀的结果就是把结构元素 B 平移后使B 与 E的交集非空的点构成的集合。先腐蚀后膨胀的过程称为开运算。它具有消除细小物体，在纤细处分离物体和平滑较大物体边界的作用。先膨胀后腐蚀的过程称为闭运算。它具有填充物体内细小空洞，连接邻近物体和平滑边界的作用。</p><p>可见，二值形态膨胀与腐蚀可转化为集合的逻辑运算，算法简单，适于并行处理，且易于硬件实现，适于对二值图像进行图像分割、细化、抽取骨架、边缘提取、形状分析。但是，在不同的应用场合，结构元素的选择及其相应的处理算法是不一样的，对不同的目标图像需设计不同的结构元素和不同的处理算法。结构元素的大小、形状选择合适与否，将直接影响图像的形态运算结果。因此，很多学者结合自己的应用实际，提出了一系列的改进算法。如梁勇提出的用多方位形态学结构元素进行边缘检测算法既具有较好的边缘定位能力，又具有很好的噪声平滑能力。许超提出的以最短线段结构元素构造准圆结构元素或序列结构元素生成准圆结构元素相结合的设计方法，用于骨架的提取，可大大减少形态运算的计算量，并可同时满足尺度、平移及旋转相容性，适于对形状进行分析和描述。</p><h3 id="四实验内容-1">四、实验内容</h3><p>(1)对原始图像进行灰度化、二值化处理</p><p>(2)对所得二值图像进行腐蚀运算；</p><p>(3)对二值图像进行膨胀运算；</p><p>(4)对二值图像进行开运算；</p><p>(5)对二值图像进行闭运算。</p><h3 id="五实验报告要求-1">五、实验报告要求</h3><p>(1)说明对图像进行形态学运算的理论方法</p><p>(2)列出上述图像处理程序</p><p>(3)记录结果图像</p><p>(4)心得和体会 。</p><h3 id="六预习要求-1">六、预习要求</h3><p>(1)了解图像形态学运算的方法</p><p>(2)列出上述图像处理方法的流程 。</p><h3 id="七实验">七、实验</h3><h4 id="腐蚀">1 腐蚀</h4><p>腐蚀主要就是调用cv2.erode(img,kernel,iterations) 其中 第一个参数：img指需要腐蚀的图 第二个参数： kernel 指腐蚀操作的内核，默认是一个简单的3X3矩阵 第三个参数： iterations 指的是腐蚀次数，省略是默认为 1 。</p><p>使用3 X 3 的卷积核，对二值图进行腐蚀操作的示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&quot;./image-20220425233418464.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">erosion = cv2.erode(img,kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;eroded image&#x27;</span>,erosion)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220425233418464-16512159850291.png"alt="image-20220425233418464" /><figcaption aria-hidden="true">image-20220425233418464</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">原图像</center><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429150527979.png"alt="image-20220429150527979" /><figcaption aria-hidden="true">image-20220429150527979</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">腐蚀图像</center><h4 id="膨胀">2 膨胀</h4><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&quot;./image-20220425233418464.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">erosion = cv2.erode(img,kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;eroded image&#x27;</span>,erosion)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">dilation = cv2.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dilation&#x27;</span>,dilation)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429150806658.png"alt="image-20220429150806658" /><figcaption aria-hidden="true">image-20220429150806658</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">膨胀图像</center><h4 id="开运算">3 开运算</h4><p>openvc 中 morphologyEx() 函数是一种形态学变化函数。开运算是调用cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)其中第一个参数： img 指需要开运算 的图 ；第二个参数 指的是开运算；第三个参数 kernel 指开运算的内核 。</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&quot;./image-20220425233418464.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">erosion = cv2.erode(img,kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;eroded image&#x27;</span>,erosion)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">dilation = cv2.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dilation&#x27;</span>,dilation)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">aaa=cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;aaa&#x27;</span>,aaa)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429150953882.png"alt="image-20220429150953882" /><figcaption aria-hidden="true">image-20220429150953882</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">开运算</center><h4 id="闭运算">4 闭运算</h4><p>闭运算：先 膨胀再腐蚀</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&quot;./image-20220425233418464.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">erosion = cv2.erode(img,kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;eroded image&#x27;</span>,erosion)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">dilation = cv2.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dilation&#x27;</span>,dilation)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">aaa=cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;aaa&#x27;</span>,aaa)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;closing&#x27;</span>,closing)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429151141909.png"alt="image-20220429151141909" /><figcaption aria-hidden="true">image-20220429151141909</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">闭运算</center><h2 id="实验四-数字图像的边缘检测实验">实验四数字图像的边缘检测实验</h2><h3 id="一实验目的-3">一、实验目的</h3><p>1、掌握数字图像的空间域滤波原理</p><p>2、掌握数字图像的边缘检测原理及常用的边缘检测算子</p><p>3、掌握阈值分割及图像的二值化 。</p><h3 id="二实验主要仪器设备-2">二、实验主要仪器设备</h3><p>(1)计算机</p><p>(2)python 软件</p><p>(3)典型的灰度、彩色图像文件 。</p><h3 id="三实验原理-2">三、实验原理</h3><p>（1）图像空间滤波原理：空间滤波是一种采用滤波处理的影像增强方法。其理论基础是空间卷积和空间相关。目的是改善影像质量，包括去除高频噪声与干扰，及影像边缘增强、线性增强以及去模糊等。分为低通滤波（平滑化）、 高通滤波 （锐化）和带通滤波 。</p><p>（2）边缘检测原理：边缘检测是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。这些包括</p><p>（ i ）深度上的不连续、</p><p>（ ii ）表面方向不连续、</p><p>（iii ）物质属性变化和 iv场景照明变化。</p><p>边缘检测是图像处理和计算机视觉中，尤其是特征提取中的一个研究领域。</p><h3 id="四实验内容-2">四、实验内容</h3><p>（1） 读取图像</p><p>（2）使用 opencv python 对六种边缘检测器 进行图片边缘检测并对三种算子得出的结果进行比较 。</p><h3 id="五实验报告要求-2">五、实验报告要求</h3><p>(1)熟悉边缘检测的原理</p><p>(2)列出实验程序及结果，并比较各边缘提取算子的特点</p><p>(3)写出心得、体会 。</p><h3 id="六预习要求-2">六、预习要求</h3><p>（1）了解边缘检测原理</p><p>（2）熟悉边缘检测程序流程</p><h3 id="七实验-1">七、实验</h3><h4 id="log-检测器">1 LoG 检测器</h4><p>实现LOG 算法要对图像先进行高斯滤波降噪处理，然后通过Laplacian算法进行轮廓提取。</p><p>OpenCV 官方将Laplacian算法封装到cv2.Laplacian()函数中，函数原型：result=cv2.Laplacian(img,ddepth, ksize)</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429152200932.png"alt="image-20220429152200932" /><figcaption aria-hidden="true">image-20220429152200932</figcaption></figure><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&quot;./2.jpg&quot;</span>,<span class="number">0</span>)</span><br><span class="line">blur=cv2.GaussianBlur(img,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">1</span>,<span class="number">1</span>)<span class="comment">#核尺寸通过对图像的调节自行定义</span></span><br><span class="line"><span class="comment">#调用Laplacian 算法的OpenCV 库函数进行图像轮廓提取</span></span><br><span class="line">result = cv2.Laplacian(blur,cv2.CV_16S,ksize=<span class="number">1</span>)</span><br><span class="line">LOG = cv2.convertScaleAbs(result)<span class="comment">#得到LOG 算法处理结果</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;LOG&#x27;</span>,LOG)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/2.jpg"alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">原图像</center><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429152322448.png"alt="image-20220429152322448" /><figcaption aria-hidden="true">image-20220429152322448</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">处理后的图像</center><h4 id="scharr-算子">2 Scharr 算子</h4><p>Scharr 算子又称为Scharr 滤波器，也是计算x 或y方向上的图像差分，在OpenCV 中主要是配合Sobel 算子的运算而存在的。scharr算子的卷积模板如下所示：</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429152453296.png"alt="image-20220429152453296" /><figcaption aria-hidden="true">image-20220429152453296</figcaption></figure><p>OpenCV 官方给出了明确的Scharr算法的库函数，函数原型：result=cv2.Scharr(img, ddepth, dx, dy)</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429152513998.png"alt="image-20220429152513998" /><figcaption aria-hidden="true">image-20220429152513998</figcaption></figure><p>Scharr 算子的代码基本实现类似于Sobel 算子。</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&quot;./2.jpg&quot;</span>,<span class="number">0</span>)</span><br><span class="line">scharrx = cv2.Scharr(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">scharrx = cv2.convertScaleAbs(scharrx)   <span class="comment"># 转回uint8</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;original&quot;</span>,img)</span><br><span class="line">cv2.imshow(<span class="string">&quot;x&quot;</span>,scharrx)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429152819337.png"alt="image-20220429152819337" /><figcaption aria-hidden="true">image-20220429152819337</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">原图像</center><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429152832650.png"alt="image-20220429152832650" /><figcaption aria-hidden="true">image-20220429152832650</figcaption></figure><center style="color=#C0C0C0;text-decoration:underline">处理后的图像</center><h4 id="canny-边缘检测器">3 Canny 边缘检测器</h4><p>Canny 边缘检测器是函数edge 中最强大的边缘检测器。方法总结如下：</p><p>1.使用具有指定标准差δ 的一个高斯滤波器来平滑图像，以减少噪声。</p><p>2.在每个点处计算局部梯度<spanclass="math inline">\([g^2_x+g^1_y]^{1/2}\)</span>和边缘方向<spanclass="math inline">\(arctan(g_x/g_y)\)</span>。边缘点定义为梯度方向强度局部最大的点。</p><p>3.步骤2中确定的边缘点产生梯度中的脊线。然后，算法沿这些脊线的顶部进行追踪，并将实际上不在脊线顶部的像素设置为零，从而在输出中给出一条细线，该过程称为非最大值抑制。然后使用称为滞后阈值处理的方法来对这些脊线像素进行阈值处理，这一处理方法使用两个阈值<spanclass="math inline">\(T_1\)</span>和<spanclass="math inline">\(T_2\)</span>其中<spanclass="math inline">\(T_1&lt;T_2\)</span>。其值大于<spanclass="math inline">\(T_2\)</span>的脊线像素称为“强”边缘像素，值在<spanclass="math inline">\(T_1\)</span> 和<spanclass="math inline">\(T_2\)</span>之间的脊线像素称为“弱”边缘像素。</p><p>在OpenCV 中，Canny()库函数原型为：</p><p>Canny = cv2.Canny(img, threshold1, threshold2, apertureSize)</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429153414623.png"alt="image-20220429153414623" /><figcaption aria-hidden="true">image-20220429153414623</figcaption></figure><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  <span class="comment"># opencv读取的格式是BGR</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  <span class="comment"># Matplotlib是RGB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读图</span></span><br><span class="line">img = cv2.imread(<span class="string">&quot;2.jpg&quot;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用Canny并调参，前者minval，后者maxval</span></span><br><span class="line">v1 = cv2.Canny(img, <span class="number">80</span>, <span class="number">150</span>)</span><br><span class="line">v2 = cv2.Canny(img, <span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比</span></span><br><span class="line">res = np.hstack((img, v1, v2))</span><br><span class="line">cv2.imshow(<span class="string">&quot;res&quot;</span>,res)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220429153655043.png"alt="image-20220429153655043" /><figcaption aria-hidden="true">image-20220429153655043</figcaption></figure><h2 id="实验五-基于图像分割的车牌定位识别">实验五基于图像分割的车牌定位识别</h2><h3 id="一实验目的-4">一、实验目的</h3><p>1.掌握车牌阈值分割；</p><p>2.掌握基于形态学计算的图像分割；</p><p>3.掌握图像的二值化；</p><p>4.掌握基于像素投影的字符分割；</p><p>5.掌握字符识别原理。</p><h3 id="二实验主要仪器设备-3">二、实验主要仪器设备</h3><p>(1)计算机；</p><p>(2)python 3.x</p><p>(3)需进行车牌识别的图片。</p><h3 id="三实验原理-3">三、实验原理</h3><p>（1）图像灰度化</p><p>灰度数字图像是每个像素只有一个采样颜色的图像。这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑白两种颜色，灰度图像在黑色与白色之间还有许多级的颜色深度。</p><p>（2）图像二值化</p><p>图像二值化就是将图像上的像素点的灰度值设置为 0或255，也就是将整个图像呈现出明显的黑白效果。</p><p>（3）图像形态学运算</p><p>(见实验三 )</p><p>（4）阈值分割原理</p><p>阈值分割算法是图形分割中应用场景最多的算法之一。简单地说，对灰度图像进行阈值分割就是先确定一个处于图像灰度取值范围内的阈值，然后将图像中各个像素的灰度值与这个阈值比较，并根据比较的结果将对应的像素划分为两类：像素灰度大于阈值的一类和像素值小于阈值的另一类，灰度值等于阈值的像素可以归入这两类之一。分割后的两类像素一般分属图像的两个不同区域，所以对像素根据阈值分类达到了区域分割的目的。</p><p>（5）字符分割原理</p><p>二值化后的图像 ,在没有字符的区域， y方向上像素灰度和为0，在有字符的区域为灰度和非 0。</p><h3 id="四实验内容-3">四、实验内容</h3><p>（1）定位车牌区域 (可基于灰度阈值或形态学运算等</p><p>（2）车牌图像预处理 (灰度化、二值化</p><p>（3）字符分割 (可基于灰度垂直投影等</p><p>（4）字符识别 (可使用模版匹配等方法 )</p><h3 id="五实验报告">五、实验报告</h3><p>（1）说明车牌区域识别、车牌图像预处理、字符分割和识别的原理</p><p>（2）列出实验程序</p><p>（3）记录实验过程中每一步的图像</p><p>（4）心得和体会。</p><h3 id="六预习要求-3">六、预习要求</h3><p>（1）总结和掌握车牌识别的基本流程和常见方法</p><p>（2）熟悉 opencv图像基本处理的相关函数。</p><h3 id="七实验-2">七、实验</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> norm</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">SZ = <span class="number">20</span>  <span class="comment"># 训练图片长宽</span></span><br><span class="line">MAX_WIDTH = <span class="number">1000</span>  <span class="comment"># 原始图片最大宽度</span></span><br><span class="line">Min_Area = <span class="number">2000</span>  <span class="comment"># 车牌区域允许最大面积</span></span><br><span class="line">PROVINCE_START = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imreadex</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">return</span> cv2.imdecode(np.fromfile(filename, dtype=np.uint8), cv2.IMREAD_COLOR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">point_limit</span>(<span class="params">point</span>):</span><br><span class="line">    <span class="keyword">if</span> point[<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        point[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> point[<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        point[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据设定的阈值和图片直方图，找出波峰，用于分隔字符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_waves</span>(<span class="params">threshold, histogram</span>):</span><br><span class="line">    up_point = -<span class="number">1</span>  <span class="comment"># 上升点</span></span><br><span class="line">    is_peak = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> histogram[<span class="number">0</span>] &gt; threshold:</span><br><span class="line">        up_point = <span class="number">0</span></span><br><span class="line">        is_peak = <span class="literal">True</span></span><br><span class="line">    wave_peaks = []</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(histogram):</span><br><span class="line">        <span class="keyword">if</span> is_peak <span class="keyword">and</span> x &lt; threshold:</span><br><span class="line">            <span class="keyword">if</span> i - up_point &gt; <span class="number">2</span>:</span><br><span class="line">                is_peak = <span class="literal">False</span></span><br><span class="line">                wave_peaks.append((up_point, i))</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> is_peak <span class="keyword">and</span> x &gt;= threshold:</span><br><span class="line">            is_peak = <span class="literal">True</span></span><br><span class="line">            up_point = i</span><br><span class="line">    <span class="keyword">if</span> is_peak <span class="keyword">and</span> up_point != -<span class="number">1</span> <span class="keyword">and</span> i - up_point &gt; <span class="number">4</span>:</span><br><span class="line">        wave_peaks.append((up_point, i))</span><br><span class="line">    <span class="keyword">return</span> wave_peaks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据找出的波峰，分隔图片，从而得到逐个字符图片</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">seperate_card</span>(<span class="params">img, waves</span>):</span><br><span class="line">    part_cards = []</span><br><span class="line">    <span class="keyword">for</span> wave <span class="keyword">in</span> waves:</span><br><span class="line">        part_cards.append(img[:, wave[<span class="number">0</span>]:wave[<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">return</span> part_cards</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 来自opencv的sample，用于svm训练</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deskew</span>(<span class="params">img</span>):</span><br><span class="line">    m = cv2.moments(img)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(m[<span class="string">&#x27;mu02&#x27;</span>]) &lt; <span class="number">1e-2</span>:</span><br><span class="line">        <span class="keyword">return</span> img.copy()</span><br><span class="line">    skew = m[<span class="string">&#x27;mu11&#x27;</span>] / m[<span class="string">&#x27;mu02&#x27;</span>]</span><br><span class="line">    M = np.float32([[<span class="number">1</span>, skew, -<span class="number">0.5</span> * SZ * skew], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    img = cv2.warpAffine(img, M, (SZ, SZ), flags=cv2.WARP_INVERSE_MAP | cv2.INTER_LINEAR)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 来自opencv的sample，用于svm训练</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_hog</span>(<span class="params">digits</span>):</span><br><span class="line">    samples = []</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> digits:</span><br><span class="line">        gx = cv2.Sobel(img, cv2.CV_32F, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        gy = cv2.Sobel(img, cv2.CV_32F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        mag, ang = cv2.cartToPolar(gx, gy)</span><br><span class="line">        bin_n = <span class="number">16</span></span><br><span class="line">        <span class="built_in">bin</span> = np.int32(bin_n * ang / (<span class="number">2</span> * np.pi))</span><br><span class="line">        bin_cells = <span class="built_in">bin</span>[:<span class="number">10</span>, :<span class="number">10</span>], <span class="built_in">bin</span>[<span class="number">10</span>:, :<span class="number">10</span>], <span class="built_in">bin</span>[:<span class="number">10</span>, <span class="number">10</span>:], <span class="built_in">bin</span>[<span class="number">10</span>:, <span class="number">10</span>:]</span><br><span class="line">        mag_cells = mag[:<span class="number">10</span>, :<span class="number">10</span>], mag[<span class="number">10</span>:, :<span class="number">10</span>], mag[:<span class="number">10</span>, <span class="number">10</span>:], mag[<span class="number">10</span>:, <span class="number">10</span>:]</span><br><span class="line">        hists = [np.bincount(b.ravel(), m.ravel(), bin_n) <span class="keyword">for</span> b, m <span class="keyword">in</span> <span class="built_in">zip</span>(bin_cells, mag_cells)]</span><br><span class="line">        hist = np.hstack(hists)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># transform to Hellinger kernel</span></span><br><span class="line">        eps = <span class="number">1e-7</span></span><br><span class="line">        hist /= hist.<span class="built_in">sum</span>() + eps</span><br><span class="line">        hist = np.sqrt(hist)</span><br><span class="line">        hist /= norm(hist) + eps</span><br><span class="line"></span><br><span class="line">        samples.append(hist)</span><br><span class="line">    <span class="keyword">return</span> np.float32(samples)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能保证包括所有省份</span></span><br><span class="line">provinces = [</span><br><span class="line">    <span class="string">&quot;zh_cuan&quot;</span>, <span class="string">&quot;川&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_e&quot;</span>, <span class="string">&quot;鄂&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_gan&quot;</span>, <span class="string">&quot;赣&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_gan1&quot;</span>, <span class="string">&quot;甘&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_gui&quot;</span>, <span class="string">&quot;贵&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_gui1&quot;</span>, <span class="string">&quot;桂&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_hei&quot;</span>, <span class="string">&quot;黑&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_hu&quot;</span>, <span class="string">&quot;沪&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_ji&quot;</span>, <span class="string">&quot;冀&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_jin&quot;</span>, <span class="string">&quot;津&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_jing&quot;</span>, <span class="string">&quot;京&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_jl&quot;</span>, <span class="string">&quot;吉&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_liao&quot;</span>, <span class="string">&quot;辽&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_lu&quot;</span>, <span class="string">&quot;鲁&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_meng&quot;</span>, <span class="string">&quot;蒙&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_min&quot;</span>, <span class="string">&quot;闽&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_ning&quot;</span>, <span class="string">&quot;宁&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_qing&quot;</span>, <span class="string">&quot;靑&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_qiong&quot;</span>, <span class="string">&quot;琼&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_shan&quot;</span>, <span class="string">&quot;陕&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_su&quot;</span>, <span class="string">&quot;苏&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_sx&quot;</span>, <span class="string">&quot;晋&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_wan&quot;</span>, <span class="string">&quot;皖&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_xiang&quot;</span>, <span class="string">&quot;湘&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_xin&quot;</span>, <span class="string">&quot;新&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_yu&quot;</span>, <span class="string">&quot;豫&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_yu1&quot;</span>, <span class="string">&quot;渝&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_yue&quot;</span>, <span class="string">&quot;粤&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_yun&quot;</span>, <span class="string">&quot;云&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_zang&quot;</span>, <span class="string">&quot;藏&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zh_zhe&quot;</span>, <span class="string">&quot;浙&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StatModel</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, fn</span>):</span><br><span class="line">        self.model = self.model.load(fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self, fn</span>):</span><br><span class="line">        self.model.save(fn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SVM</span>(<span class="title class_ inherited__">StatModel</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, C=<span class="number">1</span>, gamma=<span class="number">0.5</span></span>):</span><br><span class="line">        self.model = cv2.ml.SVM_create()</span><br><span class="line">        self.model.setGamma(gamma)</span><br><span class="line">        self.model.setC(C)</span><br><span class="line">        self.model.setKernel(cv2.ml.SVM_RBF)</span><br><span class="line">        self.model.setType(cv2.ml.SVM_C_SVC)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练svm</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, samples, responses</span>):</span><br><span class="line">        self.model.train(samples, cv2.ml.ROW_SAMPLE, responses)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 字符识别</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, samples</span>):</span><br><span class="line">        r = self.model.predict(samples)</span><br><span class="line">        <span class="keyword">return</span> r[<span class="number">1</span>].ravel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CardPredictor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 车牌识别的部分参数保存在js中，便于根据图片分辨率做调整</span></span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&#x27;./data/config.js&#x27;</span>)</span><br><span class="line">        j = json.load(f)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> j[<span class="string">&quot;config&quot;</span>]:</span><br><span class="line">            <span class="keyword">if</span> c[<span class="string">&quot;open&quot;</span>]:</span><br><span class="line">                self.cfg = c.copy()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;没有设置有效配置参数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        self.save_traindata()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train_svm</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 识别英文字母和数字</span></span><br><span class="line">        self.model = SVM(C=<span class="number">1</span>, gamma=<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># 识别中文</span></span><br><span class="line">        self.modelchinese = SVM(C=<span class="number">1</span>, gamma=<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(<span class="string">&quot;./data/svm.dat&quot;</span>):</span><br><span class="line">            self.model.load(<span class="string">&quot;./data/svm.dat&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            chars_train = []</span><br><span class="line">            chars_label = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">&quot;train\\chars2&quot;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(os.path.basename(root)) &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                root_int = <span class="built_in">ord</span>(os.path.basename(root))</span><br><span class="line">                <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">                    filepath = os.path.join(root, filename)</span><br><span class="line">                    digit_img = cv2.imread(filepath)</span><br><span class="line">                    digit_img = cv2.cvtColor(digit_img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">                    chars_train.append(digit_img)</span><br><span class="line">                    <span class="comment"># chars_label.append(1)</span></span><br><span class="line">                    chars_label.append(root_int)</span><br><span class="line"></span><br><span class="line">            chars_train = <span class="built_in">list</span>(<span class="built_in">map</span>(deskew, chars_train))</span><br><span class="line">            chars_train = preprocess_hog(chars_train)</span><br><span class="line">            <span class="comment"># chars_train = chars_train.reshape(-1, 20, 20).astype(np.float32)</span></span><br><span class="line">            chars_label = np.array(chars_label)</span><br><span class="line">            <span class="built_in">print</span>(chars_train.shape)</span><br><span class="line">            self.model.train(chars_train, chars_label)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(<span class="string">&quot;./data/svmchinese.dat&quot;</span>):</span><br><span class="line">            self.modelchinese.load(<span class="string">&quot;./data/svmchinese.dat&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            chars_train = []</span><br><span class="line">            chars_label = []</span><br><span class="line">            <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">&quot;train\\charsChinese&quot;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.basename(root).startswith(<span class="string">&quot;zh_&quot;</span>):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                pinyin = os.path.basename(root)</span><br><span class="line">                index = provinces.index(pinyin) + PROVINCE_START + <span class="number">1</span>  <span class="comment"># 1是拼音对应的汉字</span></span><br><span class="line">                <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">                    filepath = os.path.join(root, filename)</span><br><span class="line">                    digit_img = cv2.imread(filepath)</span><br><span class="line">                    digit_img = cv2.cvtColor(digit_img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">                    chars_train.append(digit_img)</span><br><span class="line">                    <span class="comment"># chars_label.append(1)</span></span><br><span class="line">                    chars_label.append(index)</span><br><span class="line">            chars_train = <span class="built_in">list</span>(<span class="built_in">map</span>(deskew, chars_train))</span><br><span class="line">            chars_train = preprocess_hog(chars_train)</span><br><span class="line">            <span class="comment"># chars_train = chars_train.reshape(-1, 20, 20).astype(np.float32)</span></span><br><span class="line">            chars_label = np.array(chars_label)</span><br><span class="line">            <span class="built_in">print</span>(chars_train.shape)</span><br><span class="line">            self.modelchinese.train(chars_train, chars_label)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_traindata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;./data/svm.dat&quot;</span>):</span><br><span class="line">            self.model.save(<span class="string">&quot;./data/svm.dat&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;./data/svmchinese.dat&quot;</span>):</span><br><span class="line">            self.modelchinese.save(<span class="string">&quot;./data/svmchinese.dat&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accurate_place</span>(<span class="params">self, card_img_hsv, limit1, limit2, color</span>):</span><br><span class="line">        row_num, col_num = card_img_hsv.shape[:<span class="number">2</span>]</span><br><span class="line">        xl = col_num</span><br><span class="line">        xr = <span class="number">0</span></span><br><span class="line">        yh = <span class="number">0</span></span><br><span class="line">        yl = row_num</span><br><span class="line">        <span class="comment"># col_num_limit = self.cfg[&quot;col_num_limit&quot;]</span></span><br><span class="line">        row_num_limit = self.cfg[<span class="string">&quot;row_num_limit&quot;</span>]</span><br><span class="line">        col_num_limit = col_num * <span class="number">0.8</span> <span class="keyword">if</span> color != <span class="string">&quot;green&quot;</span> <span class="keyword">else</span> col_num * <span class="number">0.5</span>  <span class="comment"># 绿色有渐变</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row_num):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col_num):</span><br><span class="line">                H = card_img_hsv.item(i, j, <span class="number">0</span>)</span><br><span class="line">                S = card_img_hsv.item(i, j, <span class="number">1</span>)</span><br><span class="line">                V = card_img_hsv.item(i, j, <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> limit1 &lt; H &lt;= limit2 <span class="keyword">and</span> <span class="number">34</span> &lt; S <span class="keyword">and</span> <span class="number">46</span> &lt; V:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; col_num_limit:</span><br><span class="line">                <span class="keyword">if</span> yl &gt; i:</span><br><span class="line">                    yl = i</span><br><span class="line">                <span class="keyword">if</span> yh &lt; i:</span><br><span class="line">                    yh = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col_num):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row_num):</span><br><span class="line">                H = card_img_hsv.item(i, j, <span class="number">0</span>)</span><br><span class="line">                S = card_img_hsv.item(i, j, <span class="number">1</span>)</span><br><span class="line">                V = card_img_hsv.item(i, j, <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> limit1 &lt; H &lt;= limit2 <span class="keyword">and</span> <span class="number">34</span> &lt; S <span class="keyword">and</span> <span class="number">46</span> &lt; V:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; row_num - row_num_limit:</span><br><span class="line">                <span class="keyword">if</span> xl &gt; j:</span><br><span class="line">                    xl = j</span><br><span class="line">                <span class="keyword">if</span> xr &lt; j:</span><br><span class="line">                    xr = j</span><br><span class="line">        <span class="keyword">return</span> xl, xr, yh, yl</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, car_pic</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(car_pic) == <span class="built_in">type</span>(<span class="string">&quot;&quot;</span>):</span><br><span class="line">            img = imreadex(car_pic)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img = car_pic</span><br><span class="line">        pic_hight, pic_width = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pic_width &gt; MAX_WIDTH:</span><br><span class="line">            resize_rate = MAX_WIDTH / pic_width</span><br><span class="line">            img = cv2.resize(img, (MAX_WIDTH, <span class="built_in">int</span>(pic_hight * resize_rate)), interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">        blur = self.cfg[<span class="string">&quot;blur&quot;</span>]</span><br><span class="line">        <span class="comment"># 高斯去噪</span></span><br><span class="line">        <span class="keyword">if</span> blur &gt; <span class="number">0</span>:</span><br><span class="line">            img = cv2.GaussianBlur(img, (blur, blur), <span class="number">0</span>)  <span class="comment"># 图片分辨率调整</span></span><br><span class="line">        oldimg = img</span><br><span class="line">        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="comment"># equ = cv2.equalizeHist(img)</span></span><br><span class="line">        <span class="comment"># img = np.hstack((img, equ))</span></span><br><span class="line">        <span class="comment"># 去掉图像中不会是车牌的区域</span></span><br><span class="line">        kernel = np.ones((<span class="number">20</span>, <span class="number">20</span>), np.uint8)</span><br><span class="line">        img_opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)</span><br><span class="line">        img_opening = cv2.addWeighted(img, <span class="number">1</span>, img_opening, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到图像边缘</span></span><br><span class="line">        ret, img_thresh = cv2.threshold(img_opening, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">        img_edge = cv2.Canny(img_thresh, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">        <span class="comment"># 使用开运算和闭运算让图像边缘成为一个整体</span></span><br><span class="line">        kernel = np.ones((self.cfg[<span class="string">&quot;morphologyr&quot;</span>], self.cfg[<span class="string">&quot;morphologyc&quot;</span>]), np.uint8)</span><br><span class="line">        img_edge1 = cv2.morphologyEx(img_edge, cv2.MORPH_CLOSE, kernel)</span><br><span class="line">        img_edge2 = cv2.morphologyEx(img_edge1, cv2.MORPH_OPEN, kernel)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查找图像边缘整体形成的矩形区域，可能有很多，车牌就在其中一个矩形区域中</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            contours, hierarchy = cv2.findContours(img_edge2, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            image, contours, hierarchy = cv2.findContours(img_edge2, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">        contours = [cnt <span class="keyword">for</span> cnt <span class="keyword">in</span> contours <span class="keyword">if</span> cv2.contourArea(cnt) &gt; Min_Area]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;len(contours)&#x27;</span>, <span class="built_in">len</span>(contours))</span><br><span class="line">        <span class="comment"># 一一排除不是车牌的矩形区域</span></span><br><span class="line">        car_contours = []</span><br><span class="line">        <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:</span><br><span class="line">            rect = cv2.minAreaRect(cnt)</span><br><span class="line">            area_width, area_height = rect[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> area_width &lt; area_height:</span><br><span class="line">                area_width, area_height = area_height, area_width</span><br><span class="line">            wh_ratio = area_width / area_height</span><br><span class="line">            <span class="comment"># print(wh_ratio)</span></span><br><span class="line">            <span class="comment"># 要求矩形区域长宽比在2到5.5之间，2到5.5是车牌的长宽比，其余的矩形排除</span></span><br><span class="line">            <span class="keyword">if</span> wh_ratio &gt; <span class="number">2</span> <span class="keyword">and</span> wh_ratio &lt; <span class="number">5.5</span>:</span><br><span class="line">                car_contours.append(rect)</span><br><span class="line">                box = cv2.boxPoints(rect)</span><br><span class="line">                box = np.int0(box)</span><br><span class="line">        <span class="comment"># oldimg = cv2.drawContours(oldimg, [box], 0, (0, 0, 255), 2)</span></span><br><span class="line">        <span class="comment"># cv2.imshow(&quot;edge4&quot;, oldimg)</span></span><br><span class="line">        <span class="comment"># print(rect)</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(car_contours))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;精确定位&quot;</span>)</span><br><span class="line">        card_imgs = []</span><br><span class="line">        <span class="comment"># 矩形区域可能是倾斜的矩形，需要矫正，以便使用颜色定位</span></span><br><span class="line">        <span class="keyword">for</span> rect <span class="keyword">in</span> car_contours:</span><br><span class="line">            <span class="keyword">if</span> rect[<span class="number">2</span>] &gt; -<span class="number">1</span> <span class="keyword">and</span> rect[<span class="number">2</span>] &lt; <span class="number">1</span>:  <span class="comment"># 创造角度，使得左、高、右、低拿到正确的值</span></span><br><span class="line">                angle = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                angle = rect[<span class="number">2</span>]</span><br><span class="line">            rect = (rect[<span class="number">0</span>], (rect[<span class="number">1</span>][<span class="number">0</span>] + <span class="number">5</span>, rect[<span class="number">1</span>][<span class="number">1</span>] + <span class="number">5</span>), angle)  <span class="comment"># 扩大范围，避免车牌边缘被排除</span></span><br><span class="line"></span><br><span class="line">            box = cv2.boxPoints(rect)</span><br><span class="line">            heigth_point = right_point = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            left_point = low_point = [pic_width, pic_hight]</span><br><span class="line">            <span class="keyword">for</span> point <span class="keyword">in</span> box:</span><br><span class="line">                <span class="keyword">if</span> left_point[<span class="number">0</span>] &gt; point[<span class="number">0</span>]:</span><br><span class="line">                    left_point = point</span><br><span class="line">                <span class="keyword">if</span> low_point[<span class="number">1</span>] &gt; point[<span class="number">1</span>]:</span><br><span class="line">                    low_point = point</span><br><span class="line">                <span class="keyword">if</span> heigth_point[<span class="number">1</span>] &lt; point[<span class="number">1</span>]:</span><br><span class="line">                    heigth_point = point</span><br><span class="line">                <span class="keyword">if</span> right_point[<span class="number">0</span>] &lt; point[<span class="number">0</span>]:</span><br><span class="line">                    right_point = point</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left_point[<span class="number">1</span>] &lt;= right_point[<span class="number">1</span>]:  <span class="comment"># 正角度</span></span><br><span class="line">                new_right_point = [right_point[<span class="number">0</span>], heigth_point[<span class="number">1</span>]]</span><br><span class="line">                pts2 = np.float32([left_point, heigth_point, new_right_point])  <span class="comment"># 字符只是高度需要改变</span></span><br><span class="line">                pts1 = np.float32([left_point, heigth_point, right_point])</span><br><span class="line">                M = cv2.getAffineTransform(pts1, pts2)</span><br><span class="line">                dst = cv2.warpAffine(oldimg, M, (pic_width, pic_hight))</span><br><span class="line">                point_limit(new_right_point)</span><br><span class="line">                point_limit(heigth_point)</span><br><span class="line">                point_limit(left_point)</span><br><span class="line">                card_img = dst[<span class="built_in">int</span>(left_point[<span class="number">1</span>]):<span class="built_in">int</span>(heigth_point[<span class="number">1</span>]), <span class="built_in">int</span>(left_point[<span class="number">0</span>]):<span class="built_in">int</span>(new_right_point[<span class="number">0</span>])]</span><br><span class="line">                card_imgs.append(card_img)</span><br><span class="line">            <span class="comment"># cv2.imshow(&quot;card&quot;, card_img)</span></span><br><span class="line">            <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">            <span class="keyword">elif</span> left_point[<span class="number">1</span>] &gt; right_point[<span class="number">1</span>]:  <span class="comment"># 负角度</span></span><br><span class="line"></span><br><span class="line">                new_left_point = [left_point[<span class="number">0</span>], heigth_point[<span class="number">1</span>]]</span><br><span class="line">                pts2 = np.float32([new_left_point, heigth_point, right_point])  <span class="comment"># 字符只是高度需要改变</span></span><br><span class="line">                pts1 = np.float32([left_point, heigth_point, right_point])</span><br><span class="line">                M = cv2.getAffineTransform(pts1, pts2)</span><br><span class="line">                dst = cv2.warpAffine(oldimg, M, (pic_width, pic_hight))</span><br><span class="line">                point_limit(right_point)</span><br><span class="line">                point_limit(heigth_point)</span><br><span class="line">                point_limit(new_left_point)</span><br><span class="line">                card_img = dst[<span class="built_in">int</span>(right_point[<span class="number">1</span>]):<span class="built_in">int</span>(heigth_point[<span class="number">1</span>]), <span class="built_in">int</span>(new_left_point[<span class="number">0</span>]):<span class="built_in">int</span>(right_point[<span class="number">0</span>])]</span><br><span class="line">                card_imgs.append(card_img)</span><br><span class="line">        <span class="comment"># cv2.imshow(&quot;card&quot;, card_img)</span></span><br><span class="line">        <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">        <span class="comment"># 开始使用颜色定位，排除不是车牌的矩形，目前只识别蓝、绿、黄车牌</span></span><br><span class="line">        colors = []</span><br><span class="line">        <span class="keyword">for</span> card_index, card_img <span class="keyword">in</span> <span class="built_in">enumerate</span>(card_imgs):</span><br><span class="line">            green = yello = blue = black = white = <span class="number">0</span></span><br><span class="line">            card_img_hsv = cv2.cvtColor(card_img, cv2.COLOR_BGR2HSV)</span><br><span class="line">            <span class="comment"># 有转换失败的可能，原因来自于上面矫正矩形出错</span></span><br><span class="line">            <span class="keyword">if</span> card_img_hsv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            row_num, col_num = card_img_hsv.shape[:<span class="number">2</span>]</span><br><span class="line">            card_img_count = row_num * col_num</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row_num):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col_num):</span><br><span class="line">                    H = card_img_hsv.item(i, j, <span class="number">0</span>)</span><br><span class="line">                    S = card_img_hsv.item(i, j, <span class="number">1</span>)</span><br><span class="line">                    V = card_img_hsv.item(i, j, <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">11</span> &lt; H &lt;= <span class="number">34</span> <span class="keyword">and</span> S &gt; <span class="number">34</span>:  <span class="comment"># 图片分辨率调整</span></span><br><span class="line">                        yello += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="number">35</span> &lt; H &lt;= <span class="number">99</span> <span class="keyword">and</span> S &gt; <span class="number">34</span>:  <span class="comment"># 图片分辨率调整</span></span><br><span class="line">                        green += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="number">99</span> &lt; H &lt;= <span class="number">124</span> <span class="keyword">and</span> S &gt; <span class="number">34</span>:  <span class="comment"># 图片分辨率调整</span></span><br><span class="line">                        blue += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt; H &lt; <span class="number">180</span> <span class="keyword">and</span> <span class="number">0</span> &lt; S &lt; <span class="number">255</span> <span class="keyword">and</span> <span class="number">0</span> &lt; V &lt; <span class="number">46</span>:</span><br><span class="line">                        black += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="number">0</span> &lt; H &lt; <span class="number">180</span> <span class="keyword">and</span> <span class="number">0</span> &lt; S &lt; <span class="number">43</span> <span class="keyword">and</span> <span class="number">221</span> &lt; V &lt; <span class="number">225</span>:</span><br><span class="line">                        white += <span class="number">1</span></span><br><span class="line">            color = <span class="string">&quot;no&quot;</span></span><br><span class="line"></span><br><span class="line">            limit1 = limit2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> yello * <span class="number">2</span> &gt;= card_img_count:</span><br><span class="line">                color = <span class="string">&quot;yello&quot;</span></span><br><span class="line">                limit1 = <span class="number">11</span></span><br><span class="line">                limit2 = <span class="number">34</span>  <span class="comment"># 有的图片有色偏偏绿</span></span><br><span class="line">            <span class="keyword">elif</span> green * <span class="number">2</span> &gt;= card_img_count:</span><br><span class="line">                color = <span class="string">&quot;green&quot;</span></span><br><span class="line">                limit1 = <span class="number">35</span></span><br><span class="line">                limit2 = <span class="number">99</span></span><br><span class="line">            <span class="keyword">elif</span> blue * <span class="number">2</span> &gt;= card_img_count:</span><br><span class="line">                color = <span class="string">&quot;blue&quot;</span></span><br><span class="line">                limit1 = <span class="number">100</span></span><br><span class="line">                limit2 = <span class="number">124</span>  <span class="comment"># 有的图片有色偏偏紫</span></span><br><span class="line">            <span class="keyword">elif</span> black + white &gt;= card_img_count * <span class="number">0.7</span>:  <span class="comment"># TODO</span></span><br><span class="line">                color = <span class="string">&quot;bw&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(color)</span><br><span class="line">            colors.append(color)</span><br><span class="line">            <span class="built_in">print</span>(blue, green, yello, black, white, card_img_count)</span><br><span class="line">            <span class="comment"># cv2.imshow(&quot;color&quot;, card_img)</span></span><br><span class="line">            <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">            <span class="keyword">if</span> limit1 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 以上为确定车牌颜色</span></span><br><span class="line">            <span class="comment"># 以下为根据车牌颜色再定位，缩小边缘非车牌边界</span></span><br><span class="line">            xl, xr, yh, yl = self.accurate_place(card_img_hsv, limit1, limit2, color)</span><br><span class="line">            <span class="keyword">if</span> yl == yh <span class="keyword">and</span> xl == xr:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            need_accurate = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> yl &gt;= yh:</span><br><span class="line">                yl = <span class="number">0</span></span><br><span class="line">                yh = row_num</span><br><span class="line">                need_accurate = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> xl &gt;= xr:</span><br><span class="line">                xl = <span class="number">0</span></span><br><span class="line">                xr = col_num</span><br><span class="line">                need_accurate = <span class="literal">True</span></span><br><span class="line">            card_imgs[card_index] = card_img[yl:yh, xl:xr] <span class="keyword">if</span> color != <span class="string">&quot;green&quot;</span> <span class="keyword">or</span> yl &lt; (yh - yl) // <span class="number">4</span> <span class="keyword">else</span> card_img[</span><br><span class="line">                                                                                                           yl - (</span><br><span class="line">                                                                                                                   yh - yl) // <span class="number">4</span>:yh,</span><br><span class="line">                                                                                                           xl:xr]</span><br><span class="line">            <span class="keyword">if</span> need_accurate:  <span class="comment"># 可能x或y方向未缩小，需要再试一次</span></span><br><span class="line">                card_img = card_imgs[card_index]</span><br><span class="line">                card_img_hsv = cv2.cvtColor(card_img, cv2.COLOR_BGR2HSV)</span><br><span class="line">                xl, xr, yh, yl = self.accurate_place(card_img_hsv, limit1, limit2, color)</span><br><span class="line">                <span class="keyword">if</span> yl == yh <span class="keyword">and</span> xl == xr:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> yl &gt;= yh:</span><br><span class="line">                    yl = <span class="number">0</span></span><br><span class="line">                    yh = row_num</span><br><span class="line">                <span class="keyword">if</span> xl &gt;= xr:</span><br><span class="line">                    xl = <span class="number">0</span></span><br><span class="line">                    xr = col_num</span><br><span class="line">            card_imgs[card_index] = card_img[yl:yh, xl:xr] <span class="keyword">if</span> color != <span class="string">&quot;green&quot;</span> <span class="keyword">or</span> yl &lt; (yh - yl) // <span class="number">4</span> <span class="keyword">else</span> card_img[</span><br><span class="line">                                                                                                           yl - (</span><br><span class="line">                                                                                                                   yh - yl) // <span class="number">4</span>:yh,</span><br><span class="line">                                                                                                           xl:xr]</span><br><span class="line">        <span class="comment"># 以上为车牌定位</span></span><br><span class="line">        <span class="comment"># 以下为识别车牌中的字符</span></span><br><span class="line">        predict_result = []</span><br><span class="line">        roi = <span class="literal">None</span></span><br><span class="line">        card_color = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i, color <span class="keyword">in</span> <span class="built_in">enumerate</span>(colors):</span><br><span class="line">            <span class="keyword">if</span> color <span class="keyword">in</span> (<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yello&quot;</span>, <span class="string">&quot;green&quot;</span>):</span><br><span class="line">                card_img = card_imgs[i]</span><br><span class="line">                gray_img = cv2.cvtColor(card_img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">                <span class="comment"># 黄、绿车牌字符比背景暗、与蓝车牌刚好相反，所以黄、绿车牌需要反向</span></span><br><span class="line">                <span class="keyword">if</span> color == <span class="string">&quot;green&quot;</span> <span class="keyword">or</span> color == <span class="string">&quot;yello&quot;</span>:</span><br><span class="line">                    gray_img = cv2.bitwise_not(gray_img)</span><br><span class="line">                ret, gray_img = cv2.threshold(gray_img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">                <span class="comment"># 查找水平直方图波峰</span></span><br><span class="line">                x_histogram = np.<span class="built_in">sum</span>(gray_img, axis=<span class="number">1</span>)</span><br><span class="line">                x_min = np.<span class="built_in">min</span>(x_histogram)</span><br><span class="line">                x_average = np.<span class="built_in">sum</span>(x_histogram) / x_histogram.shape[<span class="number">0</span>]</span><br><span class="line">                x_threshold = (x_min + x_average) / <span class="number">2</span></span><br><span class="line">                wave_peaks = find_waves(x_threshold, x_histogram)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(wave_peaks) == <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;peak less 0:&quot;</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 认为水平方向，最大的波峰为车牌区域</span></span><br><span class="line">                wave = <span class="built_in">max</span>(wave_peaks, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>] - x[<span class="number">0</span>])</span><br><span class="line">                gray_img = gray_img[wave[<span class="number">0</span>]:wave[<span class="number">1</span>]]</span><br><span class="line">                <span class="comment"># 查找垂直直方图波峰</span></span><br><span class="line">                row_num, col_num = gray_img.shape[:<span class="number">2</span>]</span><br><span class="line">                <span class="comment"># 去掉车牌上下边缘1个像素，避免白边影响阈值判断</span></span><br><span class="line">                gray_img = gray_img[<span class="number">1</span>:row_num - <span class="number">1</span>]</span><br><span class="line">                y_histogram = np.<span class="built_in">sum</span>(gray_img, axis=<span class="number">0</span>)</span><br><span class="line">                y_min = np.<span class="built_in">min</span>(y_histogram)</span><br><span class="line">                y_average = np.<span class="built_in">sum</span>(y_histogram) / y_histogram.shape[<span class="number">0</span>]</span><br><span class="line">                y_threshold = (y_min + y_average) / <span class="number">5</span>  <span class="comment"># U和0要求阈值偏小，否则U和0会被分成两半</span></span><br><span class="line"></span><br><span class="line">                wave_peaks = find_waves(y_threshold, y_histogram)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># for wave in wave_peaks:</span></span><br><span class="line">                <span class="comment">#  cv2.line(card_img, pt1=(wave[0], 5), pt2=(wave[1], 5), color=(0, 0, 255), thickness=2)</span></span><br><span class="line">                <span class="comment"># 车牌字符数应大于6</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(wave_peaks) &lt;= <span class="number">6</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;peak less 1:&quot;</span>, <span class="built_in">len</span>(wave_peaks))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                wave = <span class="built_in">max</span>(wave_peaks, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>] - x[<span class="number">0</span>])</span><br><span class="line">                max_wave_dis = wave[<span class="number">1</span>] - wave[<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># 判断是否是左侧车牌边缘</span></span><br><span class="line">                <span class="keyword">if</span> wave_peaks[<span class="number">0</span>][<span class="number">1</span>] - wave_peaks[<span class="number">0</span>][<span class="number">0</span>] &lt; max_wave_dis / <span class="number">3</span> <span class="keyword">and</span> wave_peaks[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                    wave_peaks.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 组合分离汉字</span></span><br><span class="line">                cur_dis = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i, wave <span class="keyword">in</span> <span class="built_in">enumerate</span>(wave_peaks):</span><br><span class="line">                    <span class="keyword">if</span> wave[<span class="number">1</span>] - wave[<span class="number">0</span>] + cur_dis &gt; max_wave_dis * <span class="number">0.6</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur_dis += wave[<span class="number">1</span>] - wave[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    wave = (wave_peaks[<span class="number">0</span>][<span class="number">0</span>], wave_peaks[i][<span class="number">1</span>])</span><br><span class="line">                    wave_peaks = wave_peaks[i + <span class="number">1</span>:]</span><br><span class="line">                    wave_peaks.insert(<span class="number">0</span>, wave)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 去除车牌上的分隔点</span></span><br><span class="line">                point = wave_peaks[<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">if</span> point[<span class="number">1</span>] - point[<span class="number">0</span>] &lt; max_wave_dis / <span class="number">3</span>:</span><br><span class="line">                    point_img = gray_img[:, point[<span class="number">0</span>]:point[<span class="number">1</span>]]</span><br><span class="line">                    <span class="keyword">if</span> np.mean(point_img) &lt; <span class="number">255</span> / <span class="number">5</span>:</span><br><span class="line">                        wave_peaks.pop(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(wave_peaks) &lt;= <span class="number">6</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;peak less 2:&quot;</span>, <span class="built_in">len</span>(wave_peaks))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                part_cards = seperate_card(gray_img, wave_peaks)</span><br><span class="line">                <span class="keyword">for</span> i, part_card <span class="keyword">in</span> <span class="built_in">enumerate</span>(part_cards):</span><br><span class="line">                    <span class="comment"># 可能是固定车牌的铆钉</span></span><br><span class="line">                    <span class="keyword">if</span> np.mean(part_card) &lt; <span class="number">255</span> / <span class="number">5</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;a point&quot;</span>)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    part_card_old = part_card</span><br><span class="line">                    w = <span class="built_in">abs</span>(part_card.shape[<span class="number">1</span>] - SZ) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                    part_card = cv2.copyMakeBorder(part_card, <span class="number">0</span>, <span class="number">0</span>, w, w, cv2.BORDER_CONSTANT, value=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">                    part_card = cv2.resize(part_card, (SZ, SZ), interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># part_card = deskew(part_card)</span></span><br><span class="line">                    part_card = preprocess_hog([part_card])</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                        resp = self.modelchinese.predict(part_card)</span><br><span class="line">                        charactor = provinces[<span class="built_in">int</span>(resp[<span class="number">0</span>]) - PROVINCE_START]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        resp = self.model.predict(part_card)</span><br><span class="line">                        charactor = <span class="built_in">chr</span>(resp[<span class="number">0</span>])</span><br><span class="line">                    <span class="comment"># 判断最后一个数是否是车牌边缘，假设车牌边缘被认为是1</span></span><br><span class="line">                    <span class="keyword">if</span> charactor == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> i == <span class="built_in">len</span>(part_cards) - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> part_card_old.shape[<span class="number">0</span>] / part_card_old.shape[<span class="number">1</span>] &gt;= <span class="number">7</span>:  <span class="comment"># 1太细，认为是边缘</span></span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                    predict_result.append(charactor)</span><br><span class="line">                roi = card_img</span><br><span class="line">                card_color = color</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> predict_result, roi, card_color  <span class="comment"># 识别到的字符、定位的车牌图像、车牌颜色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = CardPredictor()</span><br><span class="line">    c.train_svm()</span><br><span class="line">    r, roi, color = c.predict(<span class="string">&#x27;./1.jpg&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure><p>识别结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\ProgramData\Anaconda3\python.exe F:/Mirror/Learning/研一/数字图像处理/code/LicensePlaterecognize-master/predict.py</span><br><span class="line">len(contours) 5</span><br><span class="line">2</span><br><span class="line">精确定位</span><br><span class="line">blue</span><br><span class="line">3060 147 0 0 4 3213</span><br><span class="line">no</span><br><span class="line">645 292 75 83 2 12455</span><br><span class="line">[&#x27;鲁&#x27;, &#x27;R&#x27;, &#x27;R&#x27;, &#x27;Y&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;2&#x27;]</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/1-16513792792811.jpg"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理，opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于动态规划的多目标优化电梯智能群控算法</title>
      <link href="/2022/04/03/%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/03/%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2id="基于动态规划的多目标优化电梯智能群控算法">基于动态规划的多目标优化电梯智能群控算法</h2><span id="more"></span><h3 id="多目标优化函数选取">1、多目标优化函数选取</h3><h4 id="候梯时间评价函数">1.1 候梯时间评价函数</h4><p>乘客的候梯时间 <spanclass="math inline">\(WT(i，j)\)</span>,表示第i个电梯响应第j层外呼的侯梯时间<span class="math display">\[WT(i,j)=t_{run}+t_{stop}+t_{on}\]</span> 其中<spanclass="math inline">\(t_{run}\)</span>表示电梯的行驶时间，<spanclass="math inline">\(t_{stop}\)</span>表示电梯停止时间，<spanclass="math inline">\(t_{on}\)</span>表示电梯的启动时间。<spanclass="math inline">\(t_{on}+t_{stop}\)</span>为一个固定的常数，<spanclass="math inline">\(t_{run}\)</span>与此时乘客呼叫电梯的楼层与电梯当前位置的绝对距离有关。</p><p>对侯梯时间评价函数进行归一化操作</p><p>当大楼内部某一楼层有外呼信号时，设置乘客候梯时间评价函数为1，随着乘客候梯时间的增长，那么候梯时间评价函数逐渐减少并接近于0，假设长候梯时间为 60S。则 <span class="math display">\[f_w(i,j) = \begin{cases}1  , &amp; WT(i,j)=60s \\e^{x*WT^2(i,j)}  , &amp; WT(i,j)=0s \\\end{cases}\]</span> 当大楼内乘客的候梯时间是 60s 的时候，假设评价函数的值是1，可求出x=-0.0019，故候梯时间评价函数为： <span class="math display">\[f_w(i,j) =e^{-0.0019*WT^2(i,j)}\]</span></p><h4 id="电梯能耗评价函数">1.2 电梯能耗评价函数</h4><p>电梯的能耗通常是由电梯的启停能耗和匀速运行能耗这两部分所构成，因为电梯有着特殊的对重存在，一般而言，电梯在实际运行过程中的启停能耗要远高于匀速运行能耗，故此可通过减少电梯的不必要停靠次数来减少电梯能耗。电梯停靠次数也和电梯能耗满足指数曲线，故电梯能耗评价函数为：<span class="math display">\[f_e(i,j) = \begin{cases}1  , &amp; n(i,j)=2 \\e^{x*n^2(i,,j)}  , &amp; n(i,j)=15 \\\end{cases}\]</span> 当电梯的停靠次数是 15 时，设定能耗评价函数是 0.001，可求取出x=-0.0307，故电梯能耗评价函数表达式是：</p><p><span class="math display">\[f_e(i,j) =e^{-0.0019*n^2(i,j)}\]</span></p><h4 id="多目标评价函数">1.3多目标评价函数</h4><p><span class="math display">\[F(i,j)=a_1f_w(i,j)+a_2f_e(i,j)\]</span></p><p>该目标函数越小越好。</p><h3 id="基于动态规划的派梯策略">2 基于动态规划的派梯策略</h3><p>采用隔一段时间，处理一次派梯的策略</p><p>下面以一个例子说明动态规划算法，以一个简单的3部电梯，10层楼的例子说明</p><p>假设在本个处理周期，接到了2层上行呼叫，5层下行呼叫，7层上行呼叫，9层下行呼叫</p><p>假设此时1号梯位于1楼，正在上行，且内部有2，6，10层的内呼；2号梯正位于5层，正在上行，且内部有6和7层的内呼；3号梯位于4层，正在下行，且内部有3，2，1的内呼。</p><p>为了方便计算，该例子考虑较为简单的多目标评价函数。</p><p>即<spanclass="math inline">\(f_w(i,j)\)</span>为第i部电梯此时距离第j层乘客的距离，加上第i部电梯，到达第j层时中间需要停的楼层数。</p><p><spanclass="math inline">\(f_e(i,j)\)</span>为第i部电梯到达第j层的启停次数，直接用中间需要停的楼层树衡量，且<spanclass="math inline">\(a_1=1\)</span>,<spanclass="math inline">\(a_2=1\)</span>;</p><p>下面开始算法的迭代，将该位点初，评价函数的值作为标号</p><p>第一步：先处理2层上行呼叫，可派电梯为1，2，3，并计算其评价函数<spanclass="math inline">\(F(i,j)\)</span></p><p><img src="%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/image-20220427205900964.png" alt="image-20220427205900964"  /></p><figure><img src="image-20220427215326156.png" alt="image-20220427215326156" /><figcaption aria-hidden="true">image-20220427215326156</figcaption></figure><p>第二步：处理5层下行呼叫，可派梯为1，2，3，并计算评价函数<spanclass="math inline">\(F(i,j)\)</span>，并加上上一个阶段已经派梯的<spanclass="math inline">\(F(i,j)\)</span>，选择最小的标号开始延申。</p><p><img src="%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/image-20220427211539547.png" alt="image-20220427211539547"  /></p><p><img src="image-20220427211539547.png" alt="image-20220427211539547"  /></p><p>第三步：选择最小的标号点开始延申</p><p><img src="%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/image-20220427212705903.png" alt="image-20220427212705903"  /></p><p><img src="image-20220427212705903.png" alt="image-20220427212705903"  /></p><p>第四步：选择最小的标号点开始延申</p><p><img src="%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/image-20220427212730099.png" alt="image-20220427212730099"  /></p><p><img src="image-20220427212730099.png" alt="image-20220427212730099"  /></p><p>第五步：选择最小的标号点开始延申</p><p><img src="%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/image-20220427213623621.png" alt="image-20220427213623621"  /></p><p><img src="image-20220427213623621.png" alt="image-20220427213623621"  /></p><p>第六步：选择最小的标号点开始延申</p><p><img src="%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/image-20220427213838152.png" alt="image-20220427213838152"  /></p><p><img src="image-20220427213838152.png" alt="image-20220427213838152"  /></p><p>第七步：选择最小的标号点开始延申</p><p><img src="%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/image-20220427214237148.png" alt="image-20220427214237148"  /></p><p><img src="image-20220427214237148.png" alt="image-20220427214237148"  /></p><p>第八步：选择最小的标号点开始延申</p><p><img src="%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/image-20220427214702884.png" alt="image-20220427214702884"  /></p><p><img src="image-20220427214702884.png" alt="image-20220427214702884"  /></p><p>第九步：选择最小的标号点开始延申</p><p><img src="%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%94%B5%E6%A2%AF%E6%99%BA%E8%83%BD%E7%BE%A4%E6%8E%A7%E7%AE%97%E6%B3%95/image-20220427215021631.png" alt="image-20220427215021631"  /></p><p><img src="image-20220427214702884.png" alt="image-20220427214702884"  /></p><p>第十步：选择最小的标号点开始延申，直到，最小标号点位于第四阶段。按照目前分配方式，最佳派梯策略应该是，一号梯去接2层；2号梯去接7层9层；3号梯去接5层；</p>]]></content>
      
      
      <categories>
          
          <category> 优化算法，电梯群控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
            <tag> 电梯调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog HDL 语法</title>
      <link href="/2022/04/01/Verilog-HDL-%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/04/01/Verilog-HDL-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="verilog-hdl-语法">Verilog HDL 语法</h2><p>Verilog HDL (Hardware Description Language)是在用途最广泛的C语言的基础上发展起来的一种硬件描述语言 ，具有灵活性高、易学易用等特点。Verilog HDL可以在较短的时间内学习和掌握，目前已经在 FPGA开发 /IC设计领域占据 绝对的领导地位。</p><span id="more"></span><h3 id="verilog基础知识">1 Verilog基础知识</h3><h4 id="verilog的-逻辑值">1.1 Verilog的 逻辑值</h4><p>我们先看下逻辑 电路 中有四种值，即四种状态：</p><p>逻辑0：表示低电平，也就是对应我们电路的 GND</p><p>逻辑1：表示高电平，也就是对应我们电路的 VCC</p><p>逻辑X：表示未知，有可能是高电平，也有可能是低电平</p><p>逻辑Z：表示高阻态，外部没有激励信号是一个悬空状态。</p><p>如下图所示：</p><p><img src="image-20220401152308016.png" alt="image-20220401152308016"  /></p><center style="color=#C0C0C0;text-decoration:underline">图1.1 Verilog逻辑值</center><h4 id="verilog的标识符">1.2 Verilog的标识符</h4><h5 id="定义">定义</h5><p>标识符(identifier）用于定义模块名、端口名和信号名等。Verilog的标识符可以是任意一组字母、数字、$和 _(下划线 )符号的组合，但标识符的第一个字符必须是字母或者下划线。另外，标识符是区分大小写的。以下是标识符的几个例子：</p><p>Count</p><p>COUNT //与 Count不同。</p><p>R56_68</p><p>FIVE$</p><p>虽然 标识符写法很多，但是要简洁、清晰、易懂，推荐写法如下：</p><p>count</p><p>fifo_wr</p><p>不建议大小写混合使用，普通内部信号建议全部小写，参数定义建议大写，另外信号命名最好体现信号的含义。</p><h5 id="规范建议">规范建议</h5><p>以下是一些书写规范的要求：</p><p>1、用有意义的有效的名字如 sum、 cpu_addr等。</p><p>2、用下划线区分词语组合，如 cpu_addr。</p><p>3、采用一些前缀或后缀，比如：时钟采用 clk前缀： clk_50mclk_cpu；低电平采用 _n后缀： enable_n</p><p>4、统一缩写，如全局复位信号 rst。</p><p>5、同一信号在不同层次保 持一致性，如同一时钟信号必须在各模块保持一致。</p><p>6、自定义的标识符不能与保留字（关键词）同名。</p><p>7、参数统一采用大写，如定义参数 使用 SIZE</p><h4 id="verilog的数字进制格式">1.3 Verilog的数字进制格式</h4><p>Verilog数字 进制格式包括二进制、 八进制 、 十进制和十六进制，一般常用的为二进制、十进制和十六进制。</p><p>二进制表示 如下： 4’b0101表示 4位 二进制数字 0101</p><p>十进制表示 如下： 4’d2表示 4位十进制数字 2（二进制 0010</p><p>十六进制表示 如下： 4’ha表示 4位十六 进制数字 a（二进制1010），十六进制 的计数方式为 0 1 2…9a b c d e f 最大计数为 f f：十 进制表示为 15）。</p><p>当代码中没有指定数字的位宽与进制时，默认为32位的十进制，比如100，实际上表示的值为32’d100。</p><h4 id="verilog的数据类型">1.4 Verilog的数据类型</h4><p>在Verilog语法中，主要有三大类数据类型，即寄存器类型、线网类型和参数类型。从名称中，我们可以看出，真正在数字电路中起作用的数据类型应该是寄存器类型和线网类型。</p><p>1、寄存器类型</p><p>寄存器类型表示一个抽象的数据存储单元，它只能在always语句和initial语句中被赋值，并且它的值从一个赋值到另一个赋值过程中被保存下来。如果该过程语句描述的是时序逻辑，即always语句带有时钟信号，则该寄存器变量对应为寄存器；如果该过程语句描述的是组合逻辑即always语句不带有时钟信号则该寄存器变量对应为硬件连线；寄存器类型的缺省值是x（未知状态）。</p><p>寄存器数据类型有很多种，如reg、 integer、 real等，其中最常用的就是reg类型，它的使用方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reg define </span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] delay_cnt; </span><br><span class="line"><span class="comment">//延时计数器 </span></span><br><span class="line"><span class="keyword">reg</span>    key_flag ; <span class="comment">//按键标志</span></span><br></pre></td></tr></table></figure><p>2、线网类型</p><p>线网表示Verilog结构化元件间的物理连线。它的值由驱动元件的值决定，例如连续赋值或门的输出。如果没有驱动元件连接到线网，线网的缺省值为z（高阻态）。线网类型同寄存器类型一样也是有很多种如 tri和wire等，其中最常用的就是 wire类型，它的使用方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wire define </span></span><br><span class="line"><span class="keyword">wire</span>       data_en; <span class="comment">//数据使能信号 </span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data ; <span class="comment">//数据</span></span><br></pre></td></tr></table></figure><p>3、参数类型</p><p>我们再来看下参数类型 ，参数其实就是一个常量，常被用于定义状态机的状态、数据位宽和延迟大小等，由于它可以在编译时修改参数的值，因此它又常被用于一些参数可调的模块中，使用户在实例化模块时，可以根据需要配置参数。在定义参数时，我们可以一次定义多个参数，参数与参数之间需要用逗号隔开。这里我们需要注意的是参数的定义是局部的，只在当前模块中有效。它的使用方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parameter define </span></span><br><span class="line"><span class="keyword">parameter</span> DATA_WIDTH = <span class="number">8</span>; <span class="comment">//数据位宽为8位</span></span><br></pre></td></tr></table></figure><h4 id="verilog的运算符">1.5 Verilog的运算符</h4><p>大家看完了 Verilog的 数据类型 我们再来介绍下 Verilog的运算符。Verilog中的运算符按照功能可以分为下述类型： 1、算术运算符、2、关系运算符、 3、逻辑运算符、 4、条件运算符、 5、位运算符、6、移位运算符、 7、拼接运算符。下面我们分别 对 这些运算符进行介绍。</p><p>1、算术运算符</p><p>算术运算符，简单来说，就是数学运算里面的加减乘除，数字逻辑处理有时候也需要进行数字运算，所以需要算术运算符。常用的算术运算符主要包括加减乘除和模除（模除运算也叫取余运算）如下表 所示</p><center style="color=#C0C0C0;text-decoration:underline">表1.1 算术运算符</center><p><img src="image-20220401161008229.png" alt="image-20220401161008229" style="zoom: 80%;" /></p><p>大家要注意下， Verilog实现乘除比较浪费组合逻辑资源，尤其是除法 。一般2的指数次幂的乘除法使用移位运算来完成运算 ，详情 可以看移位运算符章节 。非2的指数次幂的乘除法一般是 调用 现成的IPQUARTUS/ISE等工具软件会有提供， 不过这些工具软件提供的 IP也是 由 最底层的 组合逻辑 (与 或非门等 )搭建而成的。</p><p>2、关系运算符</p><p>关系运算符主要是用来做一些条件判断用的，在进行关系运算符时，如果声明的关系是假的，则返回值是0，如果声明的关系是真的，则返回值是1；所有的关系运算符有着相同的优先级别，关系运算符的优先级别低于算术运算符的优先级别如下表所示。</p><center style="color=#C0C0C0;text-decoration:underline">表1.2 关系运算符</center><p><img src="image-20220401161352566.png" alt="image-20220401161352566" style="zoom:80%;" /></p><p>3、逻辑运算符</p><p>逻辑运算符是连接多个关系表达式用的，可实现更加复杂的判断，一般不单独使用，都需要配合具体语句来实现完整的意思，如下表 所示。</p><center style="color=#C0C0C0;text-decoration:underline">表1.3 逻辑运算符</center><p><img src="image-20220401163025582.png" alt="image-20220401163025582" style="zoom:80%;" /></p><p>4、条件运算符</p><p>条件操作符一般来构建从两个输入中选择一个作为输出的条件选择结构，功能等同于always中的ifelse语句，如 下表 所示。</p><center style="color=#C0C0C0;text-decoration:underline">表1.4 条件运算符</center><p><img src="image-20220401163137576.png" alt="image-20220401163137576" style="zoom:80%;" /></p><p>5、位运算符</p><p>位运算符是一类最基本的运算符，可以认为它们直接对应数字逻辑中的与、或、非门等逻辑门。常用的位运算符如 下表 所示 。</p><center style="color=#C0C0C0;text-decoration:underline">表1.5 位运算符</center><p><img src="image-20220401190024356.png" alt="image-20220401190024356" style="zoom:80%;" /></p><p>位运算符的与、或、非与逻辑运算符逻辑与、逻辑或、逻辑非使用时候容易混淆，逻辑运算符一般用在条件判断上，位运算符一般用在信号赋值上。</p><p>6、移位运算符</p><p>移位运算符包括左移位运算符和右移位运算符，这两种移位运算符都用0来填补移出的空位。如下表所示 。</p><center style="color=#C0C0C0;text-decoration:underline">表1.6 移位运算符</center><p><img src="image-20220401190234108.png" alt="image-20220401190234108" style="zoom:80%;" /></p><p>假设a有 8bit数据 位宽 ，那么 a&lt;&lt;2，表示 a左 移 2bit a还是8bit数据位宽 a的最高 2bit数据被移位丢弃了，最低 2bit数据 固 定 补 0。如果 a是 3（二进制 00000011 那么 3左 移 2bit 3&lt;&lt;2 就是12（二进制： 00001100）。 一般使用左移位 运算代替乘法 ，右移位运算代替除法但是这种也只能表示 2的指数次幂的乘除法。</p><p>7、拼接运算符</p><p>Verilog中有一个特殊的运算符 是 C语言中没有的，就是位拼接运算符。用这个运算符可以把两个或多个信号的某些位拼接起来进行运算操作。如下表 所示</p><center style="color=#C0C0C0;text-decoration:underline">表1.7 拼接运算符A</center><p><img src="image-20220401190535911.png" alt="image-20220401190535911" style="zoom:80%;" /></p><p>8、运算符的优先级</p><p>介绍完了 这么多运算符，大家可能 会想到究竟哪个运算符高，哪个运算符低。为了便于大家查看这些运算符的优先级，我们将它们制作成了表格，如下表所示。</p><center style="color=#C0C0C0;text-decoration:underline">表1.7 运算符的优先级</center><p><img src="image-20220401190619799.png" alt="image-20220401190619799" style="zoom:80%;" /></p><h3 id="verilog程序框架">2 Verilog程序框架</h3><h4 id="注释">2.1 注释</h4><p>Verilog HDL中有两种注释的方式，一种是以“ “/<em>”符号开始，“</em>/”结束，在两个符号之间的语句都是注释语句，因此可扩展到多行。如：</p><p>/* statement1</p><p>statement2</p><p>......</p><p>statementn */</p><p>以上</p><p>n个语句都是注释语句。</p><p>另一种是以</p><p>//开头的语句，它表示以 //开始到本行结束都属于注释 语句。如：</p><p>//statement1</p><p>我们建议的写法：使用//作为注释。</p><h4 id="关键字">2.2 关键字</h4><p>Verilog和 C语言 类似，都因编写需要定义了一系列保留字，叫做关键字（或关键词）。这些保留字是识别语法的关键 。我们给大家列出了Verilog中 的关键字，如下表所示。</p><center style="color=#C0C0C0;text-decoration:underline">表2.1 Verilog的所有关键字</center><p><img src="image-20220401191332360.png" alt="image-20220401191332360"  /></p><p>虽然上 表 列了很多，但是实际 经常 使用的不是很多，实际 经常使用的主要 如下 表 所示。</p><center style="color=#C0C0C0;text-decoration:underline">表2.1 Verilog常用的关键字</center><p><img src="image-20220401191428325.png" alt="image-20220401191428325"  /></p><p>注意只有小写的关键字才是保留字。例如，标识符always(这是个关键词)与标识符 ALWAYS(非关键词 )是不同的。</p><h4 id="程序框架">2.3 程序框架</h4><p>我们以 LED流水灯程序 为 例来 给大家展示 Verilog的程序框架 ，代码如下所示（注意：代码中前面的行号只是为了方便大家阅读代码与快速定位到行号的位置，在实际编写代码时不可以添加行号，否则编译代码时会报错）。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File name:           led_twinkle</span></span><br><span class="line"><span class="comment">// Last modified Date:  2019/4/14 10:55:56</span></span><br><span class="line"><span class="comment">// Last Version:        V1.0</span></span><br><span class="line"><span class="comment">// Descriptions:        LED灯闪烁</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Created by:          正点原子</span></span><br><span class="line"><span class="comment">// Created date:        2019/4/14 10:55:56</span></span><br><span class="line"><span class="comment">// Version:             V1.0</span></span><br><span class="line"><span class="comment">// Descriptions:        The original version</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//****************************************************************************************//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> led_twinkle(</span><br><span class="line">    <span class="keyword">input</span>          sys_clk  ,  <span class="comment">//系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>          sys_rst_n,  <span class="comment">//系统复位，低电平有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span>  [<span class="number">1</span>:<span class="number">0</span>]  led         <span class="comment">//LED灯</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">25</span>:<span class="number">0</span>]  cnt ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************************************************</span></span><br><span class="line"><span class="comment">//**                    main code</span></span><br><span class="line"><span class="comment">//*****************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对计数器的值进行判断，以输出LED的状态</span></span><br><span class="line"><span class="keyword">assign</span> led = (cnt &lt; <span class="number">26&#x27;d2500_0000</span>) ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b10</span> ;</span><br><span class="line"><span class="comment">//assign led = (cnt &lt; 26&#x27;d5)         ? 2&#x27;b01 : 2&#x27;b10 ;  //仅用于仿真</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计数器在0~5000_000之间进行计数</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">        cnt &lt;= <span class="number">26&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt; <span class="number">26&#x27;d5000_0000</span>)</span><br><span class="line"><span class="comment">//  else if(cnt &lt; 26&#x27;d10)  //仅用于仿真</span></span><br><span class="line">        cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt &lt;= <span class="number">26&#x27;d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FPAG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Revolute Joint 模块</title>
      <link href="/2022/03/31/Revolute-Joint-%E6%A8%A1%E5%9D%97/"/>
      <url>/2022/03/31/Revolute-Joint-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="revolute-joint-模块">Revolute Joint 模块</h2><span id="more"></span><p>Joint with one revolute primitive 一个初试的旋转关节</p><ul><li><strong>Library:</strong>Simscape / Multibody / Joints</li></ul><h3 id="description">Description</h3><p>The Revolute Joint block models a joint that has one rotationaldegree of freedom.</p><p>Revolute Joint 模块模拟具有一个旋转自由度的关节。</p><p><img src="image-20220331122431883.png" alt="image-20220331122431883" style="zoom:150%;" /></p><p>The joint constrains the motion of two arbitrary frames that connectto the base and follower frames of the joint to pure rotation about acommon axis. The axis of rotation is aligned with the <em>z</em>-axis ofthe joint base frame. The base and follower frames have a common originand <em>z</em>-axis, and the follower frame rotates about the<em>z</em>-axis, as shown in the image.</p><p>关节将连接到关节的基础框架和从动框架的两个任意框架的运动限制为围绕公共轴进行纯旋转。旋转轴与关节基础框架的 z 轴对齐。如图所示，基础框架和跟随框架具有共同的原点和 z 轴，并且跟随框架围绕 z轴旋转。</p><p><img src="image-20220331122451755.png" alt="image-20220331122451755" style="zoom:150%;" /></p><p>To target the initial state of the a joint primitive, use theparameters under <strong>State Targets</strong>. The position andvelocity targets are resolved in the base frame. You can also set thepriority levels for the targets. If the block cannot simultaneouslysatisfy the state targets, the priority level determines which targetsto satisfy first and how closely to satisfy them. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/assembling-multibody-systems.html#busaiy6-1">GuidingAssembly</a> for more information.</p><p>要定位关节图元的初始状态，请使用 <strong>State Targets</strong>下的参数。 位置和速度目标在基本框架中解析。 您还可以设置目标的优先级。如果块不能同时满足状态目标，则优先级确定首先满足哪些目标以及满足这些目标的程度。更多信息见【指导组装】(https://ww2.mathworks.cn/help/physmod/sm/ug/assemble-multibody-systems.html#busaiy6-1)。</p><p>To model damping and spring behavior in a joint primitive, use theparameters under <strong>Internal Mechanics</strong>. Specify jointdamping coefficients to model energy dissipation and joint springstiffness to model energy storage. Springs resist attempts to displacethe joint primitive from its equilibrium position. Joint dampers act asenergy dissipation elements. Springs and dampers are strictlylinear.</p><p>要模拟关节基本体中的阻尼和弹簧行为，请使用内部力学下的参数。指定关节阻尼系数来模拟能量耗散和关节弹簧刚度来模拟能量存储。弹簧抵抗试图将关节基元从其平衡位置移开的尝试。关节阻尼器充当能量耗散元件。 弹簧和阻尼器是严格线性的。</p><p>To specify the limits of a joint primitive, use the parameters under<strong>Limits</strong>. The lower and upper bounds define the width ofthe free region of a joint primitive. The block applies a force ortorque to accelerate the joint position back to the free region when theposition exceeds the bounds. The block uses a smoothed spring-dampermethod to compute the force or torque. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ref/spatialcontactforce.html#mw_acd246fe-915a-4822-9c50-b9aa9debb1ce">Description</a>section of the <ahref="https://ww2.mathworks.cn/help/physmod/sm/ref/spatialcontactforce.html">SpatialContact Force</a> block for more information about the smoothedspring-damper method.</p><p>要指定关节基本体的限制，请使用“限制”下的参数。下限和上限定义了关节图元的自由区域的宽度。当位置超出界限时，该块会施加力或扭矩以将关节位置加速回到自由区域。该块使用平滑弹簧阻尼器方法来计算力或扭矩。有关平滑弹簧阻尼器方法的更多信息，请参见空间接触力模块的描述部分。</p><p>A revolute primitive provides two actuation parameters,<strong>Torque</strong> and <strong>Motion</strong>, that govern themotion of the primitive during a simulation. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/joint-actuation.html">SpecifyingJoint Actuation Inputs</a> for more information. Additionally, the blockhas ports that output sensing data, such as position, velocity,acceleration, forces, and torques, that enable you to perform analyticaltasks on a model. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/sensing.html">Sensing</a>and <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><p>旋转基元提供两个驱动参数，扭矩和运动，它们在模拟过程中控制基元的运动。有关详细信息，请参阅指定关节驱动输入。此外，该模块具有输出传感数据的端口，例如位置、速度、加速度、力和扭矩，使您能够对模型执行分析任务。有关详细信息，请参阅传感和力和扭矩传感。</p><h3 id="ports">Ports</h3><h4 id="frame">Frame</h4><h5 id="b-base-frame"><code>B</code> — Base frame</h5><p>Base frame of the joint block.</p><h5 id="f-follower-frame"><code>F</code> — Follower frame</h5><p>Follower frame of the joint block.</p><h4 id="input">Input</h4><h5id="t-actuation-torque-physical-signal-驱动扭矩物理信号"><code>t</code>— Actuation torque physical signal 驱动扭矩物理信号</h5><p>Physical signal input port that accepts the actuation torque for thejoint primitive. The signal provides the value of the torque thatapplies on both the base and follower frames of the joint primitive.</p><h6 id="dependencies">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Actuation</strong>, set <strong>Torque</strong> to<code>Provided by Input</code>.</p><p>接受关节图元的驱动扭矩的物理信号输入端口。该信号提供了应用于关节图元的基础框架和从动框架的扭矩值。</p><p>依赖项</p><p>要启用此端口，请在 Z Revolute Primitive (Rz) &gt; Actuation 下，将Torque 设置为由 Input 提供。</p><h5 id="q-motion-profile-physical-signal"><code>q</code> — Motionprofile physical signal</h5><p>Physical signal input port that accepts the motion profile for thejoint primitive. The signal provides the rotation of the follower framewith respect to the base frame about the joint primitive axis. Note thatthe signal must also contain the first and second derivatives of therotation.</p><h6 id="dependencies-1">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Actuation</strong>, set <strong>Motion</strong> to<code>Provided by Input</code>.</p><p>物理信号输入端口，接受关节基元的运动轮廓。该信号提供了从动框架相对于基本框架绕关节图元轴的旋转。请注意，信号还必须包含旋转的一阶和二阶导数。</p><h6 id="依赖项">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Actuation</strong> 下，将 <strong>Motion</strong> 设置为<code>Provided by Input</code>。</p><h5id="mode-joint-mode-control-scalar-关节模式控制标量"><code>mode</code> —Joint mode control scalar 关节模式控制标量</h5><p>Input port that controls the joint mode. The signal is a unitlessscalar. The joint mode is normal when the input signal is 0 anddisengaged when the input signal is -1. The joint mode can be changedmany times during a simulation.</p><h6 id="dependencies-2">Dependencies</h6><p>To enable this port, under <strong>Mode Configuration</strong>, set<strong>Mode</strong> to <code>Provided by Input</code>.</p><p>控制关节模式的输入端口。 信号是无单位标量。输入信号为0时关节模式正常，输入信号-1时关节模式断开。在模拟过程中可以多次更改关节模式。</p><h6 id="依赖项-1">依赖项</h6><p>要启用此端口，请在 <strong>Mode Configuration</strong> 下，将<strong>Mode</strong> 设置为 <code>Provided by Input</code>。</p><h4 id="output">Output</h4><h5id="q-position-of-joint-primitive-physical-signal-关节原始物理信号的位置"><code>q</code>— Position of joint primitive physical signal关节原始物理信号的位置</h5><p>Physical signal port that outputs the position of the jointprimitive. The value is the rotation angle of the follower frame withrespect to the base frame.</p><h6 id="dependencies-3">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Position</strong>.</p><p>输出关节图元位置的物理信号端口。该值是从动框架相对于基础框架的旋转角度。</p><h6 id="依赖项-2">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Position</strong>。</p><h5id="w-first-derivative-of-position-of-joint-primitive-physical-signal"><code>w</code>— First derivative of position of joint primitive physical signal</h5><p>Physical signal port that outputs the first derivative of position ofthe joint primitive.</p><h6 id="dependencies-4">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Velocity</strong>.</p><p>输出关节图元位置的一阶导数的物理信号端口。</p><h6 id="依赖项-3">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Velocity</strong>。</p><h5id="b-second-derivative-of-position-of-joint-primitive-physical-signal"><code>b</code>— Second derivative of position of joint primitive physical signal</h5><p>关节原始物理信号位置的二阶导数</p><p>Physical signal port that outputs the second derivative of positionof the joint primitive.</p><h6 id="dependencies-5">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Acceleration</strong>.</p><p>输出关节图元位置二阶导数的物理信号端口。</p><h6 id="依赖项-4">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Acceleration</strong>。</p><h5id="t-actuator-torque-acting-on-joint-primitive-physical-signal"><code>t</code>— Actuator torque acting on joint primitive physical signal</h5><p>Physical signal port that outputs the actuator torque acting on thejoint primitive.</p><h6 id="dependencies-6">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>ActuatorTorque</strong>.</p><p>输出作用在关节基元上的执行器扭矩的物理信号端口。</p><h6 id="依赖项-5">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Actuator Torque</strong>。</p><h5 id="tll-lower-limit-torque-physical-signal"><code>tll</code> —Lower-limit torque physical signal</h5><p>Physical signal port that outputs the lower-limit torque. The blockapplies the torque when the joint primitive position exceeds the lowerbound of the free region. The torque applies to both the base andfollower frames of the joint primitive to accelerate the position backto the free region.</p><h6 id="dependencies-7">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Lower-LimitTorque</strong>.</p><p>输出下限扭矩的物理信号端口。当关节基元位置超过自由区域的下限时，该模块将应用扭矩。扭矩适用于关节图元的基础框架和跟随框架，以将位置加速回到自由区域。</p><h6 id="依赖项-6">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Lower-LimitTorque</strong>。</p><h5 id="tul-upper-limit-torque-physical-signal"><code>tul</code> —Upper-limit torque physical signal</h5><p>Physical signal port that outputs the upper-limit torque. The blockapplies the torque when the joint primitive position exceeds the upperbound of the free region. The torque applies to both the base andfollower frames of the joint primitive to accelerate the position backto the free region.</p><h6 id="dependencies-8">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Upper-LimitTorque</strong>.</p><p>输出上限扭矩的物理信号端口。当关节基元位置超过自由区域的上限时，该模块将应用扭矩。扭矩适用于关节图元的基础框架和跟随框架，以将位置加速回到自由区域。</p><h6 id="依赖项-7">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Upper-LimitTorque</strong>。</p><h5 id="fc-constraint-force-physical-signal"><code>fc</code> —Constraint force physical signal</h5><p>Physical signal port that outputs constraint force that acts in thejoint. The force maintains the translational constraints of the joint.See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/sense-internal-forces-in-double-pendulum-link.html">SenseConstraint Forces</a> for more information.</p><h6 id="dependencies-9">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Constraint Force</strong>.</p><p>输出作用于关节的约束力的物理信号端口。 力保持关节的平移约束。更多信息参见【感知约束力】(https://ww2.mathworks.cn/help/physmod/sm/ug/sense-internal-forces-in-double-pendulum-link.html)。</p><h6 id="依赖项-8">依赖项</h6><p>要启用此端口，请在 <strong>Composite Force/Torque Sensing</strong>下，选择 <strong>Constraint Force</strong>。</p><h5 id="tc-constraint-torque-physical-signal"><code>tc</code> —Constraint torque physical signal</h5><p>Physical signal port that outputs constraint torque that acts in thejoint. The torque maintains the rotational constraints of the joint. See<ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><h6 id="dependencies-10">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Constraint Torque</strong>.</p><p>输出作用于关节的约束扭矩的物理信号端口。 扭矩保持关节的旋转约束。有关详细信息，请参阅力和扭矩传感。</p><h6 id="依赖项-9">依赖项</h6><p>要启用此端口，请在 Composite Force/Torque Sensing 下选择 ConstraintTorque。</p><h5 id="ft-total-force-physical-signal"><code>ft</code> — Total forcephysical signal</h5><p>Physical signal port that outputs the total force that acts in thejoint. The total force is the sum of the forces transmitted from oneframe to the other through the joint. The force includes actuation,internal, limit and constraint forces. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><h6 id="dependencies-11">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Total Force</strong>.</p><p>输出作用于关节的总力的物理信号端口。总力是通过关节从一帧传递到另一帧的力的总和。力包括驱动力、内部力、限制力和约束力。更多信息请参见【力和扭矩传感】（https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。###### 依赖项 要启用此端口，请在 <strong>Composite Force/TorqueSensing</strong> 下，选择 <strong>Total Force</strong>。</p><h5 id="tt-total-torque-physical-signal"><code>tt</code> — Total torquephysical signal</h5><p>Physical signal port that outputs the total torque that acts in thejoint. The total torque is the sum of the torques transmitted from oneframe to the other through the joint. The torque includes actuation,internal, limit, and constraint torques. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><h6 id="dependencies-12">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Total Torque</strong>.</p><p>输出作用于关节的总扭矩的物理信号端口。总扭矩是从一个框架通过关节传递到另一个框架的扭矩之和。扭矩包括致动扭矩、内部扭矩、限制扭矩和约束扭矩。更多信息请参见【力和扭矩传感】（https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。</p><h6 id="依赖项-10">依赖项</h6><p>要启用此端口，请在 <strong>Composite Force/Torque Sensing</strong>下，选择 <strong>Total Torque</strong>。</p><h3 id="parameters">Parameters</h3><h4 id="z-revolute-primitive-rz">Z Revolute Primitive (Rz)</h4><h5id="state-targets-specify-position-target-whether-to-specify-position-target-off-default-on"><code>State Targets &gt; Specify Position Target</code>— Whether to specify position target <code>off</code> (default) |<code>on</code></h5><p>State Targets &gt; Specify PositionTarget<code>— 是否指定位置目标</code>off<code>（默认） |</code>开</p><p>Select this parameter to enable parameters that specify the positiontarget of the joint primitive.</p><p>选择此参数以启用指定关节图元位置目标的参数。</p><h5id="state-targets-specify-position-target-priority-priority-level-of-position-target-high-desired-default-low-approximate"><code>State Targets &gt; Specify Position Target &gt; Priority</code>— Priority level of position target <code>High (desired)</code>(default) | <code>Low (approximate)</code></h5><p>状态目标 &gt; 指定位置目标 &gt; 优先级 -位置目标的优先级高（需要）（默认）| 低（大约）</p><p>Priority level of the position target, specified as<code>High (desired)</code> or <code>Low (approximate)</code>.</p><h6 id="dependencies-13">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Position Target</strong>.</p><p>位置目标的优先级，指定为“高（期望）”或“低（近似）”。</p><h6 id="依赖项-11">依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>State Targets</strong> 下，选择 <strong>Specify PositionTarget</strong>。</p><h5id="state-targets-specify-position-target-value-angle-of-position-target-0-deg-default-scalar-with-a-unit-of-angle"><code>State Targets &gt; Specify Position Target &gt; Value</code>— Angle of position target 0 <code>deg</code> (default) | scalar with aunit of angle</h5><p>Angle to specify the position target, specified as a scalar with aunit of angle.</p><h6 id="dependencies-14">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Position Target</strong>.</p><p>指定位置目标的角度，指定为以角度为单位的标量。</p><p>依赖项 要启用此参数，请在 Z Revolute Primitive (Rz) &gt; StateTargets 下选择指定位置目标。</p><h5id="state-targets-specify-velocity-target-whether-to-specify-velocity-target-off-default-on"><code>State Targets &gt; Specify Velocity Target</code>— Whether to specify velocity target <code>off</code> (default) |<code>on</code></h5><p>Select this parameter to enable parameters for that specify thevelocity target of the joint primitive.</p><p>选择此参数以启用指定关节图元的速度目标的参数。</p><h5id="state-targets-specify-velocity-target-priority-priority-level-of-velocity-target-high-desired-default-low-approximate"><code>State Targets &gt; Specify Velocity Target &gt; Priority</code>— Priority level of velocity target <code>High (desired)</code>(default) | <code>Low (approximate)</code></h5><p>Priority level of the velocity target, specified as<code>High (desired)</code> or <code>Low (approximate)</code>.</p><h6 id="dependencies-15">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Velocity Target</strong>.</p><p>速度目标的优先级，指定为“高（期望）”或“低（近似）”。</p><h6 id="依赖项-12">依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>State Targets</strong> 下，选择 <strong>Specify VelocityTarget</strong>。</p><h5id="state-targets-specify-velocity-target-value-velocity-target-of-joint-primitive-0-degs-default-scalar-with-unit-of-angular-velocity"><code>State Targets &gt; Specify Velocity Target &gt; Value</code>— Velocity target of joint primitive 0 <code>deg/s</code> (default) |scalar with unit of angular velocity</h5><p>Velocity target of the joint primitive, specified as a scalar with aunit of angular velocity.</p><h6 id="dependencies-16">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Velocity Target</strong>.</p><p>关节图元的速度目标，指定为具有角速度单位的标量。</p><h6 id="依赖项-13">依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>State Targets</strong> 下，选择 <strong>Specify VelocityTarget</strong>。</p><h5id="internal-mechanics-equilibrium-position-position-where-internal-torque-is-zero-0-deg-default-scalar-with-unit-of-angle"><code>Internal Mechanics &gt; Equilibrium Position</code>— Position where internal torque is zero 0 <code>deg</code> (default) |scalar with unit of angle</h5><p>内部扭矩为零的位置 0 <code>deg</code>（默认）| 以角度为单位的标量</p><p>Position where the spring torque is zero, specified as a scalar witha unit of angle. The value specifies the rotation angle of the followerframe with respect to the base frame.</p><p>弹簧扭矩为零的位置，指定为具有角度单位的标量。该值指定从动框架相对于基础框架的旋转角度。</p><h5id="internal-mechanics-spring-stiffness-stiffness-of-force-law-0-nmdeg-default-scalar-with-unit-of-stiffness"><code>Internal Mechanics &gt; Spring Stiffness</code>— Stiffness of force law 0 <code>N*m/deg</code> (default) | scalar withunit of stiffness</h5><p>Stiffness of the internal spring-damper force law for the jointprimitive, specified as a scalar with a unit of stiffness.</p><p>关节基元的内部弹簧阻尼力定律的刚度，指定为具有刚度单位的标量。</p><h5id="internal-mechanics-damping-coefficient-damping-coefficient-of-force-law-0-nmdegs-default-scalar-with-unit-of-damping-coefficient"><code>Internal Mechanics &gt; Damping Coefficient</code>— Damping coefficient of force law 0 <code>N*m/(deg/s)</code> (default)| scalar with unit of damping coefficient</h5><p>Damping coefficient of the internal spring-damper force law for thejoint primitive, specified as a scalar with a unit of dampingcoefficient.</p><p>关节基元的内部弹簧-阻尼力定律的阻尼系数，指定为具有阻尼系数单位的标量。</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> MATLAB仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> MATLAB仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simulink机器人仿真库</title>
      <link href="/2022/03/27/simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93/"/>
      <url>/2022/03/27/simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h4 id="simulink机器人仿真库">simulink机器人仿真库</h4><p>[TOC]</p><span id="more"></span><h2 id="forward-dynamics-正向动力学">Forward Dynamics 正向动力学</h2><p>给定关节扭矩和状态的关节加速度</p><p><strong>Library:</strong> Robotics System Toolbox / ManipulatorAlgorithm</p><p><img src="image-20220327131159671.png" alt="image-20220327131159671"  /></p><h3 id="description">Description</h3><p>The Forward Dynamics block computes joint accelerations for a robotmodel given a robot state that is made up of joint torques, jointstates, and external forces. To get the joint accelerations, specify therobot configuration (joint positions), joint velocities, appliedtorques, and external forces.</p><p>Forward Dynamics模块在给定由关节扭矩、关节状态和外力组成的机器人状态下计算机器人模型的关节加速度。要获得关节加速度，请指定机器人配置（关节位置）、关节速度、施加的扭矩和外力。</p><p>The Forward Dynamics block computes joint accelerations for a robotmodel given a robot state that is made up of joint torques, jointstates, and external forces. To get the joint accelerations, specify therobot configuration (joint positions), joint velocities, appliedtorques, and external forces.</p><p>Specify the robot model in the <strong>Rigid body tree</strong>parameter as a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object, and set the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html#bvan8uq-1-Gravity">Gravity</a>property on the object. You can also import a robot model from an URDF(Unified Robot Description Formation) file using <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>Forward Dynamics模块在给定由关节扭矩、关节状态和外力组成的机器人状态下计算机器人模型的关节加速度。要获得关节加速度，请指定机器人配置（关节位置）、关节速度、施加的扭矩和外力。</p><p>将刚体树参数中的机器人模型指定为rigidBodyTree对象，并在该对象上设置Gravity属性。您还可以使用 importrobot 从URDF（统一机器人描述格式）文件中导入机器人模型。</p><h3 id="ports">Ports</h3><h4 id="input">Input</h4><h5 id="config-robot-configuration-vector"><code>Config</code> — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the <strong>Rigid bodytree</strong> parameter. You can also generate this vector for a complexrobot using the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>or <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a>functions inside a Constant or MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由<strong>刚体树</strong>参数设置。您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>或 [<code>randomConfiguration</code>] 为复杂机器人生成此向量(https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html)函数在 Constant 或 MATLAB Function 块中。</p><h5 id="jointvel-joint-velocities-vector"><code>JointVel</code> — Jointvelocities vector</h5><p>Joint velocities, specified as a vector. The number of jointvelocities is equal to the degrees of freedom (number of nonfixedjoints) of the robot.</p><p>关节速度，指定为矢量。关节速度的数量等于机器人的自由度（非固定关节的数量）。</p><h5 id="jointtorq-joint-torques-vector"><code>JointTorq</code> — Jointtorques vector</h5><p>Joint torques, specified as a vector. Each element corresponds to atorque applied to a specific joint. The number of joint torques is equalto the degrees of freedom (number of nonfixed joints) of the robot.</p><p>关节扭矩，指定为矢量。 每个元素对应于施加到特定关节的扭矩。关节扭矩的数量等于机器人的自由度（非固定关节的数量）。</p><h5 id="fext-external-force-matrix-6-by-n-matrix"><code>FExt</code> —External force matrix 6-by-<em>n</em> matrix</h5><p>外力矩阵，指定为 6×n 矩阵，其中 n 是机器人模型中的物体数量。该矩阵在对应于特定实体的行中包含非零值。每一行都是施加的力和扭矩的矢量，它们充当该特定身体的扳手。 使用带有MATLAB Function 模块的 externalForce 生成此矩阵</p><h4 id="output">Output</h4><h5 id="jointaccel-joint-accelerations-vector"><code>JointAccel</code> —Joint accelerations vector</h5><p>关节加速度，以向量形式返回。 关节加速度的数量等于机器人的自由度。</p><h3 id="parameters">Parameters</h3><h5id="rigid-body-tree-robot-model-twojointrigidbodytree-default-rigidbodytree-object"><code>Rigid body tree</code>— Robot model <code>twoJointRigidBodyTree</code> (default) |<code>RigidBodyTree</code> object</h5><p>Robot model, specified as a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object. You can also import a robot model from an URDF (Unified RobotDescription Formation) file using <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>The default robot model, <code>twoJointRigidBodyTree</code>, is arobot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>对象。 您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>从 URDF（统一机器人描述形成）文件导入机器人模型。</p><p>默认机器人模型“twoJointRigidBodyTree”是具有旋转关节和两个自由度的机器人。</p><h5id="simulate-using-type-of-simulation-to-run-interpreted-execution-default-code-generation"><code>Simulate using</code>— Type of simulation to run <code>Interpreted execution</code> (default)| <code>Code generation</code></h5><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB® interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成 - 使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><h2 id="get-jacobian-获取雅可比矩阵">Get Jacobian 获取雅可比矩阵</h2><p>Geometric Jacobian for robot configuration</p><p>用于机器人配置的几何雅可比行列式</p><p><img src="image-20220327132517323.png" alt="image-20220327132517323"  /></p><ul><li><strong>Library:</strong>Robotics System Toolbox / ManipulatorAlgorithms</li></ul><h3 id="description-1">Description</h3><p>The Get Jacobian block returns the geometric Jacobian relative to thebase for the specified end effector at the given configuration of a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>robot model.</p><p>The Jacobian maps the joint-space velocity to the end-effectorvelocity relative to the base coordinate frame. The end-effectorvelocity equals:</p><p>Get Jacobian模块返回相对于在刚体树机器人模型的给定配置下指定末端执行器的基部的几何雅可比。</p><p>雅可比将关节空间速度映射到相对于基本坐标系的末端执行器速度。末端执行器速度等于：</p><p><img src="simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93.assets/image-20220327132908638.png" alt="image-20220327132908638" style="zoom: 80%;" /></p><p><span class="math inline">\(\omega\)</span>is the angular velocity,<span class="math inline">\(v\)</span> is the linear velocity, and<spanclass="math inline">\(\dot q\)</span>is the joint-space velocity.</p><h3 id="ports-1">Ports</h3><h4 id="input-1">Input</h4><h5 id="config-robot-configuration-vector-1">Config — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the <strong>Rigid bodytree</strong> parameter. You can also generate this vector for a complexrobot using the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>or<ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a>functions inside a Constant or MATLAB Function block</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由刚体树参数设置。您还可以使用 Constant 或 MATLAB Function 模块中的 homeConfiguration 或randomConfiguration 函数为复杂机器人生成此向量</p><h4 id="output-1">Output</h4><h5id="jacobian-geometric-jacobian-of-end-effector-6-by-n-matrix">Jacobian— Geometric Jacobian of end effector 6-by-n matrix</h5><p>Geometric Jacobian of the end effector with the specifiedconfiguration, Config, returned as a 6-by-n matrix, where n is thenumber of degrees of freedom of the end effector. The Jacobian maps thejoint-space velocity to the end-effector velocity relative to the basecoordinate frame. The end-effector velocity equals:</p><p><img src="image-20220327133500482.png" alt="image-20220327133500482"  /></p><p><span class="math inline">\(\omega\)</span>is the angular velocity,<span class="math inline">\(v\)</span> is the linear velocity, and<spanclass="math inline">\(\dot q\)</span>is the joint-space velocity.</p><p>具有指定配置 Config 的末端执行器的几何雅可比矩阵以 6×n矩阵形式返回，其中 n 是末端执行器的自由度数。雅可比将关节空间速度映射到相对于基本坐标系的末端执行器速度。末端执行器速度等于：</p><h4 id="parameters-1">Parameters</h4><h5id="rigid-body-tree-robot-model-twojointrigidbodytree-default-rigidbodytree-object-1">Rigidbody tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTreeobject</h5><p>Robot model, specified as a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object. You can also import a robot model from an URDF (Unified RobotDescription Formation) file using <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>The default robot model, <code>twoJointRigidBodyTree</code>, is arobot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>对象。 您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>从 URDF（统一机器人描述形成）文件导入机器人模型。</p><p>默认机器人模型“twoJointRigidBodyTree”是具有旋转关节和两个自由度的机器人。</p><h5 id="end-effector-end-effector-for-jacobian-body-name">End effector —End effector for Jacobian body name</h5><p>End effector for <code>Jacobian</code>, specified as a body name fromthe <strong>Rigid body tree</strong>robot model. To access body namesfrom the robot model, click <strong>Select body</strong>.</p><p>Jacobian 的末端执行器，指定为刚体树机器人模型中的身体名称。要从机器人模型访问身体名称，请单击选择身体。</p><h5 id="simulate-using-type-of-simulation-to-run">Simulate using — Typeof simulation to run</h5><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB®interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p><h2 id="get-transform-获取转换矩阵">Get Transform 获取转换矩阵</h2><p>Get transform between body frames</p><p>获取身体帧之间的变换</p><ul><li><strong>Library:</strong>Robotics System Toolbox / ManipulatorAlgorithms</li></ul><p><img src="image-20220327140329832.png" alt="image-20220327140329832"  /></p><h3 id="description-2">Description</h3><p>The Get Transform block returns the homogeneous transformationbetween body frames on the <strong>Rigid body tree</strong> robot model.Specify a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object for the robot model, and select a source and target body in theblock.</p><p>The block uses <strong>Config</strong>, the robot configuration(joint positions) input, to calculate the transformation from the sourcebody to the target body. This transformation is used to convertcoordinates from the source to the target body. To convert to basecoordinates, use the base body name as the <strong>Target body</strong>parameter.</p><p>Get Transform 块返回刚体树机器人模型上的身体框架之间的齐次变换。为机器人模型指定一个刚体树对象，并在块中选择一个源体和目标体。</p><p>该块使用Config（机器人配置（关节位置）输入）来计算从源体到目标体的转换。此转换用于将坐标从源体转换为目标体。要转换为基础坐标，请使用基础主体名称作为目标主体参数。</p><h3 id="ports-2">Ports</h3><h4 id="input-2">Input</h4><h5 id="config-robot-configuration-vector-2">Config — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the <strong>Rigid bodytree</strong> parameter. You can also generate this vector for a complexrobot using the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>or<ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a>functions inside a Constant or MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由<strong>刚体树</strong>参数设置。您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>或 [<code>randomConfiguration</code>] 为复杂机器人生成此向量(https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html)函数在 Constant 或 MATLAB Function 块中。</p><h4 id="output-2">Output</h4><h5 id="transform-homogeneous-transform-4-by-4-matrix">Transform —Homogeneous transform 4-by-4 matrix</h5><p>Homogeneous transform, returned as a 4-by-4 matrix. 齐次变换，以 4×4矩阵形式返回。 #### Parameters ##### Rigid body tree — Robot modeltwoJointRigidBodyTree (default) | RigidBodyTree object Robot model,specified as a rigidBodyTree object. You can also import a robot modelfrom an URDF (Unified Robot Description Formation) file usingimportrobot.</p><p>The default robot model, twoJointRigidBodyTree, is a robot withrevolute joints and two degrees of freedom.</p><p>机器人模型，指定为一个刚体树对象。 您还可以使用 importrobot 从URDF（统一机器人描述格式）文件中导入机器人模型。</p><p>默认机器人模型 twoJointRigidBodyTree是具有旋转关节和两个自由度的机器人。</p><h5 id="target-body-target-body-name-body-name"><code>Target body</code>— Target body name body name</h5><p>Target body name, specified as a body name from the robot modelspecified in <strong>Rigid body tree</strong>. To access body names fromthe robot model, click <strong>Select body</strong>. The target frame isthe coordinate system you want to transform points into.</p><p>目标坐标系名称，指定为刚体树中指定的机器人模型的身体名称。要从机器人模型访问身体名称，请单击选择身体。目标框架是您要将点转换到的坐标系。</p><h5 id="source-body-source-body-name-body-name"><code>Source body</code>— Source body name body name</h5><p>Source body name, specified as a body name from the robot modelspecified in <strong>Rigid body tree</strong>.To access body names fromthe robot model, click <strong>Select body</strong>. The source frame isthe coordinate system you want points transformed from.</p><p>源身体名称，指定为刚体树中指定的机器人模型的身体名称。要从机器人模型访问身体名称，请单击选择身体。源框架是您想要转换点的坐标系。</p><h5 id="simulate-using-type-of-simulation-to-run-1">Simulate using —Type of simulation to run</h5><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB®interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p><h2 id="gravity-torque">Gravity Torque</h2><p>Joint torques that compensate gravity</p><p>补偿重力的关节扭矩</p><p><img src="image-20220327154957257.png" alt="image-20220327154957257"  /></p><h3 id="description-3">Description</h3><p>The Gravity Torque block returns the joint torques required to holdthe robot at a given configuration with the current <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html#bvan8uq-1-Gravity">Gravity</a>setting on the <strong>Rigid body tree</strong> robot model.</p><p>Gravity Torque 块返回在刚体树机器人模型上使用当前 Gravity设置将机器人保持在给定配置所需的关节扭矩。</p><h3 id="ports-3">Ports</h3><h4 id="input-3">Input</h4><h5 id="config-robot-configuration-vector-3"><code>Config</code> — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the Rigid body treeparameter. You can also generate this vector for a complex robot usingthe homeConfiguration or randomConfiguration functions inside a Constantor MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由刚体树参数设置。您还可以使用 Constant 或 MATLAB Function 模块中的 homeConfiguration 或randomConfiguration 函数为复杂机器人生成此向量。</p><h4 id="output-3">Output</h4><h5 id="jointtorq-joint-torques-vector-1"><code>JointTorq</code> — Jointtorques vector</h5><p>Joint torques, specified as a vector. Each element corresponds to atorque applied to a specific joint. The number of joint torques is equalto the degrees of freedom (number of nonfixed joints) of the robot.</p><p>关节扭矩，指定为矢量。 每个元素对应于施加到特定关节的扭矩。关节扭矩的数量等于机器人的自由度（非固定关节的数量）。</p><h4 id="parameters-2">Parameters</h4><h5id="rigid-body-tree-robot-model-twojointrigidbodytree-default-rigidbodytree-object-2">Rigidbody tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTreeobject</h5><p>Robot model, specified as a rigidBodyTree object. You can also importa robot model from an URDF (Unified Robot Description Formation) fileusing importrobot.</p><p>The default robot model, twoJointRigidBodyTree, is a robot withrevolute joints and two degrees of freedom.</p><p>机器人模型，指定为一个刚体树对象。 您还可以使用 importrobot 从URDF（统一机器人描述格式）文件中导入机器人模型。</p><p>默认机器人模型 twoJointRigidBodyTree是具有旋转关节和两个自由度的机器人。 ##### Simulate using — Type ofsimulation to run</p><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB®interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> MATLAB仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> MATLAB仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代学习控制</title>
      <link href="/2022/03/24/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/03/24/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代学习控制">迭代学习控制</h3><p>迭代学习控制（iterative learningcontrol，ILC）是智能控制中具有严格数学描述的一个分支。1984年，Arimoto等人提出了迭代学习控制的概念，该控制方法适合于<strong>具有重复运动性质</strong>的被控对象，它不依赖于系统的精确数学模型，能以非常简单的方式处理不确定度相当高的非线性强耦合动态系统。目前，迭代学习控制在学习算法、收敛性、鲁棒性、学习速度及工程应用研究上取得了巨大的进展。近年来，迭代学习控制理论和应用在国外得到快速发展，取得了许多成果。在国内，迭代学习控制理论也得到广泛的重视，有许多重要著作出版，发表了许多综述性论文。</p><span id="more"></span><h4 id="迭代学习控制基本原理">1、迭代学习控制基本原理</h4><p>设被控对象的动态过程为 <span class="math display">\[\dot x(t)=f(x(t),u(t),t), y(t)=g(x(t),u(t),t)\]</span> 其中，<span class="math inline">\(x\in R^n\)</span>、<spanclass="math inline">\(y\in R^m\)</span>、<spanclass="math inline">\(u\inR^r\)</span>分别为系统的状态、输出和输入变量，<spanclass="math inline">\(f(·)\)</span>、<spanclass="math inline">\(g(·)\)</span>为适当维数的向量函数，其结构与参数均未知。若期望控制<spanclass="math inline">\(u_d(t)\)</span>存在，则迭代学习<strong>控制的目标</strong>为：给定期望输出<spanclass="math inline">\(y_d(t)\)</span>和每次运行的初始状态<spanclass="math inline">\(x_k(0)\)</span>，要求在给定的时间<spanclass="math inline">\(t\in[0,T]\)</span>内，按照一定的学习控制算法通过多次重复的运行，使控制输入<spanclass="math inline">\(u_k(t)\rightarrow u_d(t)\)</span>，而系统输出<spanclass="math inline">\(y_k(t)\rightarrow y_d(t)\)</span>。第<spanclass="math inline">\(k\)</span>次运行时，式<spanclass="math inline">\((1)\)</span>表示为 <span class="math display">\[\dot x_k(t)=f(x_k(t),u_k(t),t), y_k(t)=g(x_k(t),u_k(t),t)\]</span> 跟踪误差为 <span class="math display">\[e_k(t)=y_d(t)-y_k(t)\]</span> 迭代学习控制可分为以下开环学习和闭环学习两种方法：</p><p>（1）开环学习控制的方法是：第<spanclass="math inline">\(k+1\)</span>次的控制等于第<spanclass="math inline">\(k\)</span>次控制再加上第<spanclass="math inline">\(k\)</span>次输出误差的校正项，即 <spanclass="math display">\[u_{k+1}(t)=L(u_k(t),e_k(t))\]</span> （2）闭环学习控制的方法是：取第<spanclass="math inline">\(k十1\)</span>次运行的误差作为学习的修正项，即<span class="math display">\[u_{k+1}(t)== L(u_k(t),e_{k+1}(t))\]</span> 其中，L为线性或非线性算子。</p><p><img src="%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0%E6%8E%A7%E5%88%B6/20211203022736652.jpg" alt="20211203022736652" style="zoom:67%;" /></p><h4 id="基本的迭代学习控制算法">2、基本的迭代学习控制算法</h4><p>Arimoto等首先给出了线性时变连续系统的D型迭代学习控制律 <spanclass="math display">\[u_{k+1}(t)=u_k(t)+\Gamma \dot e_k(t)\]</span> 其中，<spanclass="math inline">\(\Gamma\)</span>为常数增益矩阵。在D型算法的基础上，相继出现了P型、PI型、PD型迭代学习控制律。从一般意义来看它们都是PID型迭代学习控制律的特殊形式，PID迭代学习控制律表示为<span class="math display">\[u_{k+1}(t)=u(t)+\Gamma \dot e_k(t)+\Phie_K(T)+\Psi\int_{0}^{t}e_k(\tau)d\tau\]</span> 其中，<span class="math inline">\(\Gamma\)</span>、<spanclass="math inline">\(\Phi\)</span>、<spanclass="math inline">\(\Psi\)</span>为学习增益矩阵。算法中的误差信息使用<spanclass="math inline">\(e_k(t)\)</span>称为开环迭代学习控制，如果使用<spanclass="math inline">\(e_{k+1}(t)\)</span>则称为闭环迭代学习控制，如果同时使用<spanclass="math inline">\(e_k(t)\)</span>和<spanclass="math inline">\(e_{k+1}(t)\)</span>则称为开闭环迭代学习控制。</p><p>此外，还有高阶迭代学习控制算法、最优迭代学习控制算法、遗忘因子迭代学习控制算法和反馈-前馈迭代学习控制算法等。</p><h4 id="迭代学习控制主要分析方法">3、迭代学习控制主要分析方法</h4><p>学习算法的收敛性分析是迭代学习控制的核心问题，这方面的研究成果很丰富。</p><p>1、基本的收敛性分析方法</p><p>对于如下线性离散系统： <span class="math display">\[\left\{\begin{matrix}x(t+1)=Ax(t)+Bu(t) \\y(t)=Cx(t)\end{matrix}\right.\]</span> 迭代学习控制算法为 <span class="math display">\[u_{k+1}(t)=u_k(t)+\Gamma e_k(t+1)\]</span> 针对学习算法式<spanclass="math inline">\((9)\)</span>的收敛性，有以下两种分析方法：</p><p>（1）压缩映射方法：即系统要求满足全局<spanclass="math inline">\(Lipschitz\)</span>条件和相同的初始条件，如果 <spanclass="math inline">\(||I-CBT||&lt;1\)</span>,则有 <spanclass="math display">\[\parallele_{K+1}\parallel=\parallel(I-CB\Gamma)e_K\parallel&lt;\parallelI-CB\Gamma\parallel \parallel e_k\parallel&lt;\parallel e_k\parallel\]</span> 此时算法是单调收敛的。该方法依赖于范数的选择，常用的有<spanclass="math inline">\(l_1\)</span>范数、<spanclass="math inline">\(l_2\)</span>范数、<spanclass="math inline">\(l_\infty\)</span>范数 及<spanclass="math inline">\(\lambda\)</span>范数。在收敛性证明过程中常用到<spanclass="math inline">\(Bellman-Gronwall\)</span>引理。</p><p>（2）谱半径条件法：如果谱半径<spanclass="math inline">\(\rho\)</span>满足<spanclass="math inline">\(\rho(I-CB\Gamma)\leq \rho &lt;1\)</span>，则有<span class="math display">\[\lim_{k \to \infty}\parallel e_k \parallel = \lim_{k \to \infty}\parallel(I- CB\Gamma)e_{k-1}\parallel = \lim_{k \to \infty}\rho(I-CB\Gamma)^k\parallel e \parallel\]</span> 即$ _ {k }e_k$。</p><p>2、基于2-D理论的分析方法</p><p>迭代学习控制系统的学习是按两个相互独立的方向进行：时间轴方向和迭代次数轴方向，因此选代学习过程本质上是二维系统，可利用成熟的2-D系统理论系统地研究和分析时间域的稳定性和迭代次数域的收敛性问题。2-D系统的稳定性理论为迭代学习控制的收敛性证明提供了一种非常有效的方法，2-D系统理论中的Roesser模型成为迭代学习控制中最基本的分析模型。</p><p>3.基于Lyapunov直接法的设计方法</p><p>Lyapunov直接法已广泛用于非线性动态系统的控制器设计和分析中，在研究非线性不确定系统时，该方法是最重要的应用工具之一。受Lyapunov直接法的启发，在时间域和迭代域能量函数的概念得到研究，它为学习控制在迭代域设计和收敛性分析方面提供了一种新的研究方法。</p><p>在迭代域能量函数的迭代学习控制方法基础上，发展了鲁棒和自适应迭代学习控制，可解决具有参数或非参数不确定性非线性系统控制器的设计，近年来反映时间域和迭代域系统能量的组合能量函数方法也应用于迭代学习控制，它可保证在迭代域跟踪误差的渐近收敛以及在时间域具有有界和逐点跟踪的动态特性，并且控制输入在整个迭代区间内是范数收敛的，适用于一类不具有全局Lipschitz条件的非线性系统。通过能量函数的方法，许多新的控制方法，如反演设计和非线性优化方法都作为系统设计工具应用到迭代学习控制中。此外，还有最优化分析方法、频域分析法等分析方法。#### 4、选代学习控制的关键技术 1.学习算法的稳定性和收敛性</p><p>稳定性与收敛性是研究当学习律与被控系统满足什么条件时，选代学习控制过程才是稳定收敛的。算法的稳定性保证了随着学习次数的增加，控制系统不发散，但是对于学习控制系统而言，仅仅稳定是没有实际意义的，只有使学习过程收敛到真值，才能保证得到的控制为某种意义下最优的控制。收敛是对学习控制的最基本要求，多数学者在提出新的学习律的同时，基于被控对象的一些假设，给出了收敛的条件。例如，Arimoto在最初提出PID型学习控制律时，仅针对线性系统在D型学习律下的稳定性和收敛条件作了证明。</p><p>2.初始值问题</p><p>运用迭代学习控制技术设计控制器时，只需要通过重复操作获得的受控对象的误差或误差导数信号。在这种控制技术中，迭代学习总要从某初始点开始，初始点指初始状态或初始输出。几乎所有的收敛性证明都要求初始条件是相同的，解决选代学习控制理论中的初始条件问题一直是人们追求的目标之一。目前已提出的迭代学习控制算法大多数要求被控系统每次运行时的初始状态在期望轨迹对应的初始状态上，即满足初始条件：<span class="math display">\[x_k(0)=x_d(0),k=0,1,2,…\]</span>当系统的初始状态不在期望轨迹上，而在期望轨迹的某一很小的邻域内时，通常把这类问题归结为学习控制的鲁棒性问题研究。</p><p>3.学习速度问题</p><p>在迭代学习算法研究中，其收敛条件基本上都是在学习次数<spanclass="math inline">\(k→\infty\)</span>下给出的。而在实际应用场合，学习次数<spanclass="math inline">\(k→\infty\)</span>显然是没有任何实际意义的。因此，如何使迭代学习过程更快地收敛于期望值是迭代学习控制研究中的另一个重要问题。ILC本质上是一种前馈控制技术，大部分学习律尽管证明了学习收敛的充分条件，但收敛速度还是很慢。可利用多次学习过程中得到的知识来改进后续学习过程的速度，例如，采用高阶迭代控制算法、带遗忘因子的学习律、利用当前项或反馈配置等方法来构造学习律，可使收敛速度大大加快。</p><p>4.鲁棒性问题</p><p>迭代学习控制理论的提出有浓厚的工程背景，因此仅仅在无干扰条件下过论收敛性问题是不够的，还应讨论存在各种干扰的情形下系统的跟踪性能。一个实际运行的迭代学习控制系统除了存在初始偏移外，还或多或少存在状态扰动、测量噪声、输入扰动等各种干扰。鲁棒性问题讨论存在各种干扰时迭代学习控制系统的跟踪性能。具体地说，一个迭代学习控制系统是鲁棒的，指系统在各种有界干扰的影响下，其迭代轨迹能收敛到期望轨迹的邻域内，而当这些干扰消除时，迭代轨迹会收敛到期望轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械臂的PD控制</title>
      <link href="/2022/03/23/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84PD%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/03/23/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84PD%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="机械臂的pd控制">机械臂的PD控制</h3><h3 id="控制率设计">1 控制率设计</h3><p>当忽略重力和外部干扰的时候，采用独立的PD控制，可以满足机械臂的定点控制的要求。</p><span id="more"></span><p>设n关节机械臂的动力学方程为 <span class="math display">\[D(q)\ddot q+ C(q,\dot q)\dot q=\tau\]</span> 其中，<span class="math inline">\(D(q)\)</span>为$nn <spanclass="math inline">\(正定惯性矩阵，\)</span>C(q,q)<spanclass="math inline">\(为\)</span>nn$的离心和哥氏力项。</p><p>独立的PD控制率为 <span class="math display">\[\tau =K_d\dot e +K_pe\]</span> 取跟踪误差为<spanclass="math inline">\(e=q_d-q\)</span>，采用定点控制时，<spanclass="math inline">\(q_d\)</span>为常值，则<spanclass="math inline">\(\dot q_d=\ddot q_d\equiv 0\)</span></p><p>此时，机械臂方程为 <span class="math display">\[D(q)(\ddot q_d-\ddot q)+C(q,\dot q)(\dot q_d - \dot q)+K_d\dot e +K_pe=0\]</span> 即 <span class="math display">\[D(q)\ddot e+C(q,\dot q)\dot e +K_pe=-K_d\dot e\]</span> 取Lyapunov李雅普诺夫函数为 <span class="math display">\[V= \frac{1}{2}\dot e^TD(q)\dot e+\frac{1}{2}e^TK_pe\]</span> 由<span class="math inline">\(D(q)\)</span>和<spanclass="math inline">\(K_p\)</span>的正定性可知，<spanclass="math inline">\(V\)</span>是全局正定的，则 <spanclass="math display">\[\dot V=\dot e^TD\ddot e+\frac{1}{2}\dot e^T\dot D\dot e+\dot e^TK_pe\]</span> 利用<span class="math inline">\(\dot D-\ddot2C\)</span>的斜对称性可知，<span class="math inline">\(\dot e^TD\ddote=2\dot e^TC\ddot e\)</span>则 <span class="math display">\[\dot V=\dot e^TD\ddot e+\dot e^T C\dot e+\dot e^TK_pe=\dot e^T(D\ddote+C\dot e+K_p e)=-\dot e^TK_d\dot e \leq 0\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输出受限引理</title>
      <link href="/2022/03/22/%E8%BE%93%E5%87%BA%E5%8F%97%E9%99%90%E5%BC%95%E7%90%86/"/>
      <url>/2022/03/22/%E8%BE%93%E5%87%BA%E5%8F%97%E9%99%90%E5%BC%95%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在实际系统的控制系统中，为了保证系统的安全性，通常会对系统的输出的上下界做出严格的限制，或者要求系统的超调量在一定的范围内，超调量过大往往意味着系统处于不理想的运行状态，某些情况下，会对系统本身产生不可预知的影响。</p><span id="more"></span><h4 id="引理1.1">引理1.1</h4><p>针对系统误差 <span class="math display">\[\dot{z}=f(t,z), z=[z_1,z_2]^T\]</span> 存在连续可微的正定函数<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>，<spanclass="math inline">\(k_b&gt;0\)</span>,位置输出为<spanclass="math inline">\(X_1\)</span>,定义为位置误差<spanclass="math inline">\(z_1=x_1-y_d\)</span>，满足</p><p>（1）当<span class="math inline">\(z_1\rightarrow-k_b\)</span>或<spanclass="math inline">\(z_1\rightarrow k_b\)</span>时，有<spanclass="math inline">\(V_1(z_1)\rightarrow \infty\)</span>；</p><p>（2）<span class="math inline">\(\gamma_1(|| z_2||)\leqV_2(z_2)\leq\gamma_2(||z_2||))\)</span>,<spanclass="math inline">\(\gamma_1\)</span>为<spanclass="math inline">\(\gamma_2\)</span>为<spanclass="math inline">\(K_\infty\)</span>类函数；</p><p>假设</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adaptive Neural Network Control of a Robotic Manipulator With Time-V arying Output Constraints</title>
      <link href="/2022/03/21/Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints/"/>
      <url>/2022/03/21/Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints/</url>
      
        <content type="html"><![CDATA[<h3id="adaptive-neural-network-control-of-a-robotic-manipulator-with-time-v-arying-output-constraints">AdaptiveNeural Network Control of a Robotic Manipulator With Time-V aryingOutput Constraints</h3><h3id="带时变输出约束的机械臂自适应神经网络控制">带时变输出约束的机械臂自适应神经网络控制</h3><span id="more"></span><h4 id="摘要">摘要</h4><p>研究了不确定n自由度机器人机械臂受时变输出约束的控制问题。将刚性机械臂系统描述为多输入多输出的非线性系统。我们设计了一个干扰观测器来估计来自人类和环境的未知干扰。为了解决不确定性问题，采用径向基函数的神经网络对机械臂的未知动力学进行估计。在控制设计过程中，采用了非对称势垒(障碍)李雅普诺夫函数，避免了输出约束的时变。仿真结果验证了该控制方案的有效性。</p><p>Adaptive neural network (NN) control, barrier</p><p>Lyapunov function (BLF), disturbance observer (DO)</p><h4 id="论文拟解决的主要问题"><strong>论文拟解决的主要问题</strong></h4><p>机器人系统的输入输出普遍存在饱和、死区、安全规范等约束。由于现在要求机器人与人类和环境有更多的物理互动，违反这些约束所产生的安全问题是不可忽视的。因此，我们需要设计有针对性的控制器来处理这些问题。在人与环境的相互作用下，对未知的动力学和未知的扰动的不确定机械臂的控制具有挑战性。</p><p>传统的李雅普诺夫函数的目标是实现有保证的全局或半全局稳定性，而在本文中，我们不仅要保证系统的半全局稳定性，而且要避免时变约束的冲突。研究中常见的约束通常是常数约束，而常数约束可以看作是一种特殊的时变约束，因此时变约束的研究更为实际。现有的大量论文考虑了无约束的非线性系统、具有输入约束的非线性系统、具有恒定输出约束的非线性系统，或具有时变输出约束的某些SISO非线性系统。因此，需要解决MIMO未知机器人系统在未知扰动和时变输出约束下的控制问题</p><h4 id="论文主要研究内容"><strong>论文主要研究内容</strong></h4><p>利用自适应神经网络对机械臂系统的不确定动力学进行补偿。在控制设计过程中利用非对称blf（障碍李雅普诺夫函数）来克服输出约束的时变问题。本文的主要贡献如下:</p><p>1)通过基于神经网络的自适应控制律，成功地补偿了系统不确定性的影响，提高了机器人系统的鲁棒性。</p><p>2)将神经网络估计误差与来自人、环境的未知干扰集成为一个组合干扰，最后由DO逼近。</p><p>3)为了避免时变约束的冲突，采用非对称blf设计控制律，成功实现了渐近跟踪。</p><h4 id="论文的算法"><strong>论文的算法</strong></h4><p><img src="1.png" alt="1"  /></p><p><img src="2.png" alt="2" style="zoom:67%;" /></p><p>控制目标就是设计控制率，使得输出可以跟踪轨迹q，同时不能违反时变输出约束，如果给出了时变的边界，kc和kc-，输出qt就应该在这个边界内。</p><p><img src="3.png" alt="3" style="zoom: 80%;" /></p><h4 id="控制算法设计"><strong>控制算法设计</strong></h4><p>使用神经网络来弥补系统不确定性的影响，并使用时变的blf来避免时变约束的冲突。我们定义了一种新的由神经网络估计误差和来自人类和环境的未知外部干扰组成的复合干扰，该复合干扰由DO估计。控制策略如图2所示。</p><p><img src="4.png" alt="4"  /></p><p><img src="5.png" alt="5"  /></p><p>定义了误差变量z1和误差变量的导数。还定义了一个新的误差变量z2，γ是辅助变量。</p><h4 id="结论"><strong>结论</strong></h4><p>我们考虑一个如图3所示的三自由度机器人机械手。该机器人有两个旋转关节和一个移动关节。手腕的位置是由两个旋转关节和一个移动关节(RRP)的两次旋转和一次平移决定的。为了验证该控制方法的有效性，对一个三自由度机器人系统进行了仿真。我们定义</p><p><img src="6.png" alt="6"  /></p><p><img src="7.png" alt="7"  /></p><p><img src="8.png" alt="8"  /></p><p><img src="9.png" alt="9"  /></p><p><img src="10.png" alt="10"  /></p><p>仿真使用了三种不同的控制率，第一个是基于模型的控制，第二个使用自适应神经网络的控制，第三个使用传统的pd控制。</p><p><img src="11.png" alt="11"  /></p><p>可以看出，输出的q可以精确地跟踪期望的轨迹qd。由图5-7可知，跟踪误差z11、z12、z13收敛到一个接近零的小值</p><p>针对一类受时变约束和未知干扰的不确定n-DOF机器人，提出了一种基于DOs的自适应神经网络控制方法。我们用神经网络估计机器人的未知动力学模型，用DOs逼近时变扰动。使用非对称BLF避免与输出约束的冲突。仿真结果表明，所提出的控制方案能在保证约束条件满足的情况下，使输出很好地跟随目标轨迹。</p><p><img src="12.png" alt="12"  /></p><p><img src="13.png" alt="13"  /></p><p>与此同时，它们的约束从未被打破。图8给出了控制输入力矩τ1、τ2和τ3。DO的近似误差如图9所示。我们可以看到，DO估计误差越来越小，最后接近于零。综上所述，本文提出的基于模型的控制方法取得了满意的控制效果。</p><p>但是，基于模型的控制律是在已知机械臂系统的精确参数的基础上建立起来的，而这些参数在实际操作中通常是未知的</p><p>对于神经网络控制律，图10表明，输出q可以在很小的误差下遵循期望的轨迹qd。由图11-13可知，跟踪误差z11、z12、z13收敛到一个接近零的小值。同时，它们都明显排斥时变边界−ka(t)和kb(t)，即不违反输出约束</p><p>Fg18表明输出q可以大致跟随所需轨迹qd，但从图20和图21可以明显看出，q2和q3的约束被打破了。图22给出了PD控制输入力矩，从中我们可以看到输入是有界的。</p><p>控制目标就是设计控制率，使得输出可以跟踪轨迹q，同时不能违反时变输出约束，如果给出了时变的边界，kc和kc-，输出qt就应该在这个边界内。</p><p><img src="14.png" alt="14"  /></p><p><img src="15.png" alt="15"  /></p><p><img src="16.png" alt="16"  /></p><p><img src="17.png" alt="17"  /></p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 论文阅读笔记 </category>
          
          <category> 英文论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 论文，英文论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械臂相关论文列表</title>
      <link href="/2022/03/21/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/"/>
      <url>/2022/03/21/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="论文列表">论文列表</h3><p>​ 1、Z. Yang, W. Lu, Z. Yao and B. Zhang, "Neuroadaptive backsteppingtracking control of robotic manipulators considering actuator dynamics,"The 27th Chinese Control and Decision Conference (2015 CCDC), 2015, pp.465-470, doi: 10.1109/CCDC.2015.7161737.</p><p>考虑执行器动力学的机器人神经自适应反步跟踪控制</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 论文列表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
