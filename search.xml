<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Revolute Joint 模块</title>
      <link href="/2022/03/31/Revolute-Joint-%E6%A8%A1%E5%9D%97/"/>
      <url>/2022/03/31/Revolute-Joint-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="revolute-joint-模块">Revolute Joint 模块</h2><p>Joint with one revolute primitive 一个初试的旋转关节</p><ul><li><strong>Library:</strong>Simscape / Multibody / Joints</li></ul><h3 id="description">Description</h3><p>The Revolute Joint block models a joint that has one rotationaldegree of freedom.</p><p>Revolute Joint 模块模拟具有一个旋转自由度的关节。</p><p><img src="Revolute-Joint-%E6%A8%A1%E5%9D%97.assets/image-20220331122431883.png" alt="image-20220331122431883" style="zoom:150%;" /></p><p>The joint constrains the motion of two arbitrary frames that connectto the base and follower frames of the joint to pure rotation about acommon axis. The axis of rotation is aligned with the <em>z</em>-axis ofthe joint base frame. The base and follower frames have a common originand <em>z</em>-axis, and the follower frame rotates about the<em>z</em>-axis, as shown in the image.</p><p>关节将连接到关节的基础框架和从动框架的两个任意框架的运动限制为围绕公共轴进行纯旋转。旋转轴与关节基础框架的 z 轴对齐。如图所示，基础框架和跟随框架具有共同的原点和 z 轴，并且跟随框架围绕 z轴旋转。</p><p><img src="Revolute-Joint-%E6%A8%A1%E5%9D%97.assets/image-20220331122451755.png" alt="image-20220331122451755" style="zoom:150%;" /></p><p>To target the initial state of the a joint primitive, use theparameters under <strong>State Targets</strong>. The position andvelocity targets are resolved in the base frame. You can also set thepriority levels for the targets. If the block cannot simultaneouslysatisfy the state targets, the priority level determines which targetsto satisfy first and how closely to satisfy them. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/assembling-multibody-systems.html#busaiy6-1">GuidingAssembly</a> for more information.</p><p>要定位关节图元的初始状态，请使用 <strong>State Targets</strong>下的参数。 位置和速度目标在基本框架中解析。 您还可以设置目标的优先级。如果块不能同时满足状态目标，则优先级确定首先满足哪些目标以及满足这些目标的程度。更多信息见【指导组装】(https://ww2.mathworks.cn/help/physmod/sm/ug/assemble-multibody-systems.html#busaiy6-1)。</p><p>To model damping and spring behavior in a joint primitive, use theparameters under <strong>Internal Mechanics</strong>. Specify jointdamping coefficients to model energy dissipation and joint springstiffness to model energy storage. Springs resist attempts to displacethe joint primitive from its equilibrium position. Joint dampers act asenergy dissipation elements. Springs and dampers are strictlylinear.</p><p>要模拟关节基本体中的阻尼和弹簧行为，请使用内部力学下的参数。指定关节阻尼系数来模拟能量耗散和关节弹簧刚度来模拟能量存储。弹簧抵抗试图将关节基元从其平衡位置移开的尝试。关节阻尼器充当能量耗散元件。 弹簧和阻尼器是严格线性的。</p><p>To specify the limits of a joint primitive, use the parameters under<strong>Limits</strong>. The lower and upper bounds define the width ofthe free region of a joint primitive. The block applies a force ortorque to accelerate the joint position back to the free region when theposition exceeds the bounds. The block uses a smoothed spring-dampermethod to compute the force or torque. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ref/spatialcontactforce.html#mw_acd246fe-915a-4822-9c50-b9aa9debb1ce">Description</a>section of the <ahref="https://ww2.mathworks.cn/help/physmod/sm/ref/spatialcontactforce.html">SpatialContact Force</a> block for more information about the smoothedspring-damper method.</p><p>要指定关节基本体的限制，请使用“限制”下的参数。下限和上限定义了关节图元的自由区域的宽度。当位置超出界限时，该块会施加力或扭矩以将关节位置加速回到自由区域。该块使用平滑弹簧阻尼器方法来计算力或扭矩。有关平滑弹簧阻尼器方法的更多信息，请参见空间接触力模块的描述部分。</p><p>A revolute primitive provides two actuation parameters,<strong>Torque</strong> and <strong>Motion</strong>, that govern themotion of the primitive during a simulation. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/joint-actuation.html">SpecifyingJoint Actuation Inputs</a> for more information. Additionally, the blockhas ports that output sensing data, such as position, velocity,acceleration, forces, and torques, that enable you to perform analyticaltasks on a model. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/sensing.html">Sensing</a>and <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><p>旋转基元提供两个驱动参数，扭矩和运动，它们在模拟过程中控制基元的运动。有关详细信息，请参阅指定关节驱动输入。此外，该模块具有输出传感数据的端口，例如位置、速度、加速度、力和扭矩，使您能够对模型执行分析任务。有关详细信息，请参阅传感和力和扭矩传感。</p><h3 id="ports">Ports</h3><h4 id="frame">Frame</h4><h5 id="b-base-frame"><code>B</code> — Base frame</h5><p>Base frame of the joint block.</p><h5 id="f-follower-frame"><code>F</code> — Follower frame</h5><p>Follower frame of the joint block.</p><h4 id="input">Input</h4><h5id="t-actuation-torque-physical-signal-驱动扭矩物理信号"><code>t</code>— Actuation torque physical signal 驱动扭矩物理信号</h5><p>Physical signal input port that accepts the actuation torque for thejoint primitive. The signal provides the value of the torque thatapplies on both the base and follower frames of the joint primitive.</p><h6 id="dependencies">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Actuation</strong>, set <strong>Torque</strong> to<code>Provided by Input</code>.</p><p>接受关节图元的驱动扭矩的物理信号输入端口。该信号提供了应用于关节图元的基础框架和从动框架的扭矩值。</p><p>依赖项</p><p>要启用此端口，请在 Z Revolute Primitive (Rz) &gt; Actuation 下，将Torque 设置为由 Input 提供。</p><h5 id="q-motion-profile-physical-signal"><code>q</code> — Motionprofile physical signal</h5><p>Physical signal input port that accepts the motion profile for thejoint primitive. The signal provides the rotation of the follower framewith respect to the base frame about the joint primitive axis. Note thatthe signal must also contain the first and second derivatives of therotation.</p><h6 id="dependencies-1">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Actuation</strong>, set <strong>Motion</strong> to<code>Provided by Input</code>.</p><p>物理信号输入端口，接受关节基元的运动轮廓。该信号提供了从动框架相对于基本框架绕关节图元轴的旋转。请注意，信号还必须包含旋转的一阶和二阶导数。</p><h6 id="依赖项">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Actuation</strong> 下，将 <strong>Motion</strong> 设置为<code>Provided by Input</code>。</p><h5id="mode-joint-mode-control-scalar-关节模式控制标量"><code>mode</code> —Joint mode control scalar 关节模式控制标量</h5><p>Input port that controls the joint mode. The signal is a unitlessscalar. The joint mode is normal when the input signal is 0 anddisengaged when the input signal is -1. The joint mode can be changedmany times during a simulation.</p><h6 id="dependencies-2">Dependencies</h6><p>To enable this port, under <strong>Mode Configuration</strong>, set<strong>Mode</strong> to <code>Provided by Input</code>.</p><p>控制关节模式的输入端口。 信号是无单位标量。输入信号为0时关节模式正常，输入信号-1时关节模式断开。在模拟过程中可以多次更改关节模式。</p><h6 id="依赖项-1">依赖项</h6><p>要启用此端口，请在 <strong>Mode Configuration</strong> 下，将<strong>Mode</strong> 设置为 <code>Provided by Input</code>。</p><h4 id="output">Output</h4><h5id="q-position-of-joint-primitive-physical-signal-关节原始物理信号的位置"><code>q</code>— Position of joint primitive physical signal关节原始物理信号的位置</h5><p>Physical signal port that outputs the position of the jointprimitive. The value is the rotation angle of the follower frame withrespect to the base frame.</p><h6 id="dependencies-3">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Position</strong>.</p><p>输出关节图元位置的物理信号端口。该值是从动框架相对于基础框架的旋转角度。</p><h6 id="依赖项-2">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Position</strong>。</p><h5id="w-first-derivative-of-position-of-joint-primitive-physical-signal"><code>w</code>— First derivative of position of joint primitive physical signal</h5><p>Physical signal port that outputs the first derivative of position ofthe joint primitive.</p><h6 id="dependencies-4">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Velocity</strong>.</p><p>输出关节图元位置的一阶导数的物理信号端口。</p><h6 id="依赖项-3">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Velocity</strong>。</p><h5id="b-second-derivative-of-position-of-joint-primitive-physical-signal"><code>b</code>— Second derivative of position of joint primitive physical signal</h5><p>关节原始物理信号位置的二阶导数</p><p>Physical signal port that outputs the second derivative of positionof the joint primitive.</p><h6 id="dependencies-5">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Acceleration</strong>.</p><p>输出关节图元位置二阶导数的物理信号端口。</p><h6 id="依赖项-4">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Acceleration</strong>。</p><h5id="t-actuator-torque-acting-on-joint-primitive-physical-signal"><code>t</code>— Actuator torque acting on joint primitive physical signal</h5><p>Physical signal port that outputs the actuator torque acting on thejoint primitive.</p><h6 id="dependencies-6">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>ActuatorTorque</strong>.</p><p>输出作用在关节基元上的执行器扭矩的物理信号端口。</p><h6 id="依赖项-5">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Actuator Torque</strong>。</p><h5 id="tll-lower-limit-torque-physical-signal"><code>tll</code> —Lower-limit torque physical signal</h5><p>Physical signal port that outputs the lower-limit torque. The blockapplies the torque when the joint primitive position exceeds the lowerbound of the free region. The torque applies to both the base andfollower frames of the joint primitive to accelerate the position backto the free region.</p><h6 id="dependencies-7">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Lower-LimitTorque</strong>.</p><p>输出下限扭矩的物理信号端口。当关节基元位置超过自由区域的下限时，该模块将应用扭矩。扭矩适用于关节图元的基础框架和跟随框架，以将位置加速回到自由区域。</p><h6 id="依赖项-6">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Lower-LimitTorque</strong>。</p><h5 id="tul-upper-limit-torque-physical-signal"><code>tul</code> —Upper-limit torque physical signal</h5><p>Physical signal port that outputs the upper-limit torque. The blockapplies the torque when the joint primitive position exceeds the upperbound of the free region. The torque applies to both the base andfollower frames of the joint primitive to accelerate the position backto the free region.</p><h6 id="dependencies-8">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Upper-LimitTorque</strong>.</p><p>输出上限扭矩的物理信号端口。当关节基元位置超过自由区域的上限时，该模块将应用扭矩。扭矩适用于关节图元的基础框架和跟随框架，以将位置加速回到自由区域。</p><h6 id="依赖项-7">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Upper-LimitTorque</strong>。</p><h5 id="fc-constraint-force-physical-signal"><code>fc</code> —Constraint force physical signal</h5><p>Physical signal port that outputs constraint force that acts in thejoint. The force maintains the translational constraints of the joint.See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/sense-internal-forces-in-double-pendulum-link.html">SenseConstraint Forces</a> for more information.</p><h6 id="dependencies-9">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Constraint Force</strong>.</p><p>输出作用于关节的约束力的物理信号端口。 力保持关节的平移约束。更多信息参见【感知约束力】(https://ww2.mathworks.cn/help/physmod/sm/ug/sense-internal-forces-in-double-pendulum-link.html)。</p><h6 id="依赖项-8">依赖项</h6><p>要启用此端口，请在 <strong>Composite Force/Torque Sensing</strong>下，选择 <strong>Constraint Force</strong>。</p><h5 id="tc-constraint-torque-physical-signal"><code>tc</code> —Constraint torque physical signal</h5><p>Physical signal port that outputs constraint torque that acts in thejoint. The torque maintains the rotational constraints of the joint. See<ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><h6 id="dependencies-10">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Constraint Torque</strong>.</p><p>输出作用于关节的约束扭矩的物理信号端口。 扭矩保持关节的旋转约束。有关详细信息，请参阅力和扭矩传感。</p><h6 id="依赖项-9">依赖项</h6><p>要启用此端口，请在 Composite Force/Torque Sensing 下选择 ConstraintTorque。</p><h5 id="ft-total-force-physical-signal"><code>ft</code> — Total forcephysical signal</h5><p>Physical signal port that outputs the total force that acts in thejoint. The total force is the sum of the forces transmitted from oneframe to the other through the joint. The force includes actuation,internal, limit and constraint forces. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><h6 id="dependencies-11">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Total Force</strong>.</p><p>输出作用于关节的总力的物理信号端口。总力是通过关节从一帧传递到另一帧的力的总和。力包括驱动力、内部力、限制力和约束力。更多信息请参见【力和扭矩传感】（https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。###### 依赖项 要启用此端口，请在 <strong>Composite Force/TorqueSensing</strong> 下，选择 <strong>Total Force</strong>。</p><h5 id="tt-total-torque-physical-signal"><code>tt</code> — Total torquephysical signal</h5><p>Physical signal port that outputs the total torque that acts in thejoint. The total torque is the sum of the torques transmitted from oneframe to the other through the joint. The torque includes actuation,internal, limit, and constraint torques. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><h6 id="dependencies-12">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Total Torque</strong>.</p><p>输出作用于关节的总扭矩的物理信号端口。总扭矩是从一个框架通过关节传递到另一个框架的扭矩之和。扭矩包括致动扭矩、内部扭矩、限制扭矩和约束扭矩。更多信息请参见【力和扭矩传感】（https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。</p><h6 id="依赖项-10">依赖项</h6><p>要启用此端口，请在 <strong>Composite Force/Torque Sensing</strong>下，选择 <strong>Total Torque</strong>。</p><h3 id="parameters">Parameters</h3><h4 id="z-revolute-primitive-rz">Z Revolute Primitive (Rz)</h4><h5id="state-targets-specify-position-target-whether-to-specify-position-target-off-default-on"><code>State Targets &gt; Specify Position Target</code>— Whether to specify position target <code>off</code> (default) |<code>on</code></h5><p>State Targets &gt; Specify PositionTarget<code>— 是否指定位置目标</code>off<code>（默认） |</code>开</p><p>Select this parameter to enable parameters that specify the positiontarget of the joint primitive.</p><p>选择此参数以启用指定关节图元位置目标的参数。</p><h5id="state-targets-specify-position-target-priority-priority-level-of-position-target-high-desired-default-low-approximate"><code>State Targets &gt; Specify Position Target &gt; Priority</code>— Priority level of position target <code>High (desired)</code>(default) | <code>Low (approximate)</code></h5><p>状态目标 &gt; 指定位置目标 &gt; 优先级 -位置目标的优先级高（需要）（默认）| 低（大约）</p><p>Priority level of the position target, specified as<code>High (desired)</code> or <code>Low (approximate)</code>.</p><h6 id="dependencies-13">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Position Target</strong>.</p><p>位置目标的优先级，指定为“高（期望）”或“低（近似）”。</p><h6 id="依赖项-11">依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>State Targets</strong> 下，选择 <strong>Specify PositionTarget</strong>。</p><h5id="state-targets-specify-position-target-value-angle-of-position-target-0-deg-default-scalar-with-a-unit-of-angle"><code>State Targets &gt; Specify Position Target &gt; Value</code>— Angle of position target 0 <code>deg</code> (default) | scalar with aunit of angle</h5><p>Angle to specify the position target, specified as a scalar with aunit of angle.</p><h6 id="dependencies-14">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Position Target</strong>.</p><p>指定位置目标的角度，指定为以角度为单位的标量。</p><p>依赖项 要启用此参数，请在 Z Revolute Primitive (Rz) &gt; StateTargets 下选择指定位置目标。</p><h5id="state-targets-specify-velocity-target-whether-to-specify-velocity-target-off-default-on"><code>State Targets &gt; Specify Velocity Target</code>— Whether to specify velocity target <code>off</code> (default) |<code>on</code></h5><p>Select this parameter to enable parameters for that specify thevelocity target of the joint primitive.</p><p>选择此参数以启用指定关节图元的速度目标的参数。</p><h5id="state-targets-specify-velocity-target-priority-priority-level-of-velocity-target-high-desired-default-low-approximate"><code>State Targets &gt; Specify Velocity Target &gt; Priority</code>— Priority level of velocity target <code>High (desired)</code>(default) | <code>Low (approximate)</code></h5><p>Priority level of the velocity target, specified as<code>High (desired)</code> or <code>Low (approximate)</code>.</p><h6 id="dependencies-15">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Velocity Target</strong>.</p><p>速度目标的优先级，指定为“高（期望）”或“低（近似）”。</p><h6 id="依赖项-12">依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>State Targets</strong> 下，选择 <strong>Specify VelocityTarget</strong>。</p><h5id="state-targets-specify-velocity-target-value-velocity-target-of-joint-primitive-0-degs-default-scalar-with-unit-of-angular-velocity"><code>State Targets &gt; Specify Velocity Target &gt; Value</code>— Velocity target of joint primitive 0 <code>deg/s</code> (default) |scalar with unit of angular velocity</h5><p>Velocity target of the joint primitive, specified as a scalar with aunit of angular velocity.</p><h6 id="dependencies-16">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Velocity Target</strong>.</p><p>关节图元的速度目标，指定为具有角速度单位的标量。</p><h6 id="依赖项-13">依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>State Targets</strong> 下，选择 <strong>Specify VelocityTarget</strong>。</p><h5id="internal-mechanics-equilibrium-position-position-where-internal-torque-is-zero-0-deg-default-scalar-with-unit-of-angle"><code>Internal Mechanics &gt; Equilibrium Position</code>— Position where internal torque is zero 0 <code>deg</code> (default) |scalar with unit of angle</h5><p>内部扭矩为零的位置 0 <code>deg</code>（默认）| 以角度为单位的标量</p><p>Position where the spring torque is zero, specified as a scalar witha unit of angle. The value specifies the rotation angle of the followerframe with respect to the base frame.</p><p>弹簧扭矩为零的位置，指定为具有角度单位的标量。该值指定从动框架相对于基础框架的旋转角度。</p><h5id="internal-mechanics-spring-stiffness-stiffness-of-force-law-0-nmdeg-default-scalar-with-unit-of-stiffness"><code>Internal Mechanics &gt; Spring Stiffness</code>— Stiffness of force law 0 <code>N*m/deg</code> (default) | scalar withunit of stiffness</h5><p>Stiffness of the internal spring-damper force law for the jointprimitive, specified as a scalar with a unit of stiffness.</p><p>关节基元的内部弹簧阻尼力定律的刚度，指定为具有刚度单位的标量。</p><h5id="internal-mechanics-damping-coefficient-damping-coefficient-of-force-law-0-nmdegs-default-scalar-with-unit-of-damping-coefficient"><code>Internal Mechanics &gt; Damping Coefficient</code>— Damping coefficient of force law 0 <code>N*m/(deg/s)</code> (default)| scalar with unit of damping coefficient</h5><p>Damping coefficient of the internal spring-damper force law for thejoint primitive, specified as a scalar with a unit of dampingcoefficient.</p><p>关节基元的内部弹簧-阻尼力定律的阻尼系数，指定为具有阻尼系数单位的标量。</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> MATLAB仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> MATLAB仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simulink机器人仿真库</title>
      <link href="/2022/03/27/simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93/"/>
      <url>/2022/03/27/simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h4 id="simulink机器人仿真库">simulink机器人仿真库</h4><p>[TOC]</p><span id="more"></span><h2 id="forward-dynamics-正向动力学">Forward Dynamics 正向动力学</h2><p>给定关节扭矩和状态的关节加速度</p><p><strong>Library:</strong> Robotics System Toolbox / ManipulatorAlgorithm</p><p><img src="image-20220327131159671.png" alt="image-20220327131159671"  /></p><h3 id="description">Description</h3><p>The Forward Dynamics block computes joint accelerations for a robotmodel given a robot state that is made up of joint torques, jointstates, and external forces. To get the joint accelerations, specify therobot configuration (joint positions), joint velocities, appliedtorques, and external forces.</p><p>Forward Dynamics模块在给定由关节扭矩、关节状态和外力组成的机器人状态下计算机器人模型的关节加速度。要获得关节加速度，请指定机器人配置（关节位置）、关节速度、施加的扭矩和外力。</p><p>The Forward Dynamics block computes joint accelerations for a robotmodel given a robot state that is made up of joint torques, jointstates, and external forces. To get the joint accelerations, specify therobot configuration (joint positions), joint velocities, appliedtorques, and external forces.</p><p>Specify the robot model in the <strong>Rigid body tree</strong>parameter as a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object, and set the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html#bvan8uq-1-Gravity">Gravity</a>property on the object. You can also import a robot model from an URDF(Unified Robot Description Formation) file using <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>Forward Dynamics模块在给定由关节扭矩、关节状态和外力组成的机器人状态下计算机器人模型的关节加速度。要获得关节加速度，请指定机器人配置（关节位置）、关节速度、施加的扭矩和外力。</p><p>将刚体树参数中的机器人模型指定为rigidBodyTree对象，并在该对象上设置Gravity属性。您还可以使用 importrobot 从URDF（统一机器人描述格式）文件中导入机器人模型。</p><h3 id="ports">Ports</h3><h4 id="input">Input</h4><h5 id="config-robot-configuration-vector"><code>Config</code> — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the <strong>Rigid bodytree</strong> parameter. You can also generate this vector for a complexrobot using the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>or <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a>functions inside a Constant or MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由<strong>刚体树</strong>参数设置。您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>或 [<code>randomConfiguration</code>] 为复杂机器人生成此向量(https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html)函数在 Constant 或 MATLAB Function 块中。</p><h5 id="jointvel-joint-velocities-vector"><code>JointVel</code> — Jointvelocities vector</h5><p>Joint velocities, specified as a vector. The number of jointvelocities is equal to the degrees of freedom (number of nonfixedjoints) of the robot.</p><p>关节速度，指定为矢量。关节速度的数量等于机器人的自由度（非固定关节的数量）。</p><h5 id="jointtorq-joint-torques-vector"><code>JointTorq</code> — Jointtorques vector</h5><p>Joint torques, specified as a vector. Each element corresponds to atorque applied to a specific joint. The number of joint torques is equalto the degrees of freedom (number of nonfixed joints) of the robot.</p><p>关节扭矩，指定为矢量。 每个元素对应于施加到特定关节的扭矩。关节扭矩的数量等于机器人的自由度（非固定关节的数量）。</p><h5 id="fext-external-force-matrix-6-by-n-matrix"><code>FExt</code> —External force matrix 6-by-<em>n</em> matrix</h5><p>外力矩阵，指定为 6×n 矩阵，其中 n 是机器人模型中的物体数量。该矩阵在对应于特定实体的行中包含非零值。每一行都是施加的力和扭矩的矢量，它们充当该特定身体的扳手。 使用带有MATLAB Function 模块的 externalForce 生成此矩阵</p><h4 id="output">Output</h4><h5 id="jointaccel-joint-accelerations-vector"><code>JointAccel</code> —Joint accelerations vector</h5><p>关节加速度，以向量形式返回。 关节加速度的数量等于机器人的自由度。</p><h3 id="parameters">Parameters</h3><h5id="rigid-body-tree-robot-model-twojointrigidbodytree-default-rigidbodytree-object"><code>Rigid body tree</code>— Robot model <code>twoJointRigidBodyTree</code> (default) |<code>RigidBodyTree</code> object</h5><p>Robot model, specified as a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object. You can also import a robot model from an URDF (Unified RobotDescription Formation) file using <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>The default robot model, <code>twoJointRigidBodyTree</code>, is arobot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>对象。 您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>从 URDF（统一机器人描述形成）文件导入机器人模型。</p><p>默认机器人模型“twoJointRigidBodyTree”是具有旋转关节和两个自由度的机器人。</p><h5id="simulate-using-type-of-simulation-to-run-interpreted-execution-default-code-generation"><code>Simulate using</code>— Type of simulation to run <code>Interpreted execution</code> (default)| <code>Code generation</code></h5><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB® interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成 - 使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><h2 id="get-jacobian-获取雅可比矩阵">Get Jacobian 获取雅可比矩阵</h2><p>Geometric Jacobian for robot configuration</p><p>用于机器人配置的几何雅可比行列式</p><p><img src="image-20220327132517323.png" alt="image-20220327132517323"  /></p><ul><li><strong>Library:</strong>Robotics System Toolbox / ManipulatorAlgorithms</li></ul><h3 id="description-1">Description</h3><p>The Get Jacobian block returns the geometric Jacobian relative to thebase for the specified end effector at the given configuration of a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>robot model.</p><p>The Jacobian maps the joint-space velocity to the end-effectorvelocity relative to the base coordinate frame. The end-effectorvelocity equals:</p><p>Get Jacobian模块返回相对于在刚体树机器人模型的给定配置下指定末端执行器的基部的几何雅可比。</p><p>雅可比将关节空间速度映射到相对于基本坐标系的末端执行器速度。末端执行器速度等于：</p><p><img src="simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93.assets/image-20220327132908638.png" alt="image-20220327132908638" style="zoom: 80%;" /></p><p><span class="math inline">\(\omega\)</span>is the angular velocity,<span class="math inline">\(v\)</span> is the linear velocity, and<spanclass="math inline">\(\dot q\)</span>is the joint-space velocity.</p><h3 id="ports-1">Ports</h3><h4 id="input-1">Input</h4><h5 id="config-robot-configuration-vector-1">Config — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the <strong>Rigid bodytree</strong> parameter. You can also generate this vector for a complexrobot using the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>or<ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a>functions inside a Constant or MATLAB Function block</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由刚体树参数设置。您还可以使用 Constant 或 MATLAB Function 模块中的 homeConfiguration 或randomConfiguration 函数为复杂机器人生成此向量</p><h4 id="output-1">Output</h4><h5id="jacobian-geometric-jacobian-of-end-effector-6-by-n-matrix">Jacobian— Geometric Jacobian of end effector 6-by-n matrix</h5><p>Geometric Jacobian of the end effector with the specifiedconfiguration, Config, returned as a 6-by-n matrix, where n is thenumber of degrees of freedom of the end effector. The Jacobian maps thejoint-space velocity to the end-effector velocity relative to the basecoordinate frame. The end-effector velocity equals:</p><p><img src="image-20220327133500482.png" alt="image-20220327133500482"  /></p><p><span class="math inline">\(\omega\)</span>is the angular velocity,<span class="math inline">\(v\)</span> is the linear velocity, and<spanclass="math inline">\(\dot q\)</span>is the joint-space velocity.</p><p>具有指定配置 Config 的末端执行器的几何雅可比矩阵以 6×n矩阵形式返回，其中 n 是末端执行器的自由度数。雅可比将关节空间速度映射到相对于基本坐标系的末端执行器速度。末端执行器速度等于：</p><h4 id="parameters-1">Parameters</h4><h5id="rigid-body-tree-robot-model-twojointrigidbodytree-default-rigidbodytree-object-1">Rigidbody tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTreeobject</h5><p>Robot model, specified as a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object. You can also import a robot model from an URDF (Unified RobotDescription Formation) file using <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>The default robot model, <code>twoJointRigidBodyTree</code>, is arobot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>对象。 您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>从 URDF（统一机器人描述形成）文件导入机器人模型。</p><p>默认机器人模型“twoJointRigidBodyTree”是具有旋转关节和两个自由度的机器人。</p><h5 id="end-effector-end-effector-for-jacobian-body-name">End effector —End effector for Jacobian body name</h5><p>End effector for <code>Jacobian</code>, specified as a body name fromthe <strong>Rigid body tree</strong>robot model. To access body namesfrom the robot model, click <strong>Select body</strong>.</p><p>Jacobian 的末端执行器，指定为刚体树机器人模型中的身体名称。要从机器人模型访问身体名称，请单击选择身体。</p><h5 id="simulate-using-type-of-simulation-to-run">Simulate using — Typeof simulation to run</h5><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB®interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p><h2 id="get-transform-获取转换矩阵">Get Transform 获取转换矩阵</h2><p>Get transform between body frames</p><p>获取身体帧之间的变换</p><ul><li><strong>Library:</strong>Robotics System Toolbox / ManipulatorAlgorithms</li></ul><p><img src="image-20220327140329832.png" alt="image-20220327140329832"  /></p><h3 id="description-2">Description</h3><p>The Get Transform block returns the homogeneous transformationbetween body frames on the <strong>Rigid body tree</strong> robot model.Specify a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object for the robot model, and select a source and target body in theblock.</p><p>The block uses <strong>Config</strong>, the robot configuration(joint positions) input, to calculate the transformation from the sourcebody to the target body. This transformation is used to convertcoordinates from the source to the target body. To convert to basecoordinates, use the base body name as the <strong>Target body</strong>parameter.</p><p>Get Transform 块返回刚体树机器人模型上的身体框架之间的齐次变换。为机器人模型指定一个刚体树对象，并在块中选择一个源体和目标体。</p><p>该块使用Config（机器人配置（关节位置）输入）来计算从源体到目标体的转换。此转换用于将坐标从源体转换为目标体。要转换为基础坐标，请使用基础主体名称作为目标主体参数。</p><h3 id="ports-2">Ports</h3><h4 id="input-2">Input</h4><h5 id="config-robot-configuration-vector-2">Config — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the <strong>Rigid bodytree</strong> parameter. You can also generate this vector for a complexrobot using the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>or<ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a>functions inside a Constant or MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由<strong>刚体树</strong>参数设置。您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>或 [<code>randomConfiguration</code>] 为复杂机器人生成此向量(https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html)函数在 Constant 或 MATLAB Function 块中。</p><h4 id="output-2">Output</h4><h5 id="transform-homogeneous-transform-4-by-4-matrix">Transform —Homogeneous transform 4-by-4 matrix</h5><p>Homogeneous transform, returned as a 4-by-4 matrix. 齐次变换，以 4×4矩阵形式返回。 #### Parameters ##### Rigid body tree — Robot modeltwoJointRigidBodyTree (default) | RigidBodyTree object Robot model,specified as a rigidBodyTree object. You can also import a robot modelfrom an URDF (Unified Robot Description Formation) file usingimportrobot.</p><p>The default robot model, twoJointRigidBodyTree, is a robot withrevolute joints and two degrees of freedom.</p><p>机器人模型，指定为一个刚体树对象。 您还可以使用 importrobot 从URDF（统一机器人描述格式）文件中导入机器人模型。</p><p>默认机器人模型 twoJointRigidBodyTree是具有旋转关节和两个自由度的机器人。</p><h5 id="target-body-target-body-name-body-name"><code>Target body</code>— Target body name body name</h5><p>Target body name, specified as a body name from the robot modelspecified in <strong>Rigid body tree</strong>. To access body names fromthe robot model, click <strong>Select body</strong>. The target frame isthe coordinate system you want to transform points into.</p><p>目标坐标系名称，指定为刚体树中指定的机器人模型的身体名称。要从机器人模型访问身体名称，请单击选择身体。目标框架是您要将点转换到的坐标系。</p><h5 id="source-body-source-body-name-body-name"><code>Source body</code>— Source body name body name</h5><p>Source body name, specified as a body name from the robot modelspecified in <strong>Rigid body tree</strong>.To access body names fromthe robot model, click <strong>Select body</strong>. The source frame isthe coordinate system you want points transformed from.</p><p>源身体名称，指定为刚体树中指定的机器人模型的身体名称。要从机器人模型访问身体名称，请单击选择身体。源框架是您想要转换点的坐标系。</p><h5 id="simulate-using-type-of-simulation-to-run-1">Simulate using —Type of simulation to run</h5><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB®interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p><h2 id="gravity-torque">Gravity Torque</h2><p>Joint torques that compensate gravity</p><p>补偿重力的关节扭矩</p><p><img src="image-20220327154957257.png" alt="image-20220327154957257"  /></p><h3 id="description-3">Description</h3><p>The Gravity Torque block returns the joint torques required to holdthe robot at a given configuration with the current <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html#bvan8uq-1-Gravity">Gravity</a>setting on the <strong>Rigid body tree</strong> robot model.</p><p>Gravity Torque 块返回在刚体树机器人模型上使用当前 Gravity设置将机器人保持在给定配置所需的关节扭矩。</p><h3 id="ports-3">Ports</h3><h4 id="input-3">Input</h4><h5 id="config-robot-configuration-vector-3"><code>Config</code> — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the Rigid body treeparameter. You can also generate this vector for a complex robot usingthe homeConfiguration or randomConfiguration functions inside a Constantor MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由刚体树参数设置。您还可以使用 Constant 或 MATLAB Function 模块中的 homeConfiguration 或randomConfiguration 函数为复杂机器人生成此向量。</p><h4 id="output-3">Output</h4><h5 id="jointtorq-joint-torques-vector-1"><code>JointTorq</code> — Jointtorques vector</h5><p>Joint torques, specified as a vector. Each element corresponds to atorque applied to a specific joint. The number of joint torques is equalto the degrees of freedom (number of nonfixed joints) of the robot.</p><p>关节扭矩，指定为矢量。 每个元素对应于施加到特定关节的扭矩。关节扭矩的数量等于机器人的自由度（非固定关节的数量）。</p><h4 id="parameters-2">Parameters</h4><h5id="rigid-body-tree-robot-model-twojointrigidbodytree-default-rigidbodytree-object-2">Rigidbody tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTreeobject</h5><p>Robot model, specified as a rigidBodyTree object. You can also importa robot model from an URDF (Unified Robot Description Formation) fileusing importrobot.</p><p>The default robot model, twoJointRigidBodyTree, is a robot withrevolute joints and two degrees of freedom.</p><p>机器人模型，指定为一个刚体树对象。 您还可以使用 importrobot 从URDF（统一机器人描述格式）文件中导入机器人模型。</p><p>默认机器人模型 twoJointRigidBodyTree是具有旋转关节和两个自由度的机器人。 ##### Simulate using — Type ofsimulation to run</p><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB®interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> MATLAB仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> MATLAB仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代学习控制</title>
      <link href="/2022/03/24/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/03/24/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代学习控制">迭代学习控制</h3><p>迭代学习控制（iterative learningcontrol，ILC）是智能控制中具有严格数学描述的一个分支。1984年，Arimoto等人提出了迭代学习控制的概念，该控制方法适合于<strong>具有重复运动性质</strong>的被控对象，它不依赖于系统的精确数学模型，能以非常简单的方式处理不确定度相当高的非线性强耦合动态系统。目前，迭代学习控制在学习算法、收敛性、鲁棒性、学习速度及工程应用研究上取得了巨大的进展。近年来，迭代学习控制理论和应用在国外得到快速发展，取得了许多成果。在国内，迭代学习控制理论也得到广泛的重视，有许多重要著作出版，发表了许多综述性论文。</p><span id="more"></span><h4 id="迭代学习控制基本原理">1、迭代学习控制基本原理</h4><p>设被控对象的动态过程为 <span class="math display">\[\dot x(t)=f(x(t),u(t),t), y(t)=g(x(t),u(t),t)\]</span> 其中，<span class="math inline">\(x\in R^n\)</span>、<spanclass="math inline">\(y\in R^m\)</span>、<spanclass="math inline">\(u\inR^r\)</span>分别为系统的状态、输出和输入变量，<spanclass="math inline">\(f(·)\)</span>、<spanclass="math inline">\(g(·)\)</span>为适当维数的向量函数，其结构与参数均未知。若期望控制<spanclass="math inline">\(u_d(t)\)</span>存在，则迭代学习<strong>控制的目标</strong>为：给定期望输出<spanclass="math inline">\(y_d(t)\)</span>和每次运行的初始状态<spanclass="math inline">\(x_k(0)\)</span>，要求在给定的时间<spanclass="math inline">\(t\in[0,T]\)</span>内，按照一定的学习控制算法通过多次重复的运行，使控制输入<spanclass="math inline">\(u_k(t)\rightarrow u_d(t)\)</span>，而系统输出<spanclass="math inline">\(y_k(t)\rightarrow y_d(t)\)</span>。第<spanclass="math inline">\(k\)</span>次运行时，式<spanclass="math inline">\((1)\)</span>表示为 <span class="math display">\[\dot x_k(t)=f(x_k(t),u_k(t),t), y_k(t)=g(x_k(t),u_k(t),t)\]</span> 跟踪误差为 <span class="math display">\[e_k(t)=y_d(t)-y_k(t)\]</span> 迭代学习控制可分为以下开环学习和闭环学习两种方法：</p><p>（1）开环学习控制的方法是：第<spanclass="math inline">\(k+1\)</span>次的控制等于第<spanclass="math inline">\(k\)</span>次控制再加上第<spanclass="math inline">\(k\)</span>次输出误差的校正项，即 <spanclass="math display">\[u_{k+1}(t)=L(u_k(t),e_k(t))\]</span> （2）闭环学习控制的方法是：取第<spanclass="math inline">\(k十1\)</span>次运行的误差作为学习的修正项，即<span class="math display">\[u_{k+1}(t)== L(u_k(t),e_{k+1}(t))\]</span> 其中，L为线性或非线性算子。</p><p><img src="20211203022736652.jpg" alt="20211203022736652"  /></p><h4 id="基本的迭代学习控制算法">2、基本的迭代学习控制算法</h4><p>Arimoto等首先给出了线性时变连续系统的D型迭代学习控制律 <spanclass="math display">\[u_{k+1}(t)=u_k(t)+\Gamma \dot e_k(t)\]</span> 其中，<spanclass="math inline">\(\Gamma\)</span>为常数增益矩阵。在D型算法的基础上，相继出现了P型、PI型、PD型迭代学习控制律。从一般意义来看它们都是PID型迭代学习控制律的特殊形式，PID迭代学习控制律表示为<span class="math display">\[u_{k+1}(t)=u(t)+\Gamma \dot e_k(t)+\Phie_K(T)+\Psi\int_{0}^{t}e_k(\tau)d\tau\]</span> 其中，<span class="math inline">\(\Gamma\)</span>、<spanclass="math inline">\(\Phi\)</span>、<spanclass="math inline">\(\Psi\)</span>为学习增益矩阵。算法中的误差信息使用<spanclass="math inline">\(e_k(t)\)</span>称为开环迭代学习控制，如果使用<spanclass="math inline">\(e_{k+1}(t)\)</span>则称为闭环迭代学习控制，如果同时使用<spanclass="math inline">\(e_k(t)\)</span>和<spanclass="math inline">\(e_{k+1}(t)\)</span>则称为开闭环迭代学习控制。</p><p>此外，还有高阶迭代学习控制算法、最优迭代学习控制算法、遗忘因子迭代学习控制算法和反馈-前馈迭代学习控制算法等。</p><h4 id="迭代学习控制主要分析方法">3、迭代学习控制主要分析方法</h4><p>学习算法的收敛性分析是迭代学习控制的核心问题，这方面的研究成果很丰富。</p><p>1、基本的收敛性分析方法</p><p>对于如下线性离散系统： <span class="math display">\[\left\{\begin{matrix}x(t+1)=Ax(t)+Bu(t) \\y(t)=Cx(t)\end{matrix}\right.\]</span> 迭代学习控制算法为 <span class="math display">\[u_{k+1}(t)=u_k(t)+\Gamma e_k(t+1)\]</span> 针对学习算法式<spanclass="math inline">\((9)\)</span>的收敛性，有以下两种分析方法：</p><p>（1）压缩映射方法：即系统要求满足全局<spanclass="math inline">\(Lipschitz\)</span>条件和相同的初始条件，如果 <spanclass="math inline">\(||I-CBT||&lt;1\)</span>,则有 <spanclass="math display">\[\parallele_{K+1}\parallel=\parallel(I-CB\Gamma)e_K\parallel&lt;\parallelI-CB\Gamma\parallel \parallel e_k\parallel&lt;\parallel e_k\parallel\]</span> 此时算法是单调收敛的。该方法依赖于范数的选择，常用的有<spanclass="math inline">\(l_1\)</span>范数、<spanclass="math inline">\(l_2\)</span>范数、<spanclass="math inline">\(l_\infty\)</span>范数 及<spanclass="math inline">\(\lambda\)</span>范数。在收敛性证明过程中常用到<spanclass="math inline">\(Bellman-Gronwall\)</span>引理。</p><p>（2）谱半径条件法：如果谱半径<spanclass="math inline">\(\rho\)</span>满足<spanclass="math inline">\(\rho(I-CB\Gamma)\leq \rho &lt;1\)</span>，则有<span class="math display">\[\lim_{k \to \infty}\parallel e_k \parallel = \lim_{k \to \infty}\parallel(I- CB\Gamma)e_{k-1}\parallel = \lim_{k \to \infty}\rho(I-CB\Gamma)^k\parallel e \parallel\]</span> 即$ _ {k }e_k$。</p><p>2、基于2-D理论的分析方法</p><p>迭代学习控制系统的学习是按两个相互独立的方向进行：时间轴方向和迭代次数轴方向，因此选代学习过程本质上是二维系统，可利用成熟的2-D系统理论系统地研究和分析时间域的稳定性和迭代次数域的收敛性问题。2-D系统的稳定性理论为迭代学习控制的收敛性证明提供了一种非常有效的方法，2-D系统理论中的Roesser模型成为迭代学习控制中最基本的分析模型。</p><p>3.基于Lyapunov直接法的设计方法</p><p>Lyapunov直接法已广泛用于非线性动态系统的控制器设计和分析中，在研究非线性不确定系统时，该方法是最重要的应用工具之一。受Lyapunov直接法的启发，在时间域和迭代域能量函数的概念得到研究，它为学习控制在迭代域设计和收敛性分析方面提供了一种新的研究方法。</p><p>在迭代域能量函数的迭代学习控制方法基础上，发展了鲁棒和自适应迭代学习控制，可解决具有参数或非参数不确定性非线性系统控制器的设计，近年来反映时间域和迭代域系统能量的组合能量函数方法也应用于迭代学习控制，它可保证在迭代域跟踪误差的渐近收敛以及在时间域具有有界和逐点跟踪的动态特性，并且控制输入在整个迭代区间内是范数收敛的，适用于一类不具有全局Lipschitz条件的非线性系统。通过能量函数的方法，许多新的控制方法，如反演设计和非线性优化方法都作为系统设计工具应用到迭代学习控制中。此外，还有最优化分析方法、频域分析法等分析方法。#### 4、选代学习控制的关键技术 1.学习算法的稳定性和收敛性</p><p>稳定性与收敛性是研究当学习律与被控系统满足什么条件时，选代学习控制过程才是稳定收敛的。算法的稳定性保证了随着学习次数的增加，控制系统不发散，但是对于学习控制系统而言，仅仅稳定是没有实际意义的，只有使学习过程收敛到真值，才能保证得到的控制为某种意义下最优的控制。收敛是对学习控制的最基本要求，多数学者在提出新的学习律的同时，基于被控对象的一些假设，给出了收敛的条件。例如，Arimoto在最初提出PID型学习控制律时，仅针对线性系统在D型学习律下的稳定性和收敛条件作了证明。</p><p>2.初始值问题</p><p>运用迭代学习控制技术设计控制器时，只需要通过重复操作获得的受控对象的误差或误差导数信号。在这种控制技术中，迭代学习总要从某初始点开始，初始点指初始状态或初始输出。几乎所有的收敛性证明都要求初始条件是相同的，解决选代学习控制理论中的初始条件问题一直是人们追求的目标之一。目前已提出的迭代学习控制算法大多数要求被控系统每次运行时的初始状态在期望轨迹对应的初始状态上，即满足初始条件：<span class="math display">\[x_k(0)=x_d(0),k=0,1,2,…\]</span>当系统的初始状态不在期望轨迹上，而在期望轨迹的某一很小的邻域内时，通常把这类问题归结为学习控制的鲁棒性问题研究。</p><p>3.学习速度问题</p><p>在迭代学习算法研究中，其收敛条件基本上都是在学习次数<spanclass="math inline">\(k→\infty\)</span>下给出的。而在实际应用场合，学习次数<spanclass="math inline">\(k→\infty\)</span>显然是没有任何实际意义的。因此，如何使迭代学习过程更快地收敛于期望值是迭代学习控制研究中的另一个重要问题。ILC本质上是一种前馈控制技术，大部分学习律尽管证明了学习收敛的充分条件，但收敛速度还是很慢。可利用多次学习过程中得到的知识来改进后续学习过程的速度，例如，采用高阶迭代控制算法、带遗忘因子的学习律、利用当前项或反馈配置等方法来构造学习律，可使收敛速度大大加快。</p><p>4.鲁棒性问题</p><p>迭代学习控制理论的提出有浓厚的工程背景，因此仅仅在无干扰条件下过论收敛性问题是不够的，还应讨论存在各种干扰的情形下系统的跟踪性能。一个实际运行的迭代学习控制系统除了存在初始偏移外，还或多或少存在状态扰动、测量噪声、输入扰动等各种干扰。鲁棒性问题讨论存在各种干扰时迭代学习控制系统的跟踪性能。具体地说，一个迭代学习控制系统是鲁棒的，指系统在各种有界干扰的影响下，其迭代轨迹能收敛到期望轨迹的邻域内，而当这些干扰消除时，迭代轨迹会收敛到期望轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械臂的PD控制</title>
      <link href="/2022/03/23/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84PD%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/03/23/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84PD%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="机械臂的pd控制">机械臂的PD控制</h3><h3 id="控制率设计">1 控制率设计</h3><p>当忽略重力和外部干扰的时候，采用独立的PD控制，可以满足机械臂的定点控制的要求。</p><span id="more"></span><p>设n关节机械臂的动力学方程为 <span class="math display">\[D(q)\ddot q+ C(q,\dot q)\dot q=\tau\]</span> 其中，<span class="math inline">\(D(q)\)</span>为$nn <spanclass="math inline">\(正定惯性矩阵，\)</span>C(q,q)<spanclass="math inline">\(为\)</span>nn$的离心和哥氏力项。</p><p>独立的PD控制率为 <span class="math display">\[\tau =K_d\dot e +K_pe\]</span> 取跟踪误差为<spanclass="math inline">\(e=q_d-q\)</span>，采用定点控制时，<spanclass="math inline">\(q_d\)</span>为常值，则<spanclass="math inline">\(\dot q_d=\ddot q_d\equiv 0\)</span></p><p>此时，机械臂方程为 <span class="math display">\[D(q)(\ddot q_d-\ddot q)+C(q,\dot q)(\dot q_d - \dot q)+K_d\dot e +K_pe=0\]</span> 即 <span class="math display">\[D(q)\ddot e+C(q,\dot q)\dot e +K_pe=-K_d\dot e\]</span> 取Lyapunov李雅普诺夫函数为 <span class="math display">\[V= \frac{1}{2}\dot e^TD(q)\dot e+\frac{1}{2}e^TK_pe\]</span> 由<span class="math inline">\(D(q)\)</span>和<spanclass="math inline">\(K_p\)</span>的正定性可知，<spanclass="math inline">\(V\)</span>是全局正定的，则 <spanclass="math display">\[\dot V=\dot e^TD\ddot e+\frac{1}{2}\dot e^T\dot D\dot e+\dot e^TK_pe\]</span> 利用<span class="math inline">\(\dot D-\ddot2C\)</span>的斜对称性可知，<span class="math inline">\(\dot e^TD\ddote=2\dot e^TC\ddot e\)</span>则 <span class="math display">\[\dot V=\dot e^TD\ddot e+\dot e^T C\dot e+\dot e^TK_pe=\dot e^T(D\ddote+C\dot e+K_p e)=-\dot e^TK_d\dot e \leq 0\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输出受限引理</title>
      <link href="/2022/03/22/%E8%BE%93%E5%87%BA%E5%8F%97%E9%99%90%E5%BC%95%E7%90%86/"/>
      <url>/2022/03/22/%E8%BE%93%E5%87%BA%E5%8F%97%E9%99%90%E5%BC%95%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在实际系统的控制系统中，为了保证系统的安全性，通常会对系统的输出的上下界做出严格的限制，或者要求系统的超调量在一定的范围内，超调量过大往往意味着系统处于不理想的运行状态，某些情况下，会对系统本身产生不可预知的影响。</p><span id="more"></span><h4 id="引理1.1">引理1.1</h4><p>针对系统误差 <span class="math display">\[\dot{z}=f(t,z), z=[z_1,z_2]^T\]</span> 存在连续可微的正定函数<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>，<spanclass="math inline">\(k_b&gt;0\)</span>,位置输出为<spanclass="math inline">\(X_1\)</span>,定义为位置误差<spanclass="math inline">\(z_1=x_1-y_d\)</span>，满足</p><p>（1）当<span class="math inline">\(z_1\rightarrow-k_b\)</span>或<spanclass="math inline">\(z_1\rightarrow k_b\)</span>时，有<spanclass="math inline">\(V_1(z_1)\rightarrow \infty\)</span>；</p><p>（2）<span class="math inline">\(\gamma_1(|| z_2||)\leqV_2(z_2)\leq\gamma_2(||z_2||))\)</span>,<spanclass="math inline">\(\gamma_1\)</span>为<spanclass="math inline">\(\gamma_2\)</span>为<spanclass="math inline">\(K_\infty\)</span>类函数；</p><p>假设</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adaptive Neural Network Control of a Robotic Manipulator With Time-V arying Output Constraints</title>
      <link href="/2022/03/21/Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints/"/>
      <url>/2022/03/21/Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints/</url>
      
        <content type="html"><![CDATA[<h3id="adaptive-neural-network-control-of-a-robotic-manipulator-with-time-v-arying-output-constraints">AdaptiveNeural Network Control of a Robotic Manipulator With Time-V aryingOutput Constraints</h3><h3id="带时变输出约束的机械臂自适应神经网络控制">带时变输出约束的机械臂自适应神经网络控制</h3><span id="more"></span><h4 id="摘要">摘要</h4><p>研究了不确定n自由度机器人机械臂受时变输出约束的控制问题。将刚性机械臂系统描述为多输入多输出的非线性系统。我们设计了一个干扰观测器来估计来自人类和环境的未知干扰。为了解决不确定性问题，采用径向基函数的神经网络对机械臂的未知动力学进行估计。在控制设计过程中，采用了非对称势垒(障碍)李雅普诺夫函数，避免了输出约束的时变。仿真结果验证了该控制方案的有效性。</p><p>Adaptive neural network (NN) control, barrier</p><p>Lyapunov function (BLF), disturbance observer (DO)</p><h4 id="论文拟解决的主要问题"><strong>论文拟解决的主要问题</strong></h4><p>机器人系统的输入输出普遍存在饱和、死区、安全规范等约束。由于现在要求机器人与人类和环境有更多的物理互动，违反这些约束所产生的安全问题是不可忽视的。因此，我们需要设计有针对性的控制器来处理这些问题。在人与环境的相互作用下，对未知的动力学和未知的扰动的不确定机械臂的控制具有挑战性。</p><p>传统的李雅普诺夫函数的目标是实现有保证的全局或半全局稳定性，而在本文中，我们不仅要保证系统的半全局稳定性，而且要避免时变约束的冲突。研究中常见的约束通常是常数约束，而常数约束可以看作是一种特殊的时变约束，因此时变约束的研究更为实际。现有的大量论文考虑了无约束的非线性系统、具有输入约束的非线性系统、具有恒定输出约束的非线性系统，或具有时变输出约束的某些SISO非线性系统。因此，需要解决MIMO未知机器人系统在未知扰动和时变输出约束下的控制问题</p><h4 id="论文主要研究内容"><strong>论文主要研究内容</strong></h4><p>利用自适应神经网络对机械臂系统的不确定动力学进行补偿。在控制设计过程中利用非对称blf（障碍李雅普诺夫函数）来克服输出约束的时变问题。本文的主要贡献如下:</p><p>1)通过基于神经网络的自适应控制律，成功地补偿了系统不确定性的影响，提高了机器人系统的鲁棒性。</p><p>2)将神经网络估计误差与来自人、环境的未知干扰集成为一个组合干扰，最后由DO逼近。</p><p>3)为了避免时变约束的冲突，采用非对称blf设计控制律，成功实现了渐近跟踪。</p><h4 id="论文的算法"><strong>论文的算法</strong></h4><p><img src="1.png" alt="1"  /></p><p><img src="2.png" alt="2" style="zoom:67%;" /></p><p>控制目标就是设计控制率，使得输出可以跟踪轨迹q，同时不能违反时变输出约束，如果给出了时变的边界，kc和kc-，输出qt就应该在这个边界内。</p><p><img src="3.png" alt="3" style="zoom: 80%;" /></p><h4 id="控制算法设计"><strong>控制算法设计</strong></h4><p>使用神经网络来弥补系统不确定性的影响，并使用时变的blf来避免时变约束的冲突。我们定义了一种新的由神经网络估计误差和来自人类和环境的未知外部干扰组成的复合干扰，该复合干扰由DO估计。控制策略如图2所示。</p><p><img src="4.png" alt="4"  /></p><p><img src="5.png" alt="5"  /></p><p>定义了误差变量z1和误差变量的导数。还定义了一个新的误差变量z2，γ是辅助变量。</p><h4 id="结论"><strong>结论</strong></h4><p>我们考虑一个如图3所示的三自由度机器人机械手。该机器人有两个旋转关节和一个移动关节。手腕的位置是由两个旋转关节和一个移动关节(RRP)的两次旋转和一次平移决定的。为了验证该控制方法的有效性，对一个三自由度机器人系统进行了仿真。我们定义</p><p><img src="6.png" alt="6"  /></p><p><img src="7.png" alt="7"  /></p><p><img src="8.png" alt="8"  /></p><p><img src="9.png" alt="9"  /></p><p><img src="10.png" alt="10"  /></p><p>仿真使用了三种不同的控制率，第一个是基于模型的控制，第二个使用自适应神经网络的控制，第三个使用传统的pd控制。</p><p><img src="11.png" alt="11"  /></p><p>可以看出，输出的q可以精确地跟踪期望的轨迹qd。由图5-7可知，跟踪误差z11、z12、z13收敛到一个接近零的小值</p><p>针对一类受时变约束和未知干扰的不确定n-DOF机器人，提出了一种基于DOs的自适应神经网络控制方法。我们用神经网络估计机器人的未知动力学模型，用DOs逼近时变扰动。使用非对称BLF避免与输出约束的冲突。仿真结果表明，所提出的控制方案能在保证约束条件满足的情况下，使输出很好地跟随目标轨迹。</p><p><img src="12.png" alt="12"  /></p><p><img src="13.png" alt="13"  /></p><p>与此同时，它们的约束从未被打破。图8给出了控制输入力矩τ1、τ2和τ3。DO的近似误差如图9所示。我们可以看到，DO估计误差越来越小，最后接近于零。综上所述，本文提出的基于模型的控制方法取得了满意的控制效果。</p><p>但是，基于模型的控制律是在已知机械臂系统的精确参数的基础上建立起来的，而这些参数在实际操作中通常是未知的</p><p>对于神经网络控制律，图10表明，输出q可以在很小的误差下遵循期望的轨迹qd。由图11-13可知，跟踪误差z11、z12、z13收敛到一个接近零的小值。同时，它们都明显排斥时变边界−ka(t)和kb(t)，即不违反输出约束</p><p>Fg18表明输出q可以大致跟随所需轨迹qd，但从图20和图21可以明显看出，q2和q3的约束被打破了。图22给出了PD控制输入力矩，从中我们可以看到输入是有界的。</p><p>控制目标就是设计控制率，使得输出可以跟踪轨迹q，同时不能违反时变输出约束，如果给出了时变的边界，kc和kc-，输出qt就应该在这个边界内。</p><p><img src="14.png" alt="14"  /></p><p><img src="15.png" alt="15"  /></p><p><img src="16.png" alt="16"  /></p><p><img src="17.png" alt="17"  /></p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 论文阅读笔记 </category>
          
          <category> 英文论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 论文，英文论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械臂相关论文列表</title>
      <link href="/2022/03/21/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/"/>
      <url>/2022/03/21/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="论文列表">论文列表</h3><p>​ 1、Z. Yang, W. Lu, Z. Yao and B. Zhang, "Neuroadaptive backsteppingtracking control of robotic manipulators considering actuator dynamics,"The 27th Chinese Control and Decision Conference (2015 CCDC), 2015, pp.465-470, doi: 10.1109/CCDC.2015.7161737.</p><p>考虑执行器动力学的机器人神经自适应反步跟踪控制</p><span id="more"></span><p>2、Hanlei Wang, Yongchun Xie,Adaptive inverse dynamics ontrol ofrobots with uncertain kinematics and dynamics,Automatica,Volume 45,Issue 9,2009,Pages 2114-2119,ISSN0005-1098,https://doi.org/10.1016/j.automatica.2009.05.011.(https://www.sciencedirect.com/science/article/pii/S0005109809002556)</p><p>具有不确定的运动学和动力学机器人的自适应反动力学控制</p><p>3、D. T. Tran, D. X. Ba and K. K. Ahn, "Adaptive Backstepping SlidingMode Control for Equilibrium Position Tracking of an ElectrohydraulicElastic Manipulator," in IEEE Transactions on Industrial Electronics,vol. 67, no. 5, pp. 3860-3869, May 2020, doi:10.1109/TIE.2019.2918475.</p><p>电液弹性机械臂平衡位置跟踪的自适应反步滑模控制</p><p>4、S. Morinaga and K. Kosuge, "Collision detection system formanipulator based on adaptive impedance control law," 2003 IEEEInternational Conference on Robotics and Automation (Cat. No.03CH37422),2003, pp. 1080-1085 vol.1, doi: 10.1109/ROBOT.2003.1241736.</p><p>基于自适应阻抗控制律的机械臂碰撞检测系统</p><p>5、Kee-Ho Yu, Yoshinobu Shito, Hikaru Inooka,Position control of anunderactuated manipulator using joint friction,International Journal ofNon-Linear Mechanics,</p><p>Volume 33, Issue 4,1998,Pages 607-614,ISSN 0020-7462,</p><p>https://doi.org/10.1016/S0020-7462(97)00035-8.</p><p>(https://www.sciencedirect.com/science/article/pii/S0020746297000358)</p><p>基于关节摩擦的欠驱动机械手位置控制</p><p>6、Z. Xie, L. Jin, X. Luo, S. Li and X. Xiao, "A Data-DrivenCyclic-Motion Generation Scheme for Kinematic Control of RedundantManipulators," in IEEE Transactions on Control Systems Technology, vol.29, no. 1, pp. 53-63, Jan. 2021, doi: 10.1109/TCST.2019.2963017.</p><p>数据驱动的循环运动生成运动控制方案冗余度机械手的设计</p><p>7、W. He, H. Huang and S. S. Ge, "Adaptive Neural Network Control ofa Robotic Manipulator With Time-Varying Output Constraints," in IEEETransactions on Cybernetics, vol. 47, no. 10, pp. 3136-3147, Oct. 2017,doi: 10.1109/TCYB.2017.2711961.</p><p>时变输出约束机器人的自适应神经网络控制</p><p>8、C. Yang, G. Peng, L. Cheng, J. Na and Z. Li, "Force SensorlessAdmittance Control for Teleoperation of Uncertain Robot ManipulatorUsing Neural Networks," in IEEE Transactions on Systems, Man, andCybernetics: Systems, vol. 51, no. 5, pp. 3282-3292, May 2021, doi:10.1109/TSMC.2019.2920870.</p><p>基于神经网络的不确定机械手遥操作无力传感器导纳控制</p><p>9、Q. Guo, Y. Zhang, B. G. Celler and S. W. Su, "Backstepping Controlof Electro-Hydraulic System Based on Extended-State-Observer With PlantDynamics Largely Unknown," in IEEE Transactions on IndustrialElectronics, vol. 63, no. 11, pp. 6909-6920, Nov. 2016, doi:10.1109/TIE.2016.2585080.</p><p>10、M. Van, M. Mavrovouniotis and S. S. Ge, "An Adaptive BacksteppingNonsingular Fast Terminal Sliding Mode Control for Robust Fault TolerantControl of Robot Manipulators," in IEEE Transactions on Systems, Man,and Cybernetics: Systems, vol. 49, no. 7, pp. 1448-1458, July 2019, doi:10.1109/TSMC.2017.2782246.</p><p>机器人鲁棒容错控制的自适应反步非奇异快速终端滑模控制</p><p>11、张世轩,王琬琪,徐志刚,杜木雄.多关节套索驱动机械臂的自适应滑模鲁棒控制[J].组合机床与自动化加工技术,2022(02):63-67.DOI:10.13462/j.cnki.mmtamt.2022.02.015.</p><p>12、王泰华,马彬彬,李亚飞.基于神经网络自适应算法的机械臂位置/力控制[J].电动工具,2022(01):14-18.DOI:10.16629/j.cnki.1674-2796.2022.01.003.</p><p>13、陈正升,王雪松,程玉虎.考虑扰动与输入饱和的机械臂连续非奇异快速终端滑模控制[J].控制与决策,2022,37(04):903-912.DOI:10.13195/j.kzyjc.2020.1335.</p><p>14、于欣波,贺威,薛程谦,孙永坤,孙长银.基于扰动观测器的机器人自适应神经网络跟踪控制研究[J].自动化学报,2019,45(07):1307-1324.DOI:10.16383/j.aas.c180222.</p><p>15、朱萌,孟婥,张豪,孙以泽.基于ROS的6自由度机械臂运动轨迹规划[J].组合机床与自动化加工技术,2021(04):1-3+9.DOI:10.13462/j.cnki.mmtamt.2021.04.001.</p><p>16、李岩,柴媛媛,刘克平.一类机械臂指数加速迭代学习控制方法[J].科学技术与工程,2020,20(31):12904-12910.</p><p>17、Yan Wang and Yongling Fu, "Fuzzy Adaptive Iterative LearningControl Algorithm," 2006 6th World Congress on Intelligent Control andAutomation, 2006, pp. 3719-3723, doi: 10.1109/WCICA.2006.1713065.</p><p>数据驱动的自适应迭代学习预测控制</p><p>18、S. Zhang, Y. Hui and R. Chi, "Data-driven Adaptive IterativeLearning Control Based on a Local Dynamic Linearization," 2018 IEEE 7thData Driven Control and Learning Systems Conference (DDCLS), 2018, pp.184-188, doi: 10.1109/DDCLS.2018.8516008.</p><p>基于局部动态线性化的数据驱动自适应迭代学习控制</p><p>19、A. Madady and H. Reza-Alikhani, "Adaptive PI type iterativelearning control," 2010 5th IEEE International Conference IntelligentSystems, 2010, pp. 37-42, doi: 10.1109/IS.2010.5548330.</p><p>自适应PI型迭代学习控制</p><p>20、Z. Cheng and Z. Zhuo, "Adaptive Iterative Learning TrajectoryTracking Control of SCARA Robot," 2021 IEEE 4th Advanced InformationManagement, Communicates, Electronic and Automation Control Conference(IMCEC), 2021, pp. 910-914, doi: 10.1109/IMCEC51613.2021.9482360.</p><p>SCARA机器人自适应迭代学习轨迹跟踪控制</p><p>21、Y. Sun and J. Li, "Adaptive iterative learning control viacontinuous sliding-mode technique with uncertainties," 2016 ChineseControl and Decision Conference (CCDC), 2016, pp. 473-478, doi:10.1109/CCDC.2016.7531031.</p><p>具有不确定性的连续滑模技术自适应迭代学习控制</p><p>22、L. Chen and M. Sun, "Barrier Lyapunov function-based fuzzyadaptive iterative learning control," The 27th Chinese Control andDecision Conference (2015 CCDC), 2015, pp. 2877-2882, doi:10.1109/CCDC.2015.7162417.</p><p>基于障碍李雅普诺夫函数的模糊自适应迭代学习控制</p><p>23、R. Chi, X. Liu, Z. Hou and C. -J. Chien, "A novel adaptiveiterative learning control via data-driven approach," 2016 35th ChineseControl Conference (CCC), 2016, pp. 3147-3151, doi:10.1109/ChiCC.2016.7553842.</p><p>一种基于数据驱动方法的新型自适应迭代学习控制</p><p>24、Q. Quan, W. Xinhua and C. Kaiyuan, "Higher-order AdaptiveIterative Control for Uncertain Robot Manipulators," 2007 ChineseControl Conference, 2007, pp. 825-829, doi:10.1109/CHICC.2006.4347468.</p><p>不确定机器人机械手的高阶自适应迭代控制</p><p>25、李兴.基于改进型自抗扰控制的多自由度机械臂控制系统研究[D].安徽工程大学,2021.DOI:10.27763/d.cnki.gahgc.2021.000167.</p><p>26、易善超.基于高阶滑模的机械臂轨迹跟踪控制[D].东南大学,2019.DOI:10.27014/d.cnki.gdnau.2019.002124.</p><p>27、周振.基于滑模变结构的机械臂轨迹跟踪控制方法研究[D].青岛大学,2021.DOI:10.27262/d.cnki.gqdau.2021.002206.</p><p>28、徐贵.基于滑模的机械臂轨迹跟踪控制研究[D].东南大学,2020.DOI:10.27014/d.cnki.gdnau.2020.001433.</p><p>29、吴绍华.基于终端滑模控制的机械臂轨迹跟踪[D].天津大学,2018.DOI:10.27356/d.cnki.gtjdu.2018.000890.</p><p>30、夏炎.多关节机械臂轨迹规划和轨迹跟踪控制研究[D].哈尔滨工业大学,2017.</p><p>31、刘海亭. 基于滑模变结构控制的机械臂轨迹跟踪[D].天津大学,2018.</p><p>32、L. Zhang, Z. Chen, Z. Li, C. -Y. Su and Z. Xiao, "Adaptive neuralnetwork control for uncertain MIMO robotic systems with time-varyingdelay and unknown backlash-like hysteresis," 2015 IEEE InternationalConference on Information and Automation, 2015, pp. 1827-1832, doi:10.1109/ICInfA.2015.7279585.</p><p>具有时变延迟和未知类反冲滞后的不确定多输入多输出机器人系统的自适应神经网络控制（有工程文件）</p><p>33、王新达,韩宝玲,陈禹含,郑凯林.一种多关节机械臂运动过程中的碰撞检测方法[J].科学技术与工程,2019,19(14):218-223.</p><p>34、C. Yang, Y. Jiang, W. He, J. Na, Z. Li and B. Xu, "AdaptiveParameter Estimation and Control Design for Robot Manipulators WithFinite-Time Convergence," in IEEE Transactions on IndustrialElectronics, vol. 65, no. 10, pp. 8112-8123, Oct. 2018, doi:10.1109/TIE.2018.2803773.</p><p>具有有限时间收敛性的机器人机械手自适应参数估计与控制设计</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 论文列表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
