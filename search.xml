<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数字图像处理实验</title>
      <link href="/2022/04/15/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"/>
      <url>/2022/04/15/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="opencv中文文档httpsopencv.apachecn.org">opencv中文文档：<ahref="https://opencv.apachecn.org/#/">https://opencv.apachecn.org</a></h1><h2 id="实验一-python中数字图像处理的基本操作">实验一Python中数字图像处理的基本操作</h2><span id="more"></span><h3 id="一实验目的">一、实验目的</h3><p>1 熟悉及掌握在 python中能够处理哪些格式图像；</p><p>2 熟练掌握在 python中如何 用 OpenCV读取图像；</p><p>3 掌握如何利用python来获取图像的大小、颜色、高度、宽度等等相关信息；</p><p>4 掌握如何在 python中 用 OpenCV按照指定要求存储一幅图像的方法；</p><p>5 图像间如何转化。</p><h3 id="二实验原理">二、实验原理</h3><h4 id="数字图像的表示和类别">1.数字图像的表示和类别</h4><p>一幅图像可以被定义为一个二维函数f(x,y),其中 x和 y是空间 (平面 )坐标，f 在任何坐标(x,y)处的振幅称为图像在该点的亮度。灰度是用来表示黑白图像亮度的一个术语，而彩色图像是由单个二维图像组合形成的。例如，在RGB彩色系统中，一幅彩色图像是由三幅独立的分量图像 (红、绿、蓝)组成的。因此，许多为黑白图像处理开发的技术适用于彩色图像处理，方法是分别处理三副独立的分量图像即可。</p><p>要将这样的一幅图像转化为数字形式，就要求数字化坐标和振幅。将坐标值数字化成为取样；将振幅数字化成为量化。采样和量化的过程如图1所示。因此，当 f的 x、y分量和振幅都是有限且离散的量时，称该图像为数字图像。</p><p><img src="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220415212141944.png" alt="image-20220415212141944" style="zoom: 80%;" /></p><center style="color=#C0C0C0;text-decoration:underline">图1 图像的采样和量化</center><p>在python中，一幅图像可能包含一个数据矩阵，也可能有一个颜色映射表矩阵。opencv支持四种图像类型，其区别在于数据矩阵元素的不同含义。它们是：</p><p> 亮度图像（ Intensity images）</p><p> 二值图像（ Binary images）</p><p> 索引图像（ Indexed images）</p><p> RGB图像（ RGB images）</p><p>(1)亮度图像。</p><p>也称灰度图像。一幅亮度图像是一个数据矩阵，其归一化的取值表示亮度。若亮度图像一幅亮度图像是一个数据矩阵，其归一化的取值表示亮度。若亮度图像的像素都是的像素都是uint8类或类或uint16类，则它们的整数值范围分别是类，则它们的整数值范围分别是[0，255]和和[0，65536]。若。若图像图像是是double类，则像素取值就是浮点数。规定双精度型归一化亮度图像的取值范围是类，则像素取值就是浮点数。规定双精度型归一化亮度图像的取值范围是[0，1]。。</p><p>(2)二值图像</p><p>二值图像是指在图像中，每个像素的灰度等级只有两种。即全黑或者全白，在二值图像是指在图像中，每个像素的灰度等级只有两种。即全黑或者全白，在python种，种，一幅二值图像是一个取值只有一幅二值图像是一个取值只有0和和255的的numpy数组数组。</p><p>(3)索引图像</p><p>索引颜色通常也称为映射颜色，在这种模式下，颜色都是预先定义的，并且可供选用的索引颜色通常也称为映射颜色，在这种模式下，颜色都是预先定义的，并且可供选用的一组颜色也很有限，索引颜色的图像最多只能显示一组颜色也很有限，索引颜色的图像最多只能显示256种颜色。种颜色。一幅索引颜色图像在图像文件里定义，当打开该文件时，构成该图像具体颜色的索引值一幅索引颜色图像在图像文件里定义，当打开该文件时，构成该图像具体颜色的索引值就被读入程序里，然后根据索引值找到最终的颜色。就被读入程序里，然后根据索引值找到最终的颜色。</p><ol start="4" type="1"><li>RGB图像</li></ol><p>一幅RGB图像就是彩色像素的一个图像就是彩色像素的一个M×N×3数组，其中每一个彩色相似点都是在特定数组，其中每一个彩色相似点都是在特定空间位置的彩色图像相对应的红、绿、蓝三个分量。按照惯例，形成一幅空间位置的彩色图像相对应的红、绿、蓝三个分量。按照惯例，形成一幅RGB彩色图像的彩色图像的三个图像常称为红、绿或蓝分量图像。三个图像常称为红、绿或蓝分量图像。</p><p>值得注意的是，在OpenCV中，加载图像通道的顺序是中，加载图像通道的顺序是BGR（实验五中您将用到此特（实验五中您将用到此特性）性）。。但是但是Matplotlib（（python的一个绘图库）以的一个绘图库）以RGB模式显示。因此，如果使用模式显示。因此，如果使用OpenCV读取彩色图像，则读取彩色图像，则Matplotlib中将无法正确显示彩色图像。中将无法正确显示彩色图像。</p><h4id="opencv图像文件格式图像文件格式">2.OpenCV图像文件格式图像文件格式</h4><p>OpenCV支持支持处理处理以下几种图像文件格式：以下几种图像文件格式：</p><p>1 PCX（WindowsPaintbrus），可处理1，4，8，16，24位等图像数据。文件位等图像数据。文件内容包括：文件头（内容包括：文件头（128字节），图像数据、扩展颜色映射表数据。字节），图像数据、扩展颜色映射表数据。</p><p>2 BMP（WindowsBitmap格式。有1，4，8，24位非压缩图像，位非压缩图像，8位位RLE（（Run-lengthEncoded）图像。文件内容包括：文件头（一个）图像。文件内容包括：文件头（一个BITMAPFILEHEADER数据结构），数据结构），位图信息数据块（位图信息头位图信息数据块（位图信息头BITMAPINFOHEADER和一个颜色表）和图像数据。和一个颜色表）和图像数据。</p><p>3 HDF（（Hierarchical DataFormat）格式。有8位，位，24位光栅数据集。位光栅数据集。</p><p>4 JPEG(Joint Photographic ExpertsGroup)格式，是一种成为联合图像专家组的图像压格式，是一种成为联合图像专家组的图像压缩格式。缩格式。</p><p>5 TIFF（Tagged Image FileFormat）格式，处理1，4，8，24位非压缩图像，位非压缩图像，1，，4，，8，，24位位packbit压缩图像，一位压缩图像，一位CCITT压缩图像等。文件内容压缩图像等。文件内容包括：文件头，参数指针表包括：文件头，参数指针表与参数域，参数数据表和图像数据四部分。与参数域，参数数据表和图像数据四部分。</p><p>6 XWD(X WindowsDump)格式。1，8位位Zpixmaps,XYbitmaps,1位位XYpixmaps。。</p><p>7 PNG（Portable Network Graphics）格式。</p><h3 id="三实验内容">三、实验内容</h3><p>1利用OpenCV读取一幅彩色图像，并读取图像的基本信息；</p><p>2 利用OpenCV显示图像；</p><p>3 对彩色图像进行灰度化化处理；</p><p>4 对灰度图像进行二值化处理；</p><p>5 对图像进行几何变换（缩放，平移，翻转）；</p><p>6 储存处理后的图像；</p><h3 id="四实验报告要求">四、实验报告要求</h3><p>1给出使用给出使用opencv-python进行图像读取、显示、翻转、裁剪，存储的完整代码。</p><p>2 写出实验的心得与体会。</p><h3 id="五预习要求">五、预习要求</h3><p>1 了解python 基本语法以及基本语法以及图像处理API--OpenCV。</p><p>2 了解opencv图像基础操作函数。</p><h3 id="六实验">六、实验</h3><h4 id="示例程序">1.示例程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv <span class="comment">#引入 OpenCV库</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;1.jpg&#x27;</span>) <span class="comment">#使用 imread函数读取图像 ，并以 numpy数组形式储存</span></span><br><span class="line"><span class="built_in">print</span>(img.shape) <span class="comment">#查看图像的大小。返回的元组（ touple）中的三个数依次表示高度、宽度和通道数</span></span><br><span class="line"><span class="built_in">print</span>(img.dtype) <span class="comment">#查看图片的类型</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;img&#x27;</span>,img) <span class="comment">#使用 imshow函数显示图像，第一个参数是窗口名称（可不写），第二个参数是要显示的图像的名称，一定要写</span></span><br><span class="line">cv.waitKey(<span class="number">0</span>) <span class="comment">#可以让窗口一直显示图像直到按下任意按键</span></span><br><span class="line">img_GRAY = cv.cvtColor(img,cv.COLOR_BGR2GRAY) <span class="comment">#使用 cv.cvtColor函数转换色彩空间 参数 ‘cv.COLOR_BGR2GRAY’表示从RGB空间转换到灰度空间</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;gray&#x27;</span>,img_GRAY)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">ret,thresh = cv.threshold(img_GRAY,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY) <span class="comment">#使用 cv.threshold函数进行图像阈值处理 参数‘cv.THRESH_BINARY’代表了阈值的类型 127为阈值</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;threshold&#x27;</span>,thresh)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">res = cv.resize(img,<span class="literal">None</span>,fx=<span class="number">2</span>,fy=<span class="number">2</span>,interpolation=cv.INTER_CUBIC) <span class="comment">#使用 cv.resize函数进行图像缩放</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;resize&#x27;</span>,res)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.imwrite(<span class="string">&#x27;result.jpg&#x27;</span>,res) <span class="comment">#保存图像</span></span><br></pre></td></tr></table></figure><h4 id="实验程序">2 实验程序</h4><p>1利用OpenCV读取一幅彩色图像，并读取图像的基本信息；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python:</span><br><span class="line">retval=cv.imread(filename[, flags])</span><br><span class="line">从文件加载图像。函数IMRead从指定文件加载图像并返回它。 如果无法读取图像（由于缺少文件，不正确的权限，不受支持或无效格式），则该函数返回一个空矩阵（MAT :: data == null）。</span><br></pre></td></tr></table></figure><h5 id="访问和修改像素值"><ahref="https://opencv.apachecn.org/#/docs/4.0.0/3.1-tutorial_py_basic_ops?id=访问和修改像素值">访问和修改像素值</a></h5><p>先来理解一下，图像与一般的矩阵或张量有何不同(不考虑图像的格式，元数据等信息)。首先，一张图像有自己的属性，宽，高，通道数。其中宽和高是我们肉眼可见的属性，而通道数则是图像能呈现色彩的属性。我们都知道，光学三原色是红色，绿色和蓝色，这三种颜色的混合可以形成任意的颜色。常见的图像的像素通道也是对应的R，G，B三个通道，在OpenCV中，每个通道的取值为0～255，。(注：还有RGBA，YCrCb，HSV等其他图像通道表示)。即，一般彩色图像读进内存之后是一个h* w *c的矩阵，其中h为图像高(相当于矩阵的行)，w为图像宽(相当于矩阵列)，c为通道数。</p><p>下面我们先加载一副彩色图像，更准确的说，是一副黄色图像，如图所示。</p><figure><imgsrc="%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/yellow-16500308353862.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>黄色为绿色和红色的混合，所以，该图像的所有像素值都应为R=255，G=255，B=0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img = cv2.imread(<span class="string">&quot;img/yellow.jpg&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h,w,c = img.shape</span><br><span class="line"><span class="comment">#图像为128*128*3的大小</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(h,w,c)</span><br><span class="line"><span class="number">128</span> <span class="number">128</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，您可以通过行和列坐标访问像素值。注意,对于常见的RGB图像，OpenCV的imread函数返回的是一个蓝色(Blue)、绿色(Green)、红色(Red)值的数组，维度大小为3。而对于灰度图像，仅返回相应的强度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">100</span>,<span class="number">100</span>]</span><br><span class="line"><span class="comment">#OpenCV的读取顺序为B，G，R，由于图像所有像素为黄色，因此，G=255，R=255</span></span><br><span class="line">array([  <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>], dtype=uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅访问蓝色通道的像素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blue = img[<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(blue)</span><br><span class="line"><span class="number">0</span>复制ErrorOK!</span><br></pre></td></tr></table></figure><p>你也可以使用同样的方法来修改像素值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">100</span>,<span class="number">100</span>] = [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(img[<span class="number">100</span>,<span class="number">100</span>])</span><br><span class="line">[<span class="number">255</span> <span class="number">255</span> <span class="number">255</span>]</span><br></pre></td></tr></table></figure><p>2 利用OpenCV显示图像；</p><p>3 对彩色图像进行灰度化化处理；</p><p>4 对灰度图像进行二值化处理；</p><p>5 对图像进行几何变换（缩放，平移，翻转）；</p><p>6 储存处理后的图像；</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理，opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于多目标优化的电梯智能群控算法</title>
      <link href="/2022/04/03/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/"/>
      <url>/2022/04/03/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2id="基于多目标优化的电梯智能群控算法">基于多目标优化的电梯智能群控算法</h2><span id="more"></span><h3 id="多目标优化函数选取">1、多目标优化函数选取</h3><h4 id="候梯时间评价函数">1.1 候梯时间评价函数</h4><p>乘客的候梯时间 <span class="math inline">\(WT(i，j)\)</span> <spanclass="math display">\[WT(i,j)=t_{run}+t_{stop}\]</span> 其中<spanclass="math inline">\(t_{run}\)</span>表示电梯的行驶时间，<spanclass="math inline">\(t_{stop}\)</span>表示电梯运行停止时间。电梯的行驶时间是由电梯的匀速行驶时间以及电梯的加减速时间所构成，因此，影响电梯运行时间的因素有电梯的运行速度，电梯的加速度</p>]]></content>
      
      
      <categories>
          
          <category> 优化算法，电梯群控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
            <tag> 电梯调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog HDL 语法</title>
      <link href="/2022/04/01/Verilog-HDL-%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/04/01/Verilog-HDL-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="verilog-hdl-语法">Verilog HDL 语法</h2><p>Verilog HDL (Hardware Description Language)是在用途最广泛的C语言的基础上发展起来的一种硬件描述语言 ，具有灵活性高、易学易用等特点。Verilog HDL可以在较短的时间内学习和掌握，目前已经在 FPGA开发 /IC设计领域占据 绝对的领导地位。</p><span id="more"></span><h3 id="verilog基础知识">1 Verilog基础知识</h3><h4 id="verilog的-逻辑值">1.1 Verilog的 逻辑值</h4><p>我们先看下逻辑 电路 中有四种值，即四种状态：</p><p>逻辑0：表示低电平，也就是对应我们电路的 GND</p><p>逻辑1：表示高电平，也就是对应我们电路的 VCC</p><p>逻辑X：表示未知，有可能是高电平，也有可能是低电平</p><p>逻辑Z：表示高阻态，外部没有激励信号是一个悬空状态。</p><p>如下图所示：</p><p><img src="image-20220401152308016.png" alt="image-20220401152308016"  /></p><center style="color=#C0C0C0;text-decoration:underline">图1.1 Verilog逻辑值</center><h4 id="verilog的标识符">1.2 Verilog的标识符</h4><h5 id="定义">定义</h5><p>标识符(identifier）用于定义模块名、端口名和信号名等。Verilog的标识符可以是任意一组字母、数字、$和 _(下划线 )符号的组合，但标识符的第一个字符必须是字母或者下划线。另外，标识符是区分大小写的。以下是标识符的几个例子：</p><p>Count</p><p>COUNT //与 Count不同。</p><p>R56_68</p><p>FIVE$</p><p>虽然 标识符写法很多，但是要简洁、清晰、易懂，推荐写法如下：</p><p>count</p><p>fifo_wr</p><p>不建议大小写混合使用，普通内部信号建议全部小写，参数定义建议大写，另外信号命名最好体现信号的含义。</p><h5 id="规范建议">规范建议</h5><p>以下是一些书写规范的要求：</p><p>1、用有意义的有效的名字如 sum、 cpu_addr等。</p><p>2、用下划线区分词语组合，如 cpu_addr。</p><p>3、采用一些前缀或后缀，比如：时钟采用 clk前缀： clk_50mclk_cpu；低电平采用 _n后缀： enable_n</p><p>4、统一缩写，如全局复位信号 rst。</p><p>5、同一信号在不同层次保 持一致性，如同一时钟信号必须在各模块保持一致。</p><p>6、自定义的标识符不能与保留字（关键词）同名。</p><p>7、参数统一采用大写，如定义参数 使用 SIZE</p><h4 id="verilog的数字进制格式">1.3 Verilog的数字进制格式</h4><p>Verilog数字 进制格式包括二进制、 八进制 、 十进制和十六进制，一般常用的为二进制、十进制和十六进制。</p><p>二进制表示 如下： 4’b0101表示 4位 二进制数字 0101</p><p>十进制表示 如下： 4’d2表示 4位十进制数字 2（二进制 0010</p><p>十六进制表示 如下： 4’ha表示 4位十六 进制数字 a（二进制1010），十六进制 的计数方式为 0 1 2…9a b c d e f 最大计数为 f f：十 进制表示为 15）。</p><p>当代码中没有指定数字的位宽与进制时，默认为32位的十进制，比如100，实际上表示的值为32’d100。</p><h4 id="verilog的数据类型">1.4 Verilog的数据类型</h4><p>在Verilog语法中，主要有三大类数据类型，即寄存器类型、线网类型和参数类型。从名称中，我们可以看出，真正在数字电路中起作用的数据类型应该是寄存器类型和线网类型。</p><p>1、寄存器类型</p><p>寄存器类型表示一个抽象的数据存储单元，它只能在always语句和initial语句中被赋值，并且它的值从一个赋值到另一个赋值过程中被保存下来。如果该过程语句描述的是时序逻辑，即always语句带有时钟信号，则该寄存器变量对应为寄存器；如果该过程语句描述的是组合逻辑即always语句不带有时钟信号则该寄存器变量对应为硬件连线；寄存器类型的缺省值是x（未知状态）。</p><p>寄存器数据类型有很多种，如reg、 integer、 real等，其中最常用的就是reg类型，它的使用方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reg define </span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] delay_cnt; </span><br><span class="line"><span class="comment">//延时计数器 </span></span><br><span class="line"><span class="keyword">reg</span>    key_flag ; <span class="comment">//按键标志</span></span><br></pre></td></tr></table></figure><p>2、线网类型</p><p>线网表示Verilog结构化元件间的物理连线。它的值由驱动元件的值决定，例如连续赋值或门的输出。如果没有驱动元件连接到线网，线网的缺省值为z（高阻态）。线网类型同寄存器类型一样也是有很多种如 tri和wire等，其中最常用的就是 wire类型，它的使用方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wire define </span></span><br><span class="line"><span class="keyword">wire</span>       data_en; <span class="comment">//数据使能信号 </span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data ; <span class="comment">//数据</span></span><br></pre></td></tr></table></figure><p>3、参数类型</p><p>我们再来看下参数类型 ，参数其实就是一个常量，常被用于定义状态机的状态、数据位宽和延迟大小等，由于它可以在编译时修改参数的值，因此它又常被用于一些参数可调的模块中，使用户在实例化模块时，可以根据需要配置参数。在定义参数时，我们可以一次定义多个参数，参数与参数之间需要用逗号隔开。这里我们需要注意的是参数的定义是局部的，只在当前模块中有效。它的使用方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parameter define </span></span><br><span class="line"><span class="keyword">parameter</span> DATA_WIDTH = <span class="number">8</span>; <span class="comment">//数据位宽为8位</span></span><br></pre></td></tr></table></figure><h4 id="verilog的运算符">1.5 Verilog的运算符</h4><p>大家看完了 Verilog的 数据类型 我们再来介绍下 Verilog的运算符。Verilog中的运算符按照功能可以分为下述类型： 1、算术运算符、2、关系运算符、 3、逻辑运算符、 4、条件运算符、 5、位运算符、6、移位运算符、 7、拼接运算符。下面我们分别 对 这些运算符进行介绍。</p><p>1、算术运算符</p><p>算术运算符，简单来说，就是数学运算里面的加减乘除，数字逻辑处理有时候也需要进行数字运算，所以需要算术运算符。常用的算术运算符主要包括加减乘除和模除（模除运算也叫取余运算）如下表 所示</p><center style="color=#C0C0C0;text-decoration:underline">表1.1 算术运算符</center><p><img src="image-20220401161008229.png" alt="image-20220401161008229" style="zoom: 80%;" /></p><p>大家要注意下， Verilog实现乘除比较浪费组合逻辑资源，尤其是除法 。一般2的指数次幂的乘除法使用移位运算来完成运算 ，详情 可以看移位运算符章节 。非2的指数次幂的乘除法一般是 调用 现成的IPQUARTUS/ISE等工具软件会有提供， 不过这些工具软件提供的 IP也是 由 最底层的 组合逻辑 (与 或非门等 )搭建而成的。</p><p>2、关系运算符</p><p>关系运算符主要是用来做一些条件判断用的，在进行关系运算符时，如果声明的关系是假的，则返回值是0，如果声明的关系是真的，则返回值是1；所有的关系运算符有着相同的优先级别，关系运算符的优先级别低于算术运算符的优先级别如下表所示。</p><center style="color=#C0C0C0;text-decoration:underline">表1.2 关系运算符</center><p><img src="image-20220401161352566.png" alt="image-20220401161352566" style="zoom:80%;" /></p><p>3、逻辑运算符</p><p>逻辑运算符是连接多个关系表达式用的，可实现更加复杂的判断，一般不单独使用，都需要配合具体语句来实现完整的意思，如下表 所示。</p><center style="color=#C0C0C0;text-decoration:underline">表1.3 逻辑运算符</center><p><img src="image-20220401163025582.png" alt="image-20220401163025582" style="zoom:80%;" /></p><p>4、条件运算符</p><p>条件操作符一般来构建从两个输入中选择一个作为输出的条件选择结构，功能等同于always中的ifelse语句，如 下表 所示。</p><center style="color=#C0C0C0;text-decoration:underline">表1.4 条件运算符</center><p><img src="image-20220401163137576.png" alt="image-20220401163137576" style="zoom:80%;" /></p><p>5、位运算符</p><p>位运算符是一类最基本的运算符，可以认为它们直接对应数字逻辑中的与、或、非门等逻辑门。常用的位运算符如 下表 所示 。</p><center style="color=#C0C0C0;text-decoration:underline">表1.5 位运算符</center><p><img src="image-20220401190024356.png" alt="image-20220401190024356" style="zoom:80%;" /></p><p>位运算符的与、或、非与逻辑运算符逻辑与、逻辑或、逻辑非使用时候容易混淆，逻辑运算符一般用在条件判断上，位运算符一般用在信号赋值上。</p><p>6、移位运算符</p><p>移位运算符包括左移位运算符和右移位运算符，这两种移位运算符都用0来填补移出的空位。如下表所示 。</p><center style="color=#C0C0C0;text-decoration:underline">表1.6 移位运算符</center><p><img src="image-20220401190234108.png" alt="image-20220401190234108" style="zoom:80%;" /></p><p>假设a有 8bit数据 位宽 ，那么 a&lt;&lt;2，表示 a左 移 2bit a还是8bit数据位宽 a的最高 2bit数据被移位丢弃了，最低 2bit数据 固 定 补 0。如果 a是 3（二进制 00000011 那么 3左 移 2bit 3&lt;&lt;2 就是12（二进制： 00001100）。 一般使用左移位 运算代替乘法 ，右移位运算代替除法但是这种也只能表示 2的指数次幂的乘除法。</p><p>7、拼接运算符</p><p>Verilog中有一个特殊的运算符 是 C语言中没有的，就是位拼接运算符。用这个运算符可以把两个或多个信号的某些位拼接起来进行运算操作。如下表 所示</p><center style="color=#C0C0C0;text-decoration:underline">表1.7 拼接运算符A</center><p><img src="image-20220401190535911.png" alt="image-20220401190535911" style="zoom:80%;" /></p><p>8、运算符的优先级</p><p>介绍完了 这么多运算符，大家可能 会想到究竟哪个运算符高，哪个运算符低。为了便于大家查看这些运算符的优先级，我们将它们制作成了表格，如下表所示。</p><center style="color=#C0C0C0;text-decoration:underline">表1.7 运算符的优先级</center><p><img src="image-20220401190619799.png" alt="image-20220401190619799" style="zoom:80%;" /></p><h3 id="verilog程序框架">2 Verilog程序框架</h3><h4 id="注释">2.1 注释</h4><p>Verilog HDL中有两种注释的方式，一种是以“ “/<em>”符号开始，“</em>/”结束，在两个符号之间的语句都是注释语句，因此可扩展到多行。如：</p><p>/* statement1</p><p>statement2</p><p>......</p><p>statementn */</p><p>以上</p><p>n个语句都是注释语句。</p><p>另一种是以</p><p>//开头的语句，它表示以 //开始到本行结束都属于注释 语句。如：</p><p>//statement1</p><p>我们建议的写法：使用//作为注释。</p><h4 id="关键字">2.2 关键字</h4><p>Verilog和 C语言 类似，都因编写需要定义了一系列保留字，叫做关键字（或关键词）。这些保留字是识别语法的关键 。我们给大家列出了Verilog中 的关键字，如下表所示。</p><center style="color=#C0C0C0;text-decoration:underline">表2.1 Verilog的所有关键字</center><p><img src="image-20220401191332360.png" alt="image-20220401191332360"  /></p><p>虽然上 表 列了很多，但是实际 经常 使用的不是很多，实际 经常使用的主要 如下 表 所示。</p><center style="color=#C0C0C0;text-decoration:underline">表2.1 Verilog常用的关键字</center><p><img src="image-20220401191428325.png" alt="image-20220401191428325"  /></p><p>注意只有小写的关键字才是保留字。例如，标识符always(这是个关键词)与标识符 ALWAYS(非关键词 )是不同的。</p><h4 id="程序框架">2.3 程序框架</h4><p>我们以 LED流水灯程序 为 例来 给大家展示 Verilog的程序框架 ，代码如下所示（注意：代码中前面的行号只是为了方便大家阅读代码与快速定位到行号的位置，在实际编写代码时不可以添加行号，否则编译代码时会报错）。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File name:           led_twinkle</span></span><br><span class="line"><span class="comment">// Last modified Date:  2019/4/14 10:55:56</span></span><br><span class="line"><span class="comment">// Last Version:        V1.0</span></span><br><span class="line"><span class="comment">// Descriptions:        LED灯闪烁</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Created by:          正点原子</span></span><br><span class="line"><span class="comment">// Created date:        2019/4/14 10:55:56</span></span><br><span class="line"><span class="comment">// Version:             V1.0</span></span><br><span class="line"><span class="comment">// Descriptions:        The original version</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//****************************************************************************************//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> led_twinkle(</span><br><span class="line">    <span class="keyword">input</span>          sys_clk  ,  <span class="comment">//系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>          sys_rst_n,  <span class="comment">//系统复位，低电平有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span>  [<span class="number">1</span>:<span class="number">0</span>]  led         <span class="comment">//LED灯</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">25</span>:<span class="number">0</span>]  cnt ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************************************************</span></span><br><span class="line"><span class="comment">//**                    main code</span></span><br><span class="line"><span class="comment">//*****************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对计数器的值进行判断，以输出LED的状态</span></span><br><span class="line"><span class="keyword">assign</span> led = (cnt &lt; <span class="number">26&#x27;d2500_0000</span>) ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b10</span> ;</span><br><span class="line"><span class="comment">//assign led = (cnt &lt; 26&#x27;d5)         ? 2&#x27;b01 : 2&#x27;b10 ;  //仅用于仿真</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计数器在0~5000_000之间进行计数</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">        cnt &lt;= <span class="number">26&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt; <span class="number">26&#x27;d5000_0000</span>)</span><br><span class="line"><span class="comment">//  else if(cnt &lt; 26&#x27;d10)  //仅用于仿真</span></span><br><span class="line">        cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt &lt;= <span class="number">26&#x27;d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FPAG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Revolute Joint 模块</title>
      <link href="/2022/03/31/Revolute-Joint-%E6%A8%A1%E5%9D%97/"/>
      <url>/2022/03/31/Revolute-Joint-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="revolute-joint-模块">Revolute Joint 模块</h2><span id="more"></span><p>Joint with one revolute primitive 一个初试的旋转关节</p><ul><li><strong>Library:</strong>Simscape / Multibody / Joints</li></ul><h3 id="description">Description</h3><p>The Revolute Joint block models a joint that has one rotationaldegree of freedom.</p><p>Revolute Joint 模块模拟具有一个旋转自由度的关节。</p><p><img src="image-20220331122431883.png" alt="image-20220331122431883" style="zoom:150%;" /></p><p>The joint constrains the motion of two arbitrary frames that connectto the base and follower frames of the joint to pure rotation about acommon axis. The axis of rotation is aligned with the <em>z</em>-axis ofthe joint base frame. The base and follower frames have a common originand <em>z</em>-axis, and the follower frame rotates about the<em>z</em>-axis, as shown in the image.</p><p>关节将连接到关节的基础框架和从动框架的两个任意框架的运动限制为围绕公共轴进行纯旋转。旋转轴与关节基础框架的 z 轴对齐。如图所示，基础框架和跟随框架具有共同的原点和 z 轴，并且跟随框架围绕 z轴旋转。</p><p><img src="image-20220331122451755.png" alt="image-20220331122451755" style="zoom:150%;" /></p><p>To target the initial state of the a joint primitive, use theparameters under <strong>State Targets</strong>. The position andvelocity targets are resolved in the base frame. You can also set thepriority levels for the targets. If the block cannot simultaneouslysatisfy the state targets, the priority level determines which targetsto satisfy first and how closely to satisfy them. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/assembling-multibody-systems.html#busaiy6-1">GuidingAssembly</a> for more information.</p><p>要定位关节图元的初始状态，请使用 <strong>State Targets</strong>下的参数。 位置和速度目标在基本框架中解析。 您还可以设置目标的优先级。如果块不能同时满足状态目标，则优先级确定首先满足哪些目标以及满足这些目标的程度。更多信息见【指导组装】(https://ww2.mathworks.cn/help/physmod/sm/ug/assemble-multibody-systems.html#busaiy6-1)。</p><p>To model damping and spring behavior in a joint primitive, use theparameters under <strong>Internal Mechanics</strong>. Specify jointdamping coefficients to model energy dissipation and joint springstiffness to model energy storage. Springs resist attempts to displacethe joint primitive from its equilibrium position. Joint dampers act asenergy dissipation elements. Springs and dampers are strictlylinear.</p><p>要模拟关节基本体中的阻尼和弹簧行为，请使用内部力学下的参数。指定关节阻尼系数来模拟能量耗散和关节弹簧刚度来模拟能量存储。弹簧抵抗试图将关节基元从其平衡位置移开的尝试。关节阻尼器充当能量耗散元件。 弹簧和阻尼器是严格线性的。</p><p>To specify the limits of a joint primitive, use the parameters under<strong>Limits</strong>. The lower and upper bounds define the width ofthe free region of a joint primitive. The block applies a force ortorque to accelerate the joint position back to the free region when theposition exceeds the bounds. The block uses a smoothed spring-dampermethod to compute the force or torque. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ref/spatialcontactforce.html#mw_acd246fe-915a-4822-9c50-b9aa9debb1ce">Description</a>section of the <ahref="https://ww2.mathworks.cn/help/physmod/sm/ref/spatialcontactforce.html">SpatialContact Force</a> block for more information about the smoothedspring-damper method.</p><p>要指定关节基本体的限制，请使用“限制”下的参数。下限和上限定义了关节图元的自由区域的宽度。当位置超出界限时，该块会施加力或扭矩以将关节位置加速回到自由区域。该块使用平滑弹簧阻尼器方法来计算力或扭矩。有关平滑弹簧阻尼器方法的更多信息，请参见空间接触力模块的描述部分。</p><p>A revolute primitive provides two actuation parameters,<strong>Torque</strong> and <strong>Motion</strong>, that govern themotion of the primitive during a simulation. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/joint-actuation.html">SpecifyingJoint Actuation Inputs</a> for more information. Additionally, the blockhas ports that output sensing data, such as position, velocity,acceleration, forces, and torques, that enable you to perform analyticaltasks on a model. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/sensing.html">Sensing</a>and <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><p>旋转基元提供两个驱动参数，扭矩和运动，它们在模拟过程中控制基元的运动。有关详细信息，请参阅指定关节驱动输入。此外，该模块具有输出传感数据的端口，例如位置、速度、加速度、力和扭矩，使您能够对模型执行分析任务。有关详细信息，请参阅传感和力和扭矩传感。</p><h3 id="ports">Ports</h3><h4 id="frame">Frame</h4><h5 id="b-base-frame"><code>B</code> — Base frame</h5><p>Base frame of the joint block.</p><h5 id="f-follower-frame"><code>F</code> — Follower frame</h5><p>Follower frame of the joint block.</p><h4 id="input">Input</h4><h5id="t-actuation-torque-physical-signal-驱动扭矩物理信号"><code>t</code>— Actuation torque physical signal 驱动扭矩物理信号</h5><p>Physical signal input port that accepts the actuation torque for thejoint primitive. The signal provides the value of the torque thatapplies on both the base and follower frames of the joint primitive.</p><h6 id="dependencies">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Actuation</strong>, set <strong>Torque</strong> to<code>Provided by Input</code>.</p><p>接受关节图元的驱动扭矩的物理信号输入端口。该信号提供了应用于关节图元的基础框架和从动框架的扭矩值。</p><p>依赖项</p><p>要启用此端口，请在 Z Revolute Primitive (Rz) &gt; Actuation 下，将Torque 设置为由 Input 提供。</p><h5 id="q-motion-profile-physical-signal"><code>q</code> — Motionprofile physical signal</h5><p>Physical signal input port that accepts the motion profile for thejoint primitive. The signal provides the rotation of the follower framewith respect to the base frame about the joint primitive axis. Note thatthe signal must also contain the first and second derivatives of therotation.</p><h6 id="dependencies-1">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Actuation</strong>, set <strong>Motion</strong> to<code>Provided by Input</code>.</p><p>物理信号输入端口，接受关节基元的运动轮廓。该信号提供了从动框架相对于基本框架绕关节图元轴的旋转。请注意，信号还必须包含旋转的一阶和二阶导数。</p><h6 id="依赖项">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Actuation</strong> 下，将 <strong>Motion</strong> 设置为<code>Provided by Input</code>。</p><h5id="mode-joint-mode-control-scalar-关节模式控制标量"><code>mode</code> —Joint mode control scalar 关节模式控制标量</h5><p>Input port that controls the joint mode. The signal is a unitlessscalar. The joint mode is normal when the input signal is 0 anddisengaged when the input signal is -1. The joint mode can be changedmany times during a simulation.</p><h6 id="dependencies-2">Dependencies</h6><p>To enable this port, under <strong>Mode Configuration</strong>, set<strong>Mode</strong> to <code>Provided by Input</code>.</p><p>控制关节模式的输入端口。 信号是无单位标量。输入信号为0时关节模式正常，输入信号-1时关节模式断开。在模拟过程中可以多次更改关节模式。</p><h6 id="依赖项-1">依赖项</h6><p>要启用此端口，请在 <strong>Mode Configuration</strong> 下，将<strong>Mode</strong> 设置为 <code>Provided by Input</code>。</p><h4 id="output">Output</h4><h5id="q-position-of-joint-primitive-physical-signal-关节原始物理信号的位置"><code>q</code>— Position of joint primitive physical signal关节原始物理信号的位置</h5><p>Physical signal port that outputs the position of the jointprimitive. The value is the rotation angle of the follower frame withrespect to the base frame.</p><h6 id="dependencies-3">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Position</strong>.</p><p>输出关节图元位置的物理信号端口。该值是从动框架相对于基础框架的旋转角度。</p><h6 id="依赖项-2">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Position</strong>。</p><h5id="w-first-derivative-of-position-of-joint-primitive-physical-signal"><code>w</code>— First derivative of position of joint primitive physical signal</h5><p>Physical signal port that outputs the first derivative of position ofthe joint primitive.</p><h6 id="dependencies-4">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Velocity</strong>.</p><p>输出关节图元位置的一阶导数的物理信号端口。</p><h6 id="依赖项-3">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Velocity</strong>。</p><h5id="b-second-derivative-of-position-of-joint-primitive-physical-signal"><code>b</code>— Second derivative of position of joint primitive physical signal</h5><p>关节原始物理信号位置的二阶导数</p><p>Physical signal port that outputs the second derivative of positionof the joint primitive.</p><h6 id="dependencies-5">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Acceleration</strong>.</p><p>输出关节图元位置二阶导数的物理信号端口。</p><h6 id="依赖项-4">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Acceleration</strong>。</p><h5id="t-actuator-torque-acting-on-joint-primitive-physical-signal"><code>t</code>— Actuator torque acting on joint primitive physical signal</h5><p>Physical signal port that outputs the actuator torque acting on thejoint primitive.</p><h6 id="dependencies-6">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>ActuatorTorque</strong>.</p><p>输出作用在关节基元上的执行器扭矩的物理信号端口。</p><h6 id="依赖项-5">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Actuator Torque</strong>。</p><h5 id="tll-lower-limit-torque-physical-signal"><code>tll</code> —Lower-limit torque physical signal</h5><p>Physical signal port that outputs the lower-limit torque. The blockapplies the torque when the joint primitive position exceeds the lowerbound of the free region. The torque applies to both the base andfollower frames of the joint primitive to accelerate the position backto the free region.</p><h6 id="dependencies-7">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Lower-LimitTorque</strong>.</p><p>输出下限扭矩的物理信号端口。当关节基元位置超过自由区域的下限时，该模块将应用扭矩。扭矩适用于关节图元的基础框架和跟随框架，以将位置加速回到自由区域。</p><h6 id="依赖项-6">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Lower-LimitTorque</strong>。</p><h5 id="tul-upper-limit-torque-physical-signal"><code>tul</code> —Upper-limit torque physical signal</h5><p>Physical signal port that outputs the upper-limit torque. The blockapplies the torque when the joint primitive position exceeds the upperbound of the free region. The torque applies to both the base andfollower frames of the joint primitive to accelerate the position backto the free region.</p><h6 id="dependencies-8">Dependencies</h6><p>To enable this port, under <strong>Z Revolute Primitive (Rz)</strong>&gt; <strong>Sensing</strong>, select <strong>Upper-LimitTorque</strong>.</p><p>输出上限扭矩的物理信号端口。当关节基元位置超过自由区域的上限时，该模块将应用扭矩。扭矩适用于关节图元的基础框架和跟随框架，以将位置加速回到自由区域。</p><h6 id="依赖项-7">依赖项</h6><p>要启用此端口，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>Sensing</strong> 下，选择 <strong>Upper-LimitTorque</strong>。</p><h5 id="fc-constraint-force-physical-signal"><code>fc</code> —Constraint force physical signal</h5><p>Physical signal port that outputs constraint force that acts in thejoint. The force maintains the translational constraints of the joint.See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/sense-internal-forces-in-double-pendulum-link.html">SenseConstraint Forces</a> for more information.</p><h6 id="dependencies-9">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Constraint Force</strong>.</p><p>输出作用于关节的约束力的物理信号端口。 力保持关节的平移约束。更多信息参见【感知约束力】(https://ww2.mathworks.cn/help/physmod/sm/ug/sense-internal-forces-in-double-pendulum-link.html)。</p><h6 id="依赖项-8">依赖项</h6><p>要启用此端口，请在 <strong>Composite Force/Torque Sensing</strong>下，选择 <strong>Constraint Force</strong>。</p><h5 id="tc-constraint-torque-physical-signal"><code>tc</code> —Constraint torque physical signal</h5><p>Physical signal port that outputs constraint torque that acts in thejoint. The torque maintains the rotational constraints of the joint. See<ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><h6 id="dependencies-10">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Constraint Torque</strong>.</p><p>输出作用于关节的约束扭矩的物理信号端口。 扭矩保持关节的旋转约束。有关详细信息，请参阅力和扭矩传感。</p><h6 id="依赖项-9">依赖项</h6><p>要启用此端口，请在 Composite Force/Torque Sensing 下选择 ConstraintTorque。</p><h5 id="ft-total-force-physical-signal"><code>ft</code> — Total forcephysical signal</h5><p>Physical signal port that outputs the total force that acts in thejoint. The total force is the sum of the forces transmitted from oneframe to the other through the joint. The force includes actuation,internal, limit and constraint forces. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><h6 id="dependencies-11">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Total Force</strong>.</p><p>输出作用于关节的总力的物理信号端口。总力是通过关节从一帧传递到另一帧的力的总和。力包括驱动力、内部力、限制力和约束力。更多信息请参见【力和扭矩传感】（https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。###### 依赖项 要启用此端口，请在 <strong>Composite Force/TorqueSensing</strong> 下，选择 <strong>Total Force</strong>。</p><h5 id="tt-total-torque-physical-signal"><code>tt</code> — Total torquephysical signal</h5><p>Physical signal port that outputs the total torque that acts in thejoint. The total torque is the sum of the torques transmitted from oneframe to the other through the joint. The torque includes actuation,internal, limit, and constraint torques. See <ahref="https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html">Forceand Torque Sensing</a> for more information.</p><h6 id="dependencies-12">Dependencies</h6><p>To enable this port, under <strong>Composite Force/TorqueSensing</strong>, select <strong>Total Torque</strong>.</p><p>输出作用于关节的总扭矩的物理信号端口。总扭矩是从一个框架通过关节传递到另一个框架的扭矩之和。扭矩包括致动扭矩、内部扭矩、限制扭矩和约束扭矩。更多信息请参见【力和扭矩传感】（https://ww2.mathworks.cn/help/physmod/sm/ug/force-and-torque-sensing.html）。</p><h6 id="依赖项-10">依赖项</h6><p>要启用此端口，请在 <strong>Composite Force/Torque Sensing</strong>下，选择 <strong>Total Torque</strong>。</p><h3 id="parameters">Parameters</h3><h4 id="z-revolute-primitive-rz">Z Revolute Primitive (Rz)</h4><h5id="state-targets-specify-position-target-whether-to-specify-position-target-off-default-on"><code>State Targets &gt; Specify Position Target</code>— Whether to specify position target <code>off</code> (default) |<code>on</code></h5><p>State Targets &gt; Specify PositionTarget<code>— 是否指定位置目标</code>off<code>（默认） |</code>开</p><p>Select this parameter to enable parameters that specify the positiontarget of the joint primitive.</p><p>选择此参数以启用指定关节图元位置目标的参数。</p><h5id="state-targets-specify-position-target-priority-priority-level-of-position-target-high-desired-default-low-approximate"><code>State Targets &gt; Specify Position Target &gt; Priority</code>— Priority level of position target <code>High (desired)</code>(default) | <code>Low (approximate)</code></h5><p>状态目标 &gt; 指定位置目标 &gt; 优先级 -位置目标的优先级高（需要）（默认）| 低（大约）</p><p>Priority level of the position target, specified as<code>High (desired)</code> or <code>Low (approximate)</code>.</p><h6 id="dependencies-13">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Position Target</strong>.</p><p>位置目标的优先级，指定为“高（期望）”或“低（近似）”。</p><h6 id="依赖项-11">依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>State Targets</strong> 下，选择 <strong>Specify PositionTarget</strong>。</p><h5id="state-targets-specify-position-target-value-angle-of-position-target-0-deg-default-scalar-with-a-unit-of-angle"><code>State Targets &gt; Specify Position Target &gt; Value</code>— Angle of position target 0 <code>deg</code> (default) | scalar with aunit of angle</h5><p>Angle to specify the position target, specified as a scalar with aunit of angle.</p><h6 id="dependencies-14">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Position Target</strong>.</p><p>指定位置目标的角度，指定为以角度为单位的标量。</p><p>依赖项 要启用此参数，请在 Z Revolute Primitive (Rz) &gt; StateTargets 下选择指定位置目标。</p><h5id="state-targets-specify-velocity-target-whether-to-specify-velocity-target-off-default-on"><code>State Targets &gt; Specify Velocity Target</code>— Whether to specify velocity target <code>off</code> (default) |<code>on</code></h5><p>Select this parameter to enable parameters for that specify thevelocity target of the joint primitive.</p><p>选择此参数以启用指定关节图元的速度目标的参数。</p><h5id="state-targets-specify-velocity-target-priority-priority-level-of-velocity-target-high-desired-default-low-approximate"><code>State Targets &gt; Specify Velocity Target &gt; Priority</code>— Priority level of velocity target <code>High (desired)</code>(default) | <code>Low (approximate)</code></h5><p>Priority level of the velocity target, specified as<code>High (desired)</code> or <code>Low (approximate)</code>.</p><h6 id="dependencies-15">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Velocity Target</strong>.</p><p>速度目标的优先级，指定为“高（期望）”或“低（近似）”。</p><h6 id="依赖项-12">依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>State Targets</strong> 下，选择 <strong>Specify VelocityTarget</strong>。</p><h5id="state-targets-specify-velocity-target-value-velocity-target-of-joint-primitive-0-degs-default-scalar-with-unit-of-angular-velocity"><code>State Targets &gt; Specify Velocity Target &gt; Value</code>— Velocity target of joint primitive 0 <code>deg/s</code> (default) |scalar with unit of angular velocity</h5><p>Velocity target of the joint primitive, specified as a scalar with aunit of angular velocity.</p><h6 id="dependencies-16">Dependencies</h6><p>To enable this parameter, under <strong>Z Revolute Primitive(Rz)</strong> &gt; <strong>State Targets</strong>, select<strong>Specify Velocity Target</strong>.</p><p>关节图元的速度目标，指定为具有角速度单位的标量。</p><h6 id="依赖项-13">依赖项</h6><p>要启用此参数，请在 <strong>Z Revolute Primitive (Rz)</strong> &gt;<strong>State Targets</strong> 下，选择 <strong>Specify VelocityTarget</strong>。</p><h5id="internal-mechanics-equilibrium-position-position-where-internal-torque-is-zero-0-deg-default-scalar-with-unit-of-angle"><code>Internal Mechanics &gt; Equilibrium Position</code>— Position where internal torque is zero 0 <code>deg</code> (default) |scalar with unit of angle</h5><p>内部扭矩为零的位置 0 <code>deg</code>（默认）| 以角度为单位的标量</p><p>Position where the spring torque is zero, specified as a scalar witha unit of angle. The value specifies the rotation angle of the followerframe with respect to the base frame.</p><p>弹簧扭矩为零的位置，指定为具有角度单位的标量。该值指定从动框架相对于基础框架的旋转角度。</p><h5id="internal-mechanics-spring-stiffness-stiffness-of-force-law-0-nmdeg-default-scalar-with-unit-of-stiffness"><code>Internal Mechanics &gt; Spring Stiffness</code>— Stiffness of force law 0 <code>N*m/deg</code> (default) | scalar withunit of stiffness</h5><p>Stiffness of the internal spring-damper force law for the jointprimitive, specified as a scalar with a unit of stiffness.</p><p>关节基元的内部弹簧阻尼力定律的刚度，指定为具有刚度单位的标量。</p><h5id="internal-mechanics-damping-coefficient-damping-coefficient-of-force-law-0-nmdegs-default-scalar-with-unit-of-damping-coefficient"><code>Internal Mechanics &gt; Damping Coefficient</code>— Damping coefficient of force law 0 <code>N*m/(deg/s)</code> (default)| scalar with unit of damping coefficient</h5><p>Damping coefficient of the internal spring-damper force law for thejoint primitive, specified as a scalar with a unit of dampingcoefficient.</p><p>关节基元的内部弹簧-阻尼力定律的阻尼系数，指定为具有阻尼系数单位的标量。</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> MATLAB仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> MATLAB仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simulink机器人仿真库</title>
      <link href="/2022/03/27/simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93/"/>
      <url>/2022/03/27/simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h4 id="simulink机器人仿真库">simulink机器人仿真库</h4><p>[TOC]</p><span id="more"></span><h2 id="forward-dynamics-正向动力学">Forward Dynamics 正向动力学</h2><p>给定关节扭矩和状态的关节加速度</p><p><strong>Library:</strong> Robotics System Toolbox / ManipulatorAlgorithm</p><p><img src="image-20220327131159671.png" alt="image-20220327131159671"  /></p><h3 id="description">Description</h3><p>The Forward Dynamics block computes joint accelerations for a robotmodel given a robot state that is made up of joint torques, jointstates, and external forces. To get the joint accelerations, specify therobot configuration (joint positions), joint velocities, appliedtorques, and external forces.</p><p>Forward Dynamics模块在给定由关节扭矩、关节状态和外力组成的机器人状态下计算机器人模型的关节加速度。要获得关节加速度，请指定机器人配置（关节位置）、关节速度、施加的扭矩和外力。</p><p>The Forward Dynamics block computes joint accelerations for a robotmodel given a robot state that is made up of joint torques, jointstates, and external forces. To get the joint accelerations, specify therobot configuration (joint positions), joint velocities, appliedtorques, and external forces.</p><p>Specify the robot model in the <strong>Rigid body tree</strong>parameter as a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object, and set the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html#bvan8uq-1-Gravity">Gravity</a>property on the object. You can also import a robot model from an URDF(Unified Robot Description Formation) file using <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>Forward Dynamics模块在给定由关节扭矩、关节状态和外力组成的机器人状态下计算机器人模型的关节加速度。要获得关节加速度，请指定机器人配置（关节位置）、关节速度、施加的扭矩和外力。</p><p>将刚体树参数中的机器人模型指定为rigidBodyTree对象，并在该对象上设置Gravity属性。您还可以使用 importrobot 从URDF（统一机器人描述格式）文件中导入机器人模型。</p><h3 id="ports">Ports</h3><h4 id="input">Input</h4><h5 id="config-robot-configuration-vector"><code>Config</code> — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the <strong>Rigid bodytree</strong> parameter. You can also generate this vector for a complexrobot using the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>or <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a>functions inside a Constant or MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由<strong>刚体树</strong>参数设置。您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>或 [<code>randomConfiguration</code>] 为复杂机器人生成此向量(https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html)函数在 Constant 或 MATLAB Function 块中。</p><h5 id="jointvel-joint-velocities-vector"><code>JointVel</code> — Jointvelocities vector</h5><p>Joint velocities, specified as a vector. The number of jointvelocities is equal to the degrees of freedom (number of nonfixedjoints) of the robot.</p><p>关节速度，指定为矢量。关节速度的数量等于机器人的自由度（非固定关节的数量）。</p><h5 id="jointtorq-joint-torques-vector"><code>JointTorq</code> — Jointtorques vector</h5><p>Joint torques, specified as a vector. Each element corresponds to atorque applied to a specific joint. The number of joint torques is equalto the degrees of freedom (number of nonfixed joints) of the robot.</p><p>关节扭矩，指定为矢量。 每个元素对应于施加到特定关节的扭矩。关节扭矩的数量等于机器人的自由度（非固定关节的数量）。</p><h5 id="fext-external-force-matrix-6-by-n-matrix"><code>FExt</code> —External force matrix 6-by-<em>n</em> matrix</h5><p>外力矩阵，指定为 6×n 矩阵，其中 n 是机器人模型中的物体数量。该矩阵在对应于特定实体的行中包含非零值。每一行都是施加的力和扭矩的矢量，它们充当该特定身体的扳手。 使用带有MATLAB Function 模块的 externalForce 生成此矩阵</p><h4 id="output">Output</h4><h5 id="jointaccel-joint-accelerations-vector"><code>JointAccel</code> —Joint accelerations vector</h5><p>关节加速度，以向量形式返回。 关节加速度的数量等于机器人的自由度。</p><h3 id="parameters">Parameters</h3><h5id="rigid-body-tree-robot-model-twojointrigidbodytree-default-rigidbodytree-object"><code>Rigid body tree</code>— Robot model <code>twoJointRigidBodyTree</code> (default) |<code>RigidBodyTree</code> object</h5><p>Robot model, specified as a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object. You can also import a robot model from an URDF (Unified RobotDescription Formation) file using <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>The default robot model, <code>twoJointRigidBodyTree</code>, is arobot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>对象。 您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>从 URDF（统一机器人描述形成）文件导入机器人模型。</p><p>默认机器人模型“twoJointRigidBodyTree”是具有旋转关节和两个自由度的机器人。</p><h5id="simulate-using-type-of-simulation-to-run-interpreted-execution-default-code-generation"><code>Simulate using</code>— Type of simulation to run <code>Interpreted execution</code> (default)| <code>Code generation</code></h5><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB® interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成 - 使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><h2 id="get-jacobian-获取雅可比矩阵">Get Jacobian 获取雅可比矩阵</h2><p>Geometric Jacobian for robot configuration</p><p>用于机器人配置的几何雅可比行列式</p><p><img src="image-20220327132517323.png" alt="image-20220327132517323"  /></p><ul><li><strong>Library:</strong>Robotics System Toolbox / ManipulatorAlgorithms</li></ul><h3 id="description-1">Description</h3><p>The Get Jacobian block returns the geometric Jacobian relative to thebase for the specified end effector at the given configuration of a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>robot model.</p><p>The Jacobian maps the joint-space velocity to the end-effectorvelocity relative to the base coordinate frame. The end-effectorvelocity equals:</p><p>Get Jacobian模块返回相对于在刚体树机器人模型的给定配置下指定末端执行器的基部的几何雅可比。</p><p>雅可比将关节空间速度映射到相对于基本坐标系的末端执行器速度。末端执行器速度等于：</p><p><img src="simulink%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F%E5%BA%93.assets/image-20220327132908638.png" alt="image-20220327132908638" style="zoom: 80%;" /></p><p><span class="math inline">\(\omega\)</span>is the angular velocity,<span class="math inline">\(v\)</span> is the linear velocity, and<spanclass="math inline">\(\dot q\)</span>is the joint-space velocity.</p><h3 id="ports-1">Ports</h3><h4 id="input-1">Input</h4><h5 id="config-robot-configuration-vector-1">Config — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the <strong>Rigid bodytree</strong> parameter. You can also generate this vector for a complexrobot using the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>or<ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a>functions inside a Constant or MATLAB Function block</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由刚体树参数设置。您还可以使用 Constant 或 MATLAB Function 模块中的 homeConfiguration 或randomConfiguration 函数为复杂机器人生成此向量</p><h4 id="output-1">Output</h4><h5id="jacobian-geometric-jacobian-of-end-effector-6-by-n-matrix">Jacobian— Geometric Jacobian of end effector 6-by-n matrix</h5><p>Geometric Jacobian of the end effector with the specifiedconfiguration, Config, returned as a 6-by-n matrix, where n is thenumber of degrees of freedom of the end effector. The Jacobian maps thejoint-space velocity to the end-effector velocity relative to the basecoordinate frame. The end-effector velocity equals:</p><p><img src="image-20220327133500482.png" alt="image-20220327133500482"  /></p><p><span class="math inline">\(\omega\)</span>is the angular velocity,<span class="math inline">\(v\)</span> is the linear velocity, and<spanclass="math inline">\(\dot q\)</span>is the joint-space velocity.</p><p>具有指定配置 Config 的末端执行器的几何雅可比矩阵以 6×n矩阵形式返回，其中 n 是末端执行器的自由度数。雅可比将关节空间速度映射到相对于基本坐标系的末端执行器速度。末端执行器速度等于：</p><h4 id="parameters-1">Parameters</h4><h5id="rigid-body-tree-robot-model-twojointrigidbodytree-default-rigidbodytree-object-1">Rigidbody tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTreeobject</h5><p>Robot model, specified as a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object. You can also import a robot model from an URDF (Unified RobotDescription Formation) file using <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>.</p><p>The default robot model, <code>twoJointRigidBodyTree</code>, is arobot with revolute joints and two degrees of freedom.</p><p>机器人模型，指定为 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>对象。 您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/importrobot.html"><code>importrobot</code></a>从 URDF（统一机器人描述形成）文件导入机器人模型。</p><p>默认机器人模型“twoJointRigidBodyTree”是具有旋转关节和两个自由度的机器人。</p><h5 id="end-effector-end-effector-for-jacobian-body-name">End effector —End effector for Jacobian body name</h5><p>End effector for <code>Jacobian</code>, specified as a body name fromthe <strong>Rigid body tree</strong>robot model. To access body namesfrom the robot model, click <strong>Select body</strong>.</p><p>Jacobian 的末端执行器，指定为刚体树机器人模型中的身体名称。要从机器人模型访问身体名称，请单击选择身体。</p><h5 id="simulate-using-type-of-simulation-to-run">Simulate using — Typeof simulation to run</h5><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB®interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p><h2 id="get-transform-获取转换矩阵">Get Transform 获取转换矩阵</h2><p>Get transform between body frames</p><p>获取身体帧之间的变换</p><ul><li><strong>Library:</strong>Robotics System Toolbox / ManipulatorAlgorithms</li></ul><p><img src="image-20220327140329832.png" alt="image-20220327140329832"  /></p><h3 id="description-2">Description</h3><p>The Get Transform block returns the homogeneous transformationbetween body frames on the <strong>Rigid body tree</strong> robot model.Specify a <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html"><code>rigidBodyTree</code></a>object for the robot model, and select a source and target body in theblock.</p><p>The block uses <strong>Config</strong>, the robot configuration(joint positions) input, to calculate the transformation from the sourcebody to the target body. This transformation is used to convertcoordinates from the source to the target body. To convert to basecoordinates, use the base body name as the <strong>Target body</strong>parameter.</p><p>Get Transform 块返回刚体树机器人模型上的身体框架之间的齐次变换。为机器人模型指定一个刚体树对象，并在块中选择一个源体和目标体。</p><p>该块使用Config（机器人配置（关节位置）输入）来计算从源体到目标体的转换。此转换用于将坐标从源体转换为目标体。要转换为基础坐标，请使用基础主体名称作为目标主体参数。</p><h3 id="ports-2">Ports</h3><h4 id="input-2">Input</h4><h5 id="config-robot-configuration-vector-2">Config — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the <strong>Rigid bodytree</strong> parameter. You can also generate this vector for a complexrobot using the <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>or<ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html"><code>randomConfiguration</code></a>functions inside a Constant or MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由<strong>刚体树</strong>参数设置。您还可以使用 <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.homeconfiguration.html"><code>homeConfiguration</code></a>或 [<code>randomConfiguration</code>] 为复杂机器人生成此向量(https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.randomconfiguration.html)函数在 Constant 或 MATLAB Function 块中。</p><h4 id="output-2">Output</h4><h5 id="transform-homogeneous-transform-4-by-4-matrix">Transform —Homogeneous transform 4-by-4 matrix</h5><p>Homogeneous transform, returned as a 4-by-4 matrix. 齐次变换，以 4×4矩阵形式返回。 #### Parameters ##### Rigid body tree — Robot modeltwoJointRigidBodyTree (default) | RigidBodyTree object Robot model,specified as a rigidBodyTree object. You can also import a robot modelfrom an URDF (Unified Robot Description Formation) file usingimportrobot.</p><p>The default robot model, twoJointRigidBodyTree, is a robot withrevolute joints and two degrees of freedom.</p><p>机器人模型，指定为一个刚体树对象。 您还可以使用 importrobot 从URDF（统一机器人描述格式）文件中导入机器人模型。</p><p>默认机器人模型 twoJointRigidBodyTree是具有旋转关节和两个自由度的机器人。</p><h5 id="target-body-target-body-name-body-name"><code>Target body</code>— Target body name body name</h5><p>Target body name, specified as a body name from the robot modelspecified in <strong>Rigid body tree</strong>. To access body names fromthe robot model, click <strong>Select body</strong>. The target frame isthe coordinate system you want to transform points into.</p><p>目标坐标系名称，指定为刚体树中指定的机器人模型的身体名称。要从机器人模型访问身体名称，请单击选择身体。目标框架是您要将点转换到的坐标系。</p><h5 id="source-body-source-body-name-body-name"><code>Source body</code>— Source body name body name</h5><p>Source body name, specified as a body name from the robot modelspecified in <strong>Rigid body tree</strong>.To access body names fromthe robot model, click <strong>Select body</strong>. The source frame isthe coordinate system you want points transformed from.</p><p>源身体名称，指定为刚体树中指定的机器人模型的身体名称。要从机器人模型访问身体名称，请单击选择身体。源框架是您想要转换点的坐标系。</p><h5 id="simulate-using-type-of-simulation-to-run-1">Simulate using —Type of simulation to run</h5><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB®interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p><h2 id="gravity-torque">Gravity Torque</h2><p>Joint torques that compensate gravity</p><p>补偿重力的关节扭矩</p><p><img src="image-20220327154957257.png" alt="image-20220327154957257"  /></p><h3 id="description-3">Description</h3><p>The Gravity Torque block returns the joint torques required to holdthe robot at a given configuration with the current <ahref="https://www.mathworks.com/help/releases/R2020b/robotics/ref/rigidbodytree.html#bvan8uq-1-Gravity">Gravity</a>setting on the <strong>Rigid body tree</strong> robot model.</p><p>Gravity Torque 块返回在刚体树机器人模型上使用当前 Gravity设置将机器人保持在给定配置所需的关节扭矩。</p><h3 id="ports-3">Ports</h3><h4 id="input-3">Input</h4><h5 id="config-robot-configuration-vector-3"><code>Config</code> — Robotconfiguration vector</h5><p>Robot configuration, specified as a vector of positions for allnonfixed joints in the robot model, as set by the Rigid body treeparameter. You can also generate this vector for a complex robot usingthe homeConfiguration or randomConfiguration functions inside a Constantor MATLAB Function block.</p><p>机器人配置，指定为机器人模型中所有非固定关节的位置向量，由刚体树参数设置。您还可以使用 Constant 或 MATLAB Function 模块中的 homeConfiguration 或randomConfiguration 函数为复杂机器人生成此向量。</p><h4 id="output-3">Output</h4><h5 id="jointtorq-joint-torques-vector-1"><code>JointTorq</code> — Jointtorques vector</h5><p>Joint torques, specified as a vector. Each element corresponds to atorque applied to a specific joint. The number of joint torques is equalto the degrees of freedom (number of nonfixed joints) of the robot.</p><p>关节扭矩，指定为矢量。 每个元素对应于施加到特定关节的扭矩。关节扭矩的数量等于机器人的自由度（非固定关节的数量）。</p><h4 id="parameters-2">Parameters</h4><h5id="rigid-body-tree-robot-model-twojointrigidbodytree-default-rigidbodytree-object-2">Rigidbody tree — Robot model twoJointRigidBodyTree (default) | RigidBodyTreeobject</h5><p>Robot model, specified as a rigidBodyTree object. You can also importa robot model from an URDF (Unified Robot Description Formation) fileusing importrobot.</p><p>The default robot model, twoJointRigidBodyTree, is a robot withrevolute joints and two degrees of freedom.</p><p>机器人模型，指定为一个刚体树对象。 您还可以使用 importrobot 从URDF（统一机器人描述格式）文件中导入机器人模型。</p><p>默认机器人模型 twoJointRigidBodyTree是具有旋转关节和两个自由度的机器人。 ##### Simulate using — Type ofsimulation to run</p><ul><li><code>Interpreted execution</code> — Simulate model using theMATLAB®interpreter. This option shortens startup time but has a slowersimulation speed than <code>Code generation</code>. In this mode, youcan debug the source code of the block.</li><li><code>Code generation</code> — Simulate model using generated Ccode. The first time you run a simulation, Simulink® generates C codefor the block. The C code is reused for subsequent simulations, as longas the model does not change. This option requires additional startuptime, but the speed of the subsequent simulations is comparable to<code>Interpreted execution</code>.</li></ul><p><strong>Tunable:</strong> No</p><p>解释执行 - 使用 MATLAB® 解释器模拟模型。此选项可缩短启动时间，但仿真速度比代码生成慢。在这种模式下，您可以调试块的源代码。</p><p>代码生成——使用生成的 C 代码模拟模型。 第一次运行仿真时，Simulink®会为模块生成 C 代码。 只要模型不改变，C 代码就可以重复用于后续仿真。此选项需要额外的启动时间，但后续模拟的速度与解释执行相当。</p><p>可调：否</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> MATLAB仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> MATLAB仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代学习控制</title>
      <link href="/2022/03/24/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/03/24/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代学习控制">迭代学习控制</h3><p>迭代学习控制（iterative learningcontrol，ILC）是智能控制中具有严格数学描述的一个分支。1984年，Arimoto等人提出了迭代学习控制的概念，该控制方法适合于<strong>具有重复运动性质</strong>的被控对象，它不依赖于系统的精确数学模型，能以非常简单的方式处理不确定度相当高的非线性强耦合动态系统。目前，迭代学习控制在学习算法、收敛性、鲁棒性、学习速度及工程应用研究上取得了巨大的进展。近年来，迭代学习控制理论和应用在国外得到快速发展，取得了许多成果。在国内，迭代学习控制理论也得到广泛的重视，有许多重要著作出版，发表了许多综述性论文。</p><span id="more"></span><h4 id="迭代学习控制基本原理">1、迭代学习控制基本原理</h4><p>设被控对象的动态过程为 <span class="math display">\[\dot x(t)=f(x(t),u(t),t), y(t)=g(x(t),u(t),t)\]</span> 其中，<span class="math inline">\(x\in R^n\)</span>、<spanclass="math inline">\(y\in R^m\)</span>、<spanclass="math inline">\(u\inR^r\)</span>分别为系统的状态、输出和输入变量，<spanclass="math inline">\(f(·)\)</span>、<spanclass="math inline">\(g(·)\)</span>为适当维数的向量函数，其结构与参数均未知。若期望控制<spanclass="math inline">\(u_d(t)\)</span>存在，则迭代学习<strong>控制的目标</strong>为：给定期望输出<spanclass="math inline">\(y_d(t)\)</span>和每次运行的初始状态<spanclass="math inline">\(x_k(0)\)</span>，要求在给定的时间<spanclass="math inline">\(t\in[0,T]\)</span>内，按照一定的学习控制算法通过多次重复的运行，使控制输入<spanclass="math inline">\(u_k(t)\rightarrow u_d(t)\)</span>，而系统输出<spanclass="math inline">\(y_k(t)\rightarrow y_d(t)\)</span>。第<spanclass="math inline">\(k\)</span>次运行时，式<spanclass="math inline">\((1)\)</span>表示为 <span class="math display">\[\dot x_k(t)=f(x_k(t),u_k(t),t), y_k(t)=g(x_k(t),u_k(t),t)\]</span> 跟踪误差为 <span class="math display">\[e_k(t)=y_d(t)-y_k(t)\]</span> 迭代学习控制可分为以下开环学习和闭环学习两种方法：</p><p>（1）开环学习控制的方法是：第<spanclass="math inline">\(k+1\)</span>次的控制等于第<spanclass="math inline">\(k\)</span>次控制再加上第<spanclass="math inline">\(k\)</span>次输出误差的校正项，即 <spanclass="math display">\[u_{k+1}(t)=L(u_k(t),e_k(t))\]</span> （2）闭环学习控制的方法是：取第<spanclass="math inline">\(k十1\)</span>次运行的误差作为学习的修正项，即<span class="math display">\[u_{k+1}(t)== L(u_k(t),e_{k+1}(t))\]</span> 其中，L为线性或非线性算子。</p><p><img src="20211203022736652.jpg" alt="20211203022736652"  /></p><h4 id="基本的迭代学习控制算法">2、基本的迭代学习控制算法</h4><p>Arimoto等首先给出了线性时变连续系统的D型迭代学习控制律 <spanclass="math display">\[u_{k+1}(t)=u_k(t)+\Gamma \dot e_k(t)\]</span> 其中，<spanclass="math inline">\(\Gamma\)</span>为常数增益矩阵。在D型算法的基础上，相继出现了P型、PI型、PD型迭代学习控制律。从一般意义来看它们都是PID型迭代学习控制律的特殊形式，PID迭代学习控制律表示为<span class="math display">\[u_{k+1}(t)=u(t)+\Gamma \dot e_k(t)+\Phie_K(T)+\Psi\int_{0}^{t}e_k(\tau)d\tau\]</span> 其中，<span class="math inline">\(\Gamma\)</span>、<spanclass="math inline">\(\Phi\)</span>、<spanclass="math inline">\(\Psi\)</span>为学习增益矩阵。算法中的误差信息使用<spanclass="math inline">\(e_k(t)\)</span>称为开环迭代学习控制，如果使用<spanclass="math inline">\(e_{k+1}(t)\)</span>则称为闭环迭代学习控制，如果同时使用<spanclass="math inline">\(e_k(t)\)</span>和<spanclass="math inline">\(e_{k+1}(t)\)</span>则称为开闭环迭代学习控制。</p><p>此外，还有高阶迭代学习控制算法、最优迭代学习控制算法、遗忘因子迭代学习控制算法和反馈-前馈迭代学习控制算法等。</p><h4 id="迭代学习控制主要分析方法">3、迭代学习控制主要分析方法</h4><p>学习算法的收敛性分析是迭代学习控制的核心问题，这方面的研究成果很丰富。</p><p>1、基本的收敛性分析方法</p><p>对于如下线性离散系统： <span class="math display">\[\left\{\begin{matrix}x(t+1)=Ax(t)+Bu(t) \\y(t)=Cx(t)\end{matrix}\right.\]</span> 迭代学习控制算法为 <span class="math display">\[u_{k+1}(t)=u_k(t)+\Gamma e_k(t+1)\]</span> 针对学习算法式<spanclass="math inline">\((9)\)</span>的收敛性，有以下两种分析方法：</p><p>（1）压缩映射方法：即系统要求满足全局<spanclass="math inline">\(Lipschitz\)</span>条件和相同的初始条件，如果 <spanclass="math inline">\(||I-CBT||&lt;1\)</span>,则有 <spanclass="math display">\[\parallele_{K+1}\parallel=\parallel(I-CB\Gamma)e_K\parallel&lt;\parallelI-CB\Gamma\parallel \parallel e_k\parallel&lt;\parallel e_k\parallel\]</span> 此时算法是单调收敛的。该方法依赖于范数的选择，常用的有<spanclass="math inline">\(l_1\)</span>范数、<spanclass="math inline">\(l_2\)</span>范数、<spanclass="math inline">\(l_\infty\)</span>范数 及<spanclass="math inline">\(\lambda\)</span>范数。在收敛性证明过程中常用到<spanclass="math inline">\(Bellman-Gronwall\)</span>引理。</p><p>（2）谱半径条件法：如果谱半径<spanclass="math inline">\(\rho\)</span>满足<spanclass="math inline">\(\rho(I-CB\Gamma)\leq \rho &lt;1\)</span>，则有<span class="math display">\[\lim_{k \to \infty}\parallel e_k \parallel = \lim_{k \to \infty}\parallel(I- CB\Gamma)e_{k-1}\parallel = \lim_{k \to \infty}\rho(I-CB\Gamma)^k\parallel e \parallel\]</span> 即$ _ {k }e_k$。</p><p>2、基于2-D理论的分析方法</p><p>迭代学习控制系统的学习是按两个相互独立的方向进行：时间轴方向和迭代次数轴方向，因此选代学习过程本质上是二维系统，可利用成熟的2-D系统理论系统地研究和分析时间域的稳定性和迭代次数域的收敛性问题。2-D系统的稳定性理论为迭代学习控制的收敛性证明提供了一种非常有效的方法，2-D系统理论中的Roesser模型成为迭代学习控制中最基本的分析模型。</p><p>3.基于Lyapunov直接法的设计方法</p><p>Lyapunov直接法已广泛用于非线性动态系统的控制器设计和分析中，在研究非线性不确定系统时，该方法是最重要的应用工具之一。受Lyapunov直接法的启发，在时间域和迭代域能量函数的概念得到研究，它为学习控制在迭代域设计和收敛性分析方面提供了一种新的研究方法。</p><p>在迭代域能量函数的迭代学习控制方法基础上，发展了鲁棒和自适应迭代学习控制，可解决具有参数或非参数不确定性非线性系统控制器的设计，近年来反映时间域和迭代域系统能量的组合能量函数方法也应用于迭代学习控制，它可保证在迭代域跟踪误差的渐近收敛以及在时间域具有有界和逐点跟踪的动态特性，并且控制输入在整个迭代区间内是范数收敛的，适用于一类不具有全局Lipschitz条件的非线性系统。通过能量函数的方法，许多新的控制方法，如反演设计和非线性优化方法都作为系统设计工具应用到迭代学习控制中。此外，还有最优化分析方法、频域分析法等分析方法。#### 4、选代学习控制的关键技术 1.学习算法的稳定性和收敛性</p><p>稳定性与收敛性是研究当学习律与被控系统满足什么条件时，选代学习控制过程才是稳定收敛的。算法的稳定性保证了随着学习次数的增加，控制系统不发散，但是对于学习控制系统而言，仅仅稳定是没有实际意义的，只有使学习过程收敛到真值，才能保证得到的控制为某种意义下最优的控制。收敛是对学习控制的最基本要求，多数学者在提出新的学习律的同时，基于被控对象的一些假设，给出了收敛的条件。例如，Arimoto在最初提出PID型学习控制律时，仅针对线性系统在D型学习律下的稳定性和收敛条件作了证明。</p><p>2.初始值问题</p><p>运用迭代学习控制技术设计控制器时，只需要通过重复操作获得的受控对象的误差或误差导数信号。在这种控制技术中，迭代学习总要从某初始点开始，初始点指初始状态或初始输出。几乎所有的收敛性证明都要求初始条件是相同的，解决选代学习控制理论中的初始条件问题一直是人们追求的目标之一。目前已提出的迭代学习控制算法大多数要求被控系统每次运行时的初始状态在期望轨迹对应的初始状态上，即满足初始条件：<span class="math display">\[x_k(0)=x_d(0),k=0,1,2,…\]</span>当系统的初始状态不在期望轨迹上，而在期望轨迹的某一很小的邻域内时，通常把这类问题归结为学习控制的鲁棒性问题研究。</p><p>3.学习速度问题</p><p>在迭代学习算法研究中，其收敛条件基本上都是在学习次数<spanclass="math inline">\(k→\infty\)</span>下给出的。而在实际应用场合，学习次数<spanclass="math inline">\(k→\infty\)</span>显然是没有任何实际意义的。因此，如何使迭代学习过程更快地收敛于期望值是迭代学习控制研究中的另一个重要问题。ILC本质上是一种前馈控制技术，大部分学习律尽管证明了学习收敛的充分条件，但收敛速度还是很慢。可利用多次学习过程中得到的知识来改进后续学习过程的速度，例如，采用高阶迭代控制算法、带遗忘因子的学习律、利用当前项或反馈配置等方法来构造学习律，可使收敛速度大大加快。</p><p>4.鲁棒性问题</p><p>迭代学习控制理论的提出有浓厚的工程背景，因此仅仅在无干扰条件下过论收敛性问题是不够的，还应讨论存在各种干扰的情形下系统的跟踪性能。一个实际运行的迭代学习控制系统除了存在初始偏移外，还或多或少存在状态扰动、测量噪声、输入扰动等各种干扰。鲁棒性问题讨论存在各种干扰时迭代学习控制系统的跟踪性能。具体地说，一个迭代学习控制系统是鲁棒的，指系统在各种有界干扰的影响下，其迭代轨迹能收敛到期望轨迹的邻域内，而当这些干扰消除时，迭代轨迹会收敛到期望轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械臂的PD控制</title>
      <link href="/2022/03/23/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84PD%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/03/23/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84PD%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="机械臂的pd控制">机械臂的PD控制</h3><h3 id="控制率设计">1 控制率设计</h3><p>当忽略重力和外部干扰的时候，采用独立的PD控制，可以满足机械臂的定点控制的要求。</p><span id="more"></span><p>设n关节机械臂的动力学方程为 <span class="math display">\[D(q)\ddot q+ C(q,\dot q)\dot q=\tau\]</span> 其中，<span class="math inline">\(D(q)\)</span>为$nn <spanclass="math inline">\(正定惯性矩阵，\)</span>C(q,q)<spanclass="math inline">\(为\)</span>nn$的离心和哥氏力项。</p><p>独立的PD控制率为 <span class="math display">\[\tau =K_d\dot e +K_pe\]</span> 取跟踪误差为<spanclass="math inline">\(e=q_d-q\)</span>，采用定点控制时，<spanclass="math inline">\(q_d\)</span>为常值，则<spanclass="math inline">\(\dot q_d=\ddot q_d\equiv 0\)</span></p><p>此时，机械臂方程为 <span class="math display">\[D(q)(\ddot q_d-\ddot q)+C(q,\dot q)(\dot q_d - \dot q)+K_d\dot e +K_pe=0\]</span> 即 <span class="math display">\[D(q)\ddot e+C(q,\dot q)\dot e +K_pe=-K_d\dot e\]</span> 取Lyapunov李雅普诺夫函数为 <span class="math display">\[V= \frac{1}{2}\dot e^TD(q)\dot e+\frac{1}{2}e^TK_pe\]</span> 由<span class="math inline">\(D(q)\)</span>和<spanclass="math inline">\(K_p\)</span>的正定性可知，<spanclass="math inline">\(V\)</span>是全局正定的，则 <spanclass="math display">\[\dot V=\dot e^TD\ddot e+\frac{1}{2}\dot e^T\dot D\dot e+\dot e^TK_pe\]</span> 利用<span class="math inline">\(\dot D-\ddot2C\)</span>的斜对称性可知，<span class="math inline">\(\dot e^TD\ddote=2\dot e^TC\ddot e\)</span>则 <span class="math display">\[\dot V=\dot e^TD\ddot e+\dot e^T C\dot e+\dot e^TK_pe=\dot e^T(D\ddote+C\dot e+K_p e)=-\dot e^TK_d\dot e \leq 0\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输出受限引理</title>
      <link href="/2022/03/22/%E8%BE%93%E5%87%BA%E5%8F%97%E9%99%90%E5%BC%95%E7%90%86/"/>
      <url>/2022/03/22/%E8%BE%93%E5%87%BA%E5%8F%97%E9%99%90%E5%BC%95%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在实际系统的控制系统中，为了保证系统的安全性，通常会对系统的输出的上下界做出严格的限制，或者要求系统的超调量在一定的范围内，超调量过大往往意味着系统处于不理想的运行状态，某些情况下，会对系统本身产生不可预知的影响。</p><span id="more"></span><h4 id="引理1.1">引理1.1</h4><p>针对系统误差 <span class="math display">\[\dot{z}=f(t,z), z=[z_1,z_2]^T\]</span> 存在连续可微的正定函数<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>，<spanclass="math inline">\(k_b&gt;0\)</span>,位置输出为<spanclass="math inline">\(X_1\)</span>,定义为位置误差<spanclass="math inline">\(z_1=x_1-y_d\)</span>，满足</p><p>（1）当<span class="math inline">\(z_1\rightarrow-k_b\)</span>或<spanclass="math inline">\(z_1\rightarrow k_b\)</span>时，有<spanclass="math inline">\(V_1(z_1)\rightarrow \infty\)</span>；</p><p>（2）<span class="math inline">\(\gamma_1(|| z_2||)\leqV_2(z_2)\leq\gamma_2(||z_2||))\)</span>,<spanclass="math inline">\(\gamma_1\)</span>为<spanclass="math inline">\(\gamma_2\)</span>为<spanclass="math inline">\(K_\infty\)</span>类函数；</p><p>假设</p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adaptive Neural Network Control of a Robotic Manipulator With Time-V arying Output Constraints</title>
      <link href="/2022/03/21/Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints/"/>
      <url>/2022/03/21/Adaptive-Neural-Network-Control-of-a-Robotic-Manipulator-With-Time-V-arying-Output-Constraints/</url>
      
        <content type="html"><![CDATA[<h3id="adaptive-neural-network-control-of-a-robotic-manipulator-with-time-v-arying-output-constraints">AdaptiveNeural Network Control of a Robotic Manipulator With Time-V aryingOutput Constraints</h3><h3id="带时变输出约束的机械臂自适应神经网络控制">带时变输出约束的机械臂自适应神经网络控制</h3><span id="more"></span><h4 id="摘要">摘要</h4><p>研究了不确定n自由度机器人机械臂受时变输出约束的控制问题。将刚性机械臂系统描述为多输入多输出的非线性系统。我们设计了一个干扰观测器来估计来自人类和环境的未知干扰。为了解决不确定性问题，采用径向基函数的神经网络对机械臂的未知动力学进行估计。在控制设计过程中，采用了非对称势垒(障碍)李雅普诺夫函数，避免了输出约束的时变。仿真结果验证了该控制方案的有效性。</p><p>Adaptive neural network (NN) control, barrier</p><p>Lyapunov function (BLF), disturbance observer (DO)</p><h4 id="论文拟解决的主要问题"><strong>论文拟解决的主要问题</strong></h4><p>机器人系统的输入输出普遍存在饱和、死区、安全规范等约束。由于现在要求机器人与人类和环境有更多的物理互动，违反这些约束所产生的安全问题是不可忽视的。因此，我们需要设计有针对性的控制器来处理这些问题。在人与环境的相互作用下，对未知的动力学和未知的扰动的不确定机械臂的控制具有挑战性。</p><p>传统的李雅普诺夫函数的目标是实现有保证的全局或半全局稳定性，而在本文中，我们不仅要保证系统的半全局稳定性，而且要避免时变约束的冲突。研究中常见的约束通常是常数约束，而常数约束可以看作是一种特殊的时变约束，因此时变约束的研究更为实际。现有的大量论文考虑了无约束的非线性系统、具有输入约束的非线性系统、具有恒定输出约束的非线性系统，或具有时变输出约束的某些SISO非线性系统。因此，需要解决MIMO未知机器人系统在未知扰动和时变输出约束下的控制问题</p><h4 id="论文主要研究内容"><strong>论文主要研究内容</strong></h4><p>利用自适应神经网络对机械臂系统的不确定动力学进行补偿。在控制设计过程中利用非对称blf（障碍李雅普诺夫函数）来克服输出约束的时变问题。本文的主要贡献如下:</p><p>1)通过基于神经网络的自适应控制律，成功地补偿了系统不确定性的影响，提高了机器人系统的鲁棒性。</p><p>2)将神经网络估计误差与来自人、环境的未知干扰集成为一个组合干扰，最后由DO逼近。</p><p>3)为了避免时变约束的冲突，采用非对称blf设计控制律，成功实现了渐近跟踪。</p><h4 id="论文的算法"><strong>论文的算法</strong></h4><p><img src="1.png" alt="1"  /></p><p><img src="2.png" alt="2" style="zoom:67%;" /></p><p>控制目标就是设计控制率，使得输出可以跟踪轨迹q，同时不能违反时变输出约束，如果给出了时变的边界，kc和kc-，输出qt就应该在这个边界内。</p><p><img src="3.png" alt="3" style="zoom: 80%;" /></p><h4 id="控制算法设计"><strong>控制算法设计</strong></h4><p>使用神经网络来弥补系统不确定性的影响，并使用时变的blf来避免时变约束的冲突。我们定义了一种新的由神经网络估计误差和来自人类和环境的未知外部干扰组成的复合干扰，该复合干扰由DO估计。控制策略如图2所示。</p><p><img src="4.png" alt="4"  /></p><p><img src="5.png" alt="5"  /></p><p>定义了误差变量z1和误差变量的导数。还定义了一个新的误差变量z2，γ是辅助变量。</p><h4 id="结论"><strong>结论</strong></h4><p>我们考虑一个如图3所示的三自由度机器人机械手。该机器人有两个旋转关节和一个移动关节。手腕的位置是由两个旋转关节和一个移动关节(RRP)的两次旋转和一次平移决定的。为了验证该控制方法的有效性，对一个三自由度机器人系统进行了仿真。我们定义</p><p><img src="6.png" alt="6"  /></p><p><img src="7.png" alt="7"  /></p><p><img src="8.png" alt="8"  /></p><p><img src="9.png" alt="9"  /></p><p><img src="10.png" alt="10"  /></p><p>仿真使用了三种不同的控制率，第一个是基于模型的控制，第二个使用自适应神经网络的控制，第三个使用传统的pd控制。</p><p><img src="11.png" alt="11"  /></p><p>可以看出，输出的q可以精确地跟踪期望的轨迹qd。由图5-7可知，跟踪误差z11、z12、z13收敛到一个接近零的小值</p><p>针对一类受时变约束和未知干扰的不确定n-DOF机器人，提出了一种基于DOs的自适应神经网络控制方法。我们用神经网络估计机器人的未知动力学模型，用DOs逼近时变扰动。使用非对称BLF避免与输出约束的冲突。仿真结果表明，所提出的控制方案能在保证约束条件满足的情况下，使输出很好地跟随目标轨迹。</p><p><img src="12.png" alt="12"  /></p><p><img src="13.png" alt="13"  /></p><p>与此同时，它们的约束从未被打破。图8给出了控制输入力矩τ1、τ2和τ3。DO的近似误差如图9所示。我们可以看到，DO估计误差越来越小，最后接近于零。综上所述，本文提出的基于模型的控制方法取得了满意的控制效果。</p><p>但是，基于模型的控制律是在已知机械臂系统的精确参数的基础上建立起来的，而这些参数在实际操作中通常是未知的</p><p>对于神经网络控制律，图10表明，输出q可以在很小的误差下遵循期望的轨迹qd。由图11-13可知，跟踪误差z11、z12、z13收敛到一个接近零的小值。同时，它们都明显排斥时变边界−ka(t)和kb(t)，即不违反输出约束</p><p>Fg18表明输出q可以大致跟随所需轨迹qd，但从图20和图21可以明显看出，q2和q3的约束被打破了。图22给出了PD控制输入力矩，从中我们可以看到输入是有界的。</p><p>控制目标就是设计控制率，使得输出可以跟踪轨迹q，同时不能违反时变输出约束，如果给出了时变的边界，kc和kc-，输出qt就应该在这个边界内。</p><p><img src="14.png" alt="14"  /></p><p><img src="15.png" alt="15"  /></p><p><img src="16.png" alt="16"  /></p><p><img src="17.png" alt="17"  /></p>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 论文阅读笔记 </category>
          
          <category> 英文论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 论文，英文论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械臂相关论文列表</title>
      <link href="/2022/03/21/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/"/>
      <url>/2022/03/21/%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="论文列表">论文列表</h3><p>​ 1、Z. Yang, W. Lu, Z. Yao and B. Zhang, "Neuroadaptive backsteppingtracking control of robotic manipulators considering actuator dynamics,"The 27th Chinese Control and Decision Conference (2015 CCDC), 2015, pp.465-470, doi: 10.1109/CCDC.2015.7161737.</p><p>考虑执行器动力学的机器人神经自适应反步跟踪控制</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 机械臂Manipulator </category>
          
          <category> 论文列表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
